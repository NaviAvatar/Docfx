# 2.1 基本内置类型

## 2.1.1 算术类型

c++定义了一套基本算术类型，包括算术类型和空类型。

| 算术类型 |
| -------- |
| 字符     |
| 整型数   |
| 浮点数   |
| 布尔值   |

还有一个空类型，常见用于当函数不返回任何值时使用。

常见的算术类型如下表：

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| wchar_t     | 宽字符         | 16位         |
| char16_t    | Unicode字符    | 16位         |
| char32_t    | Unicode字符    | 32位         |
| short       | 短整型         | 16位         |
| int         | 整型           | 16位         |
| long        | 长整型         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

支持国际化的基本的字符类型是 `char` ，一个`char` 类型的大小和机器字节大小一样。

​	`c++` 规定一个`int` 至少和一个 `short` 一样大，一个`long` 至少和一个`int` 一样大，一个 `long long` 至少和一个`long` 一样大。

浮点数可表示单精度、双精度和扩展精度值。`c++` 标准只是指定了一个浮点数有效位数的最小值，大多数编译器都实现了更高的精度。通常，`float` 以1个字（32比特）来表示，`double` 以2个字（64比特）来表示，`long double` 以3个或4个字来表示。（这依赖于编译器和机器）。类型 `float` 和 `double` 分别有7和16位个有效位；类型`long double` 

### **带符号类型和无符号类型**

​	除了布尔型和扩展的字符型，其他整型可以分为带符号的和无符号的。带符号类型可以表示正数、零和负数，无符号仅能表示大于等于0的数值。

| 带符号类型 | 无符号类型         |
| ---------- | ------------------ |
| int        | unsigned int       |
| short      | unsigned short     |
| long       | unsigned long      |
| long long  | unsigned long long |

字符型比较特殊，被分为三种：`char`、`signed char`、`unsigned char`。`char` 和 `signed char`不一定一样，取决于编译器，char可能是`signed char`，也可能是 `unsigned char`。

无符号类型中，所有的数据比特都用于表示存储值，有符号类型则用一个比特表示符号，即`0`表示`+`，`1`表示`-`。

### **如何选择类型**

* 当明确知道数值不可能为负数时，选用无符号类型。
* 使用`int` 执行整数运算。现实中`short` 太小而`long` 一般和`int` 一样，如果`int` 范围不够，则用 `long long`。
* 在算术表达式中不要使用 `char` 和 `bool` ,只有在存放字符或布尔值时才使用它们。因为`char` 在一些机器上是有符号，在一些机器上是无符号。
* 执行浮点数运算使用`double` ，因为 `float`往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器，`double` 的运算比 `float` 还要快。而 `long double` 在一般情况下没必要，且计算代价高。

### 练习

**练习2.1** 类型 `int` 、`long` 、`long long` 和 `short` 的区别是什么？无符号类型和带符号类型的区别是什么？`float` 和 `double` 的区别是什么？

`int` 、`long` 、`long long` 和 `short` 都表示整形，在C++标准中，这四个类型定义的最小尺寸不一样。`short` 短整形的最小尺寸是16位，`int` 整形的最小尺寸是16位，`long` 长整形的最小尺寸是32位，`long long` 长整形的最小尺寸是64位。一个`int` 至少和一个 `short` 一样大，一个`long` 至少和一个 `int` 一样大，一个 `long long ` 至少和一个 `long` 一样大。`float` 和 `double` 都表示浮点数，`float` 用一个字表示，`double` 用两个字表示，`float` 有效为为7位，`double` 有效位为16位。

**练习2.2** 计算按揭贷款，对于利率、本金和付款分别选择何种数据类型？说明你的理由。

应选择double类型，执行浮点数运算使用`double` ，因为 `float`往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器，`double` 的运算比 `float` 还要快。而 `long double` 在一般情况下没必要，且计算代价高。

## 2.1.2 类型转换

类型转换就是将对象从一种给定的类型转换为另一种相关类型。

```c++
bool b = 42; // b 为真
int i = b; // i 的值为1
i = 3.14; // i的值为3
double pi = i; // pi的值为3.0
unsigned char c = -1; // 假设 char占8比特，c的值为255
signed char c2 = 256; // 假设 char占8比特，c2的值时未定义的
```

* 把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为 `false` ，否则结果为 `true`。
* 把一个布尔值赋给非布尔类型时，初始值为 `false` 则结果为0，初始值为 `true` 则结果为1。
* 把一个浮点数赋给整型类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
* 当把一个整数值赋值给浮点类型时，小数部分记为0。如果整数所占空间超过浮点类型的容量，精度可能有损失。
* 当赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如8比特大小的 `unsigned char` 可以表示0至255区间的值，如果给我们赋一个区间以外的值，则实际结果该值对256取模后所得的余数。比如把-1赋给8比特大小的 `unsigned char` 所得结果是255。

`一般不在算术表达式中使用布尔类型，因为布尔类型转换为整形后非零即一。`

### 含有无符号类型的表达式

当一个表达式中含有无符号和 `int` 类型变量值时，`int` 值就会转换成无符号数。

```
unsigned u =10;
int i = -42;
cout << i + i << endl;  // 输出-84
cout << u + i << endl;  // 输出 4294967264
```

这是因为32位的`unsigned int` 类型的u值为10的机器码表示为 (0000 0000 0000 0000  0000 0000 0000 1010）(二进制)，而`int` 类型的i值为-42的机器码表示为(1111 1111 1111 1111 1111 1111 1101 0110 )（负数的机器码为真值的原码取反加1，高位为1），相加后得到的机器码为(1111 1111 1111 1111 1111 1111 1110 0000)，是一个`unsigned int` 类型，所以打印输出时结果为 4294967264。

```c++
// 错误示范：这个循环会是个死循环，因为u不可能小于0。
for(unsigned u =10; u>=0;u--)
{
	cout << u << endl;
}
```

因此不要在计算表达式中混用带符号类型的变量和无符号类型的变量。

### 练习

**练习2.3** 读程序写结果：

```c++
unsigned u =10, u2 = 42;
cout << u2 - u << endl;
cout << u - u2 << endl;

int i = 10, i2 =42;
cout << i2 - i << endl;
cout << i - i2 << endl;
cout << i - u << endl;
cout << u - i << endl;
```

`unsigned int` 和 `int` 是32位的机器上的类型。

| 真值 | 机器码（补码）                             |
| ---- | ------------------------------------------ |
| 10   | `0000 0000 0000 0000 0000 0000 0000 1010`  |
| 42   | `0000 0000 0000 0000 0000 0000 0010 1010`  |
| -10  | `1111 1111 1111 1111 1111 1111 1111 0110 ` |
| -42  | `1111 1111 1111 1111 1111 1111 1101 0110 ` |

`u2 - u`， 的结果是`0000 0000 0000 0000 0000 0000 0010 0000`  ，类型是`unsigned int` ，打印的值为32。

`u - u2`， 相当于10的机器码加上 -42的机器码，返回的类型是 `unsigned int` 类型。相加后的值为 `1111 1111 1111 1111 1111 1111 1110 0000` ，打印得值为 4294967264。

`i2 - i` , 就是42的机器码加上-10的机器码，返回类型是`int` 类型。相加后的值为 `0000 0000 0000 0000 0000 0000 0010 0000`，打印的值为32。

`i - i2`，就是10的机器码加上-42的机器码，返回类型是 `int` 类型。相加后的值为`1111 1111 1111 1111 1111 1111 1110 0000`，打印的值为 -32。

`i - u` ，就是10的机器码加上 - 10的机器码，返回的是 `unsigned int 类型`，相加后的值为 `0000 0000 0000 0000 0000 0000 0000 0000`。打印的值为0。

`u - i` ，就是10的机器码加上-10的机器码，返回的是`unsigend int ` 类型，相加后的值为 `0000 0000 0000 0000 0000 0000 0010 0000` ,打印的值为0。

## 2.1.3 字面值常量

如“42”，”A“，这样的值，一望而知，称为字面值常量，每个字面值常量对应一种数据类型。

### 整型和浮点型字面值

**整型字面值**

| 十进制 | 八进制  | 十六进制     |
| ------ | ------- | ------------ |
| 20     | 024     | 0x14         |
|        | 以0开头 | 以0x或0X开头 |

**浮点型字面值**

3.14159	3.14E1	.001

### **字符和字符串字面值**

| 字符字面值 | 字符串字面值  |
| ---------- | ------------- |
| 'a'        | "hello world" |

<font color='red'>字符串由常量字符构成数组，编译器在每个字符串的结尾处添加一个空字符('\0')，因此，字符串字面值的实际长度要比它的内容多1。</font>

两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则实际上它们是个整体。

```c++
// 一行写不下，可以换行
cout << "a really, really long string literal "
		"that spans two lines" <<endl;
// 相当于 "a really, really long string literal that spans two lines"
```

### 转义序列

两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是c++语言中有特殊含义的字符。需要转义序列，转义序列均以反斜线开始。

| 名称       |      |
| ---------- | ---- |
| 换行符     | \n   |
| 纵向制表符 | \v   |
| 反斜线     | \\\\ |
| 回车符     | \r   |
| 横向制表符 | \t   |
| 退格符     | \b   |
| 问号       | \?   |
| 进纸符     | \f   |
| 报警符     | \a   |
| 双引号     | \\"  |
| 单引号     | \\'  |

泛化的转义序列，形式是\x后紧跟1个或多个十六进制数字，或\后紧跟1个或2个或3个八进制数字，其中数字部分表示的是字符对应的数值。因此，<font color='red'>反斜线\后面紧跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。如“\1234”表示两个字符，“\123”和“4”。</font>

### 指定字面值的类型

**字符和字符串字面值**

| 前缀 | 含义          | 类型     |
| ---- | ------------- | -------- |
| u    | Unicode16字符 | char16_t |
| U    | Unicode32字符 | char32_t |
| L    | 宽字符        | wchar_t  |
| u8   | UTF-8         | char     |

**整型字面值**

| 后缀     | 最小匹配类型 |
| -------- | ------------ |
| u 或 U   | unsigned     |
| l 或 L   | long         |
| ll 或 LL | long long    |

**浮点型字面值**

| 后缀   | 类型        |
| ------ | ----------- |
| f 或 F | float       |
| l 或 L | long double |

```c++
L'a'		// 宽字符类型字面值，类型是 wchar_t
u8 "hi!" 	// utf-8字符串字面值(utf-8用8位编码一个unicode字符)
42ULL		// 无符号整数字面值，类型是unsigned long long 
1E-3F		// 单精度浮点型字面值，类型是float
3.14159L	// 扩展精度浮点型字面值，类型是 long double
```

**布尔字面值和指针字面值**

| 布尔字面值    | 指针字面值 |
| ------------- | ---------- |
| true和false。 | nullptr    |

### 练习

**练习2.5** 指出下述字面值的数据类型并说明每一组内几种字面值的区别：

(a) 'a'，L'a'，“a”，L"a"

(b) 10, 10u, 10L，10uL，012，0xC

(c) 3.14，3.14f，3.14L

(d) 10，10u，10.，10e-2

 答：

​	(a)组，'a'是`char` 类型，内存占用1个字节。L'a'是 `wchar_t` 类型，内存占2个字节。“a”是字符串，存储串尾部还有一个'\0'，编码格式为ASCIII编码格式。L"a"编码格式为`Unicode` 编码格式，每个字符占用两个字节，因为串尾部结束符'\0'也占两个字节，故该串占用4个字节。

(b)组，`10` 是int类型常量，默认为有符号整型，最小尺寸为16位。`10u` 是`unsigned int` 类型，最小尺寸为16位。`10L` 是 `Long` 类型，最小尺寸为32位。`10uL` 是 `unsigned long` 类型，无符号长整型，最小尺寸为32位。012 是八进制的int类型常量，表示数值10（十进制）。0xC表示十六进制的int类型，数值为10。

(c)组，3.14表示双精度浮点数，类型为double，最小尺寸为10位有效数字。3.14f为单精度浮点数，类型为float，最小尺寸为6位有效数字.3.14L，表示 `long double` 类型，最小尺寸为10位有效数字。

(d)组，10表示int类型。10u表示`unsigned int` 类型。10.表示双精度浮点数类型double。10e-2，用科学计数法表示的浮点数0.1。

**练习2.6** 下面两组定义是否有区别，如果有，请叙述之。

```c++
int month = 9,day = 7;
int month = 09, day =07;
```

有区别，第一行是用十进制表示month和day，值分别为9和7。第二行用八进制表示month和day，但是month的值为无效字符，八进制的位不能大于7，是错误的，编译时不通过。

**练习2.7** 下述字面值表示何种含义？它们各自的数据类型是什么？

(a) "who goes with F\145rgus?\012"、

(b) 3.14e1L	（c）1024f	(d) 3.14L

(a) \145表示小写字母e，\012表示换行符。为字符串类型，因此表示字符串为

```c++
who goes with Fergus?

```

(b) 3.14e1L表示类型为 `Long double` 类型，值为31.4。

(c) 表示类型为 `float` 类型值为1024。

(d) `long double` 类型的3.14。

**练习2.8**

请利用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "2\115\012" << endl; // 输出2M和换行
    cout << "2\t\115\012" << endl; // 输出2 制表符 M 换行
    return 0; 
}
```

