# 2.1 基本内置类型

## 2.1.1 算术类型

c++定义了一套基本算术类型，包括算术类型和空类型。

| 算术类型 |
| -------- |
| 字符     |
| 整型数   |
| 浮点数   |
| 布尔值   |

还有一个空类型，常见用于当函数不返回任何值时使用。

常见的算术类型如下表：

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8位          |
| wchar_t     | 宽字符         | 16位         |
| char16_t    | Unicode字符    | 16位         |
| char32_t    | Unicode字符    | 32位         |
| short       | 短整型         | 16位         |
| int         | 整型           | 16位         |
| long        | 长整型         | 32位         |
| long long   | 长整型         | 64位         |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

支持国际化的基本的字符类型是 `char` ，一个`char` 类型的大小和机器字节大小一样。

​	`c++` 规定一个`int` 至少和一个 `short` 一样大，一个`long` 至少和一个`int` 一样大，一个 `long long` 至少和一个`long` 一样大。

浮点数可表示单精度、双精度和扩展精度值。`c++` 标准只是指定了一个浮点数有效位数的最小值，大多数编译器都实现了更高的精度。通常，`float` 以1个字（32比特）来表示，`double` 以2个字（64比特）来表示，`long double` 以3个或4个字来表示。（这依赖于编译器和机器）。类型 `float` 和 `double` 分别有7和16位个有效位；类型`long double` 

### **带符号类型和无符号类型**

​	除了布尔型和扩展的字符型，其他整型可以分为带符号的和无符号的。带符号类型可以表示正数、零和负数，无符号仅能表示大于等于0的数值。

| 带符号类型 | 无符号类型         |
| ---------- | ------------------ |
| int        | unsigned int       |
| short      | unsigned short     |
| long       | unsigned long      |
| long long  | unsigned long long |

字符型比较特殊，被分为三种：`char`、`signed char`、`unsigned char`。`char` 和 `signed char`不一定一样，取决于编译器，char可能是`signed char`，也可能是 `unsigned char`。

无符号类型中，所有的数据比特都用于表示存储值，有符号类型则用一个比特表示符号，即`0`表示`+`，`1`表示`-`。

### **如何选择类型**

* 当明确知道数值不可能为负数时，选用无符号类型。
* 使用`int` 执行整数运算。现实中`short` 太小而`long` 一般和`int` 一样，如果`int` 范围不够，则用 `long long`。
* 在算术表达式中不要使用 `char` 和 `bool` ,只有在存放字符或布尔值时才使用它们。因为`char` 在一些机器上是有符号，在一些机器上是无符号。
* 执行浮点数运算使用`double` ，因为 `float`往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器，`double` 的运算比 `float` 还要快。而 `long double` 在一般情况下没必要，且计算代价高。

### 练习

**练习2.1** 类型 `int` 、`long` 、`long long` 和 `short` 的区别是什么？无符号类型和带符号类型的区别是什么？`float` 和 `double` 的区别是什么？

`int` 、`long` 、`long long` 和 `short` 都表示整形，在C++标准中，这四个类型定义的最小尺寸不一样。`short` 短整形的最小尺寸是16位，`int` 整形的最小尺寸是16位，`long` 长整形的最小尺寸是32位，`long long` 长整形的最小尺寸是64位。一个`int` 至少和一个 `short` 一样大，一个`long` 至少和一个 `int` 一样大，一个 `long long ` 至少和一个 `long` 一样大。`float` 和 `double` 都表示浮点数，`float` 用一个字表示，`double` 用两个字表示，`float` 有效为为7位，`double` 有效位为16位。

**练习2.2** 计算按揭贷款，对于利率、本金和付款分别选择何种数据类型？说明你的理由。

应选择double类型，执行浮点数运算使用`double` ，因为 `float`往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器，`double` 的运算比 `float` 还要快。而 `long double` 在一般情况下没必要，且计算代价高。

## 2.1.2 类型转换

类型转换就是将对象从一种给定的类型转换为另一种相关类型。

```c++
bool b = 42; // b 为真
int i = b; // i 的值为1
i = 3.14; // i的值为3
double pi = i; // pi的值为3.0
unsigned char c = -1; // 假设 char占8比特，c的值为255
signed char c2 = 256; // 假设 char占8比特，c2的值时未定义的
```

* 把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为 `false` ，否则结果为 `true`。
* 把一个布尔值赋给非布尔类型时，初始值为 `false` 则结果为0，初始值为 `true` 则结果为1。
* 把一个浮点数赋给整型类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
* 当把一个整数值赋值给浮点类型时，小数部分记为0。如果整数所占空间超过浮点类型的容量，精度可能有损失。
* 当赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如8比特大小的 `unsigned char` 可以表示0至255区间的值，如果给我们赋一个区间以外的值，则实际结果该值对256取模后所得的余数。比如把-1赋给8比特大小的 `unsigned char` 所得结果是255。

`一般不在算术表达式中使用布尔类型，因为布尔类型转换为整形后非零即一。`

### 含有无符号类型的表达式

当一个表达式中含有无符号和 `int` 类型变量值时，`int` 值就会转换成无符号数。

```
unsigned u =10;
int i = -42;
cout << i + i << endl;  // 输出-84
cout << u + i << endl;  // 输出 4294967264
```

这是因为32位的`unsigned int` 类型的u值为10的机器码表示为 (0000 0000 0000 0000  0000 0000 0000 1010）(二进制)，而`int` 类型的i值为-42的机器码表示为(1111 1111 1111 1111 1111 1111 1101 0110 )（负数的机器码为真值的原码取反加1，高位为1），相加后得到的机器码为(1111 1111 1111 1111 1111 1111 1110 0000)，是一个`unsigned int` 类型，所以打印输出时结果为 4294967264。

```c++
// 错误示范：这个循环会是个死循环，因为u不可能小于0。
for(unsigned u =10; u>=0;u--)
{
	cout << u << endl;
}
```

因此不要在计算表达式中混用带符号类型的变量和无符号类型的变量。

### 练习

**练习2.3** 读程序写结果：

```c++
unsigned u =10, u2 = 42;
cout << u2 - u << endl;
cout << u - u2 << endl;

int i = 10, i2 =42;
cout << i2 - i << endl;
cout << i - i2 << endl;
cout << i - u << endl;
cout << u - i << endl;
```

`unsigned int` 和 `int` 是32位的机器上的类型。

| 真值 | 机器码（补码）                             |
| ---- | ------------------------------------------ |
| 10   | `0000 0000 0000 0000 0000 0000 0000 1010`  |
| 42   | `0000 0000 0000 0000 0000 0000 0010 1010`  |
| -10  | `1111 1111 1111 1111 1111 1111 1111 0110 ` |
| -42  | `1111 1111 1111 1111 1111 1111 1101 0110 ` |

`u2 - u`， 的结果是`0000 0000 0000 0000 0000 0000 0010 0000`  ，类型时`unsigned int` ，打印结果为32。

`u - u2`， 相当于10的机器码加上 -42的机器码，返回的类型时 `unsigned int` 类型。相加后的值为 `1111 1111 1111 1111 1111 1111 1110 0000` ，打印值就是 4294967264。

`i2 - i` , 就是42的机器码加上-10的机器码，返回类型时`int` 类型。相加后的值为 `0000 0000 0000 0000 0000 0000 0010 0000`，打印值就是32。

`i - i2`，就是10的机器码加上-42的机器码，返回类型时 `int` 类型。相加后的值为`1111 1111 1111 1111 1111 1111 1110 0000`，打印后的值为 -32。

`i - u` ，就是10的机器码加上 - 10的机器码，返回的是 `unsigned int 类型`，相加后的值为 `0000 0000 0000 0000 0000 0000 0000 0000`。打印结果就是0。

`u - i` ，就是10的机器码加上-10的机器码，返回的是`unsigend int ` 类型，相加后的值为 `0000 0000 0000 0000 0000 0000 0010 0000` ,打印结果就是0。
