# 2.3 复合类型

​	符合类型指基于其他类型定义的类型。这里仅介绍<font color='blue'>引用</font>和<font color='blue'>指针</font>。

## 2.3.1 引用

​	引用为对象起了另一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

```c++
int ival = 1024;
int &refVal = ival;		// refVal指向ival（相当于给ival起了另一个名字）
int &refVal2;			// 报错，引用必须初始化
```

​	一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

### 引用即别名

​	引用不是一个对象，它只是一个已存在的对象所起的另一个名字，对其操作是在与之绑定的对象基础上进行操作。

```
int ival = 1024;
int &refVal = ival;		// refVal指向ival（相当于给ival起了另一个名字）
refVal = 2048
cout << ival << endl;	// 打印 2048
```

### 引用的定义

​	允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头。

```c++
int i = 1024, i2 = 2048;
int &r = i, r2 = i2;
int i3 = 1024, &ri = i3;
int &r3 = i3, &r4 = i2;
```

​	引用只能绑定在对象上，不能绑定在字面值或某个表达式的计算结果。

```
int &refVal = 1024; // 报错
double dVal = 3.14; 
int refVal2 = dVal; // 报错，引用类型的初始值类型不匹配
```

### 练习

**练习2.15** 下面的哪个定义是不合法的？

(a) int ival= 1.01;	(b) int &rvall = 1.01;

(c) int &rval2 = ival;  	(d) int &rval3;

​	答：(a)和(c)合法，(b)绑定只能绑定到对象上，不能绑定到具体的字面值上，(d)绑定必须初始化。

**练习2.16** 考查下面所有的赋值然后回答，哪些赋值是不合法的，为什么?哪些赋值是合法的，他们执行了什么操作？

int i = 0,&r1 = i; double d= 0, &r2 = d;

(a) r2 = 3.14159;	(b) r2 = r1;

(c) i = r2;	(d) r1 = d;

​	答：(a) 合法，将3.14159赋值给了与r2绑定的对象。(b) 合法，将 r1绑定对象的值，赋值给 r2绑定的对象，因为r2绑定的对象是double类型，r1 是int类型，所以是可以运行的。(c) 不合法，会报警提示可能存在数据精度丢失。(d) 不合法。会报警提示可能存在数据精度丢失。

**练习2.17** 执行下面的代码段将会输出什么？

```
int i, &ri = i;
i = 5; ri = 10;
cout << i << " " << ri <<endl;
```

​	输出10 10，这里ri与i的对象绑定在一起，对ri的任何操作都是对i的操作。

## 2.3.2 指针

​	指针是指向另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。指针是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象。指针无须在定义时赋初始值。

```
int *ip1, *ip2; // 两个指向int类型的指针
int dp, *ip3;   // dp是int类型对象，ip3是指向int类型的指针。
```

### 获取对象的地址

​	指针存放某个对象的地址，而给指针赋值地址时需要<font color='blue'>取地址符&</font>。

```
int ival = 42;
int *p = &ival;	// p指针指向ival对象
```

​	引用不是对象，无实际地址，所以不能将指针指向引用。

​	一般情况下，指针的类型要和它所指向的对象类型严格匹配。

```
double ival;
double* pd = &ival;
int* p1 = pd;  			// 报错，类型不匹配
int* p = &ival;			// 报错，类型不匹配
```

### **指针值**

​	指针的值是地址。指针要么指向一个对象，要么指向紧邻对象所占空间的下一个位置，要么是个空指针（因此对指针操作一般要进行判空），或者是个无效指针，随意访问可能导致程序崩溃。

### **利用指针访问对象**

​	要知道指针指向一个对象，直接访问指针名，其实访问的是对象的地址，而一般数据是对象的内容，因此需要一个<font color='blue'>解引用符*</font>来访问对象内容。

```c++
int ival = 42;
int *p = &ival;   // p 指向ival
cout << p;        // 输出p的地址 
cout << *p;       // 输出 42
```

​	给指针指向的对象赋值，也需要<font color= 'blue'>解引用符*</font>。

```c++
*p=1024;          // 给p指向的对象赋值
cout << *p;       // 输出 1024
cout << ival;     // 输出 1024
```

​	解引用符只适用于指针指向了明确的对象。

```c++
int ival = 42;
int* p = NULL;   // p 指向ival
cout << *p << endl; // 运行时报错
```

### **空指针**

​	空指针不指向任何对象，在试图使用一个指针之前代码可以先判空。三种生成空指针的方法。

```
int *p1 = nullptr;	// c++11标准推荐使用这种方式赋值空指针
int *p2 = 0;
int *p3 = NULL;		// NULL实际就是0
```

### 赋值和指针

​	引用一旦绑定到某个对象之后，再解绑并对另一个对象绑定是不可能的。而指针就不同，指针可以再指向另一个对象。给指针赋值(地址)，就是令指针重新存放了一个地址，从而指向一个新的对象。

​	任何非0地址的指针在条件判断是都是true。

### void* 指针

​	`void*`是一种特殊的指针类型，可用于存放任意对象的地址。一个`void*`指针存放一个地址，存放什么类型地址我们不得而知。

```c++
 double obj = 3.14159, * pd = &obj;
 void* pv = &obj;
 pv = pd;

cout << *pv << endl; 	// 报错，void* 类型不允许访问，必须提前知道void*指针指向什么类型的地址，再用该类型的指针指向void*指向的指针，方可访问对象
return 0;
```

### **练习**

**练习2.18** 编写代码分别更改指针的值以及指针所指向对象的值。

```c++
double obj = 3.14159, * pd = &obj; // pd指向obj对象
double x = 1919;
pd = &x;    // 更改pd的值，令其指向x对象
*pd = 1024; // 更改pd指向对象的值，即x值为1024
```

**练习2.19** 说明指针和引用的主要区别。

答，引用不是一个对象，没有实际地址，引用一旦绑定到某个对象，要再绑定到另一个对象是不可能的，因此引用必须初始化。指针是一个对象，有实际地址，指针可以更改值，从而指向新的对象，也不用初始化。

**练习2.20** 请叙述下面这段代码的作用。

```c++
int i =42;
int *p1 = &i;
*p1 = *p1 * *p1;
```

答：定义一个int类型变量i，指针p1指向i对象，将p1指向对象的值相乘然后赋值给pi指向的对象，因此i对象的值最后变为42*42。

**练习2.21** 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？

int i = 0;

(a) double* dp = &i;	(b) int *pi = i;	(c) int *p = &i;

答：(a)非法，非空指针要和指向的对象严格类型匹配。(b) 指针初始化时是赋值地址，而非具体对象的值。

**练习2.22** 假设p是一个int型指针，请说明下述代码的含义。

```c++
if(p) // p如果是非空指针，则执行if后的代码块
if(*p) // 指针p指向的对象如果值不为0，这执行if后的代码块
```

**练习2.23** 给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断思路；如果不能，也请说明原因。

答：可以通过判空来确定是否指向了一个合法的对象。

**练习2.24** 在下面这段代码中为什么p合法而lp非法？

int i = 42; 	void *p = &i;	long *lp = &i;

答：void*指针是特殊的指针，可以指向任意对象。而long指针只能指向long类型的对象。

## 2.3.3 理解复合类型的声明

```c++
int i = 1024, *p = i, &r = i;
```

​	只需在某行代码前面写一个关键字 int ，然后声明变量的名字用逗号分隔，可以定义不同类型的变量。

### 指向指针的指针

​	不像引用，指针是内存中的对象，有自己的地址，因此可以将指针的地址存放到另一个指针中。通过*符号的个数可以区分指针的级别。`**` 表示指向指针的指针，`***`表示指向指针的指针的指针。

```c++
int ival = 1024;
int *pi = &ival; // 指向ival的指针
int **ppi = &pi; // 指向pi指针的指针

cout << *pi << endl;   // 输出 1024
cout << *ppi << endl;  // 输出 pi的地址
cout << **ppi << endl; // 输出 1024
```

### 指向指针的引用

​	引用本身不是一个对象，因此不能定义一个指向引用的对象。但是指针是一个对象，可以定义一个指向指针的引用。

```c++
int i = 42;
int *p;
int *&r = p; // r是指向p的引用，相当于p有另一个名字：r

r=&i; // 相当于将p指向了i
*r=0; // 将i的值改为0
```

### 练习

**练习2.25** 说明下列变量的类型和值。

(a) int* ip, i, &r = i; 	(b) int i, *ip = 0; 	(c) int * ip, ip2;

答：(a) ip是个int类型指针，i是int类型对象，r是一个指向i对象的int类型引用。

(b) i是个int类型对象，ip是个空的int类型指针。

(c) ip是个int类型的指针，ip2是个int类型的对象。
