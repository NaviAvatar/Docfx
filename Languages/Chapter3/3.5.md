# 3.5 数组

​	数组是一种类似标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。数组是存放类型相同的对象的容器，这些对象本身没有名字，可以通过其所在位置访问。数组大小固定不变，不能随意向数组中添加元素。可见灵活性差了点。

## 3.5.1 定义和初始化内置数组

数组中的元素个数必须大于0；编译时维度，即数组个数应该是已知的。

```c++
unsigned int cnt = 42;	// 不是常量表达式
constexpr unsigned int sz = 42;	// 常量表达式
int arr[10];	//  含有10个整数的数组
int* parr[sz];	// 含有42 个整型指针
string bad[cnt];	// 错误，cnt不是常量表达式
string strs[get_size()];	// 当get_size是constexpr 时正确，否则错误
```

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

### 显示初始化数组

```c++
const unsigned sz = 3;
int ia1[sz] = {0, 1, 2};	// 含有3个元素的数组，元素值分别是0 ， 1， 2
int a2[] = {0, 1, 2};	//维度是3的数组
int a3[5] = {0, 1, 2};	// 等价于 a3={0,1,2,0,0}
string a4[3] = {"hi", "bye"};	// 等价于a4[] = {"hi", "bye", ""}
int a5[2] = {0, 1, 2};			// 错误，初始值过多
```

### 字符数组的特殊性

字符字面值的结尾处有一个空字符，不显示在代码中。

```c++
char a1[] = {'C', '+', '+'};	// 列表初始化，没有空字符
char a2[] = {'C', '+', '+', '\0'};	// 列表初始化，含有显式的空字符
char a3[] = "c++";					// 自动添加表示字符串结束的空字符
const char a4[6] = "Daniel";		// 错误，没有空间可存放空字符
```

### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] = {0, 1, 2};
int a2[] = a; // 错误
a2 = a;		  // 错误
```

### 理解复杂的数组声明

```c++
int *ptrs[10];		// ptrs是含有10个整型指针的数组
int &refs[10] = /*?*/;	// 错误，不存在引用数组
int (*Parray)[10] = &arr;	// Parray 指向一个含有10个整数的数组。
int (&arrRef)[10] = arr;	// arrRef 引用一个含有10个整数的数组。

(*Parray)[0] = 10;		// 正确使用
arrRef[0] = 100;		// 正确使用

int* (&array)[10] = ptrs;	// array 是数组的引用，该数组含有10个指针
```

### 练习

**练习3.27** 假设 txt_size 是一个无参数的函数，它的返回值是 int。请回答下列哪个定义是非法的，为什么？

```c++
unsigned buf_size = 1024;
(a)int ia[buf_size];	(b)int ia[4 * 7 - 14];
(c)int ia[txt_size()];	(d) char st[11] = "fundamental"; 
```

a是非法的，buf_size不是常量，数组在编译时就必须知道其大小。

c是非法的，理由同a。

d是非法的，字符串字面值结尾有一个隐含的空格字符，"fundamental"实际上的长度为12。

**练习3.28** 下列数组中元素的值是什么？

```c++
string sa[10];
int ia[10];
int main()
{
    string sa2[10];
    int ia2[10];
}
```

sa中含有10个空字符串；

ia含有10个初始化为0的字符串；

sa2数组有10个未定义的string类型；

ia2数组含有10个未定义的值。

如果打印每个数组的信息的话：

ia的打印信息为：

```c++
0
0
0
0
0
0
0
0
0
0
```

ia2的打印信息为：

```c++
-858993460
-858993460
-858993460
-858993460
-858993460
-858993460
-858993460
-858993460
-858993460
-858993460
```

和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有为定义的值。

## 3.5.2 访问数组元素

可以使用范围for语句或者下标运算符访问数组元素。数组索引从0开始。

```c++
unsigned scores[11] = {};	// 11 个分数段，全部初始化为0
unsigned grade;
while( cin>> grade)
{
    if(grade <= 100)
        ++scores[grade/10];	// 将当前分数段的计数值加1
}

for( auto i : scores)
{
    cout << i << " ";
}
```

### 检查下标的值

编译器编译时并不会检查数组下标是否越界，要靠人工检查。要防止越界行为，因为越界产生各种意想不到的后果。

### 练习

**练习3.30** 指出下面代码中的索引错误。

```c++
constexpr size_t array_size = 10;
int ia[array_size];
for(size_t ix = 1; ix <= array_size; ++ ix)
    ia[ix] = ix;
```

数组索引的下标从0开始，而for语句中的ix从1开始，遍历下标从1到10，ia[10]导致数组越界。

**练习3.31** 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。

```c++
int arr[10]={};
for(int index = 0; index < 10; index++)
{
    arr[index] = index;
}
```

**练习3.32** 将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。

```c++
int arr2[10];
for(int i = 0;i < 10; i++)
{
    arr2[i] = arr[i];
}
```

**练习3.33** 对于104页的程序来说，如果不初始化scores将会发生什么？

因为函数内部定义的数组默认初始化是未定义的值，因此可能导致数据并不是预期的。

## 3.5.3 指针和数组

​	通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针。

```c++
string nums[] = {"one", "two", "three"};	// 数组的元素是string对象
string *p = &nums[0];						// p指向nums的第一个元素

// 用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。
string *p2 = nums;	// 等价于  p2 = &nums[0];
```

```c++
int ia2[10] = {};
int* p = &ia2[3];
*p = 1;
p++;
*p = 2;

for(auto s : ia2)
{
    cout << s << " ";
}

// 打印 0 0 0 1 2 0 0 0 0 0
```

​	在一些情况下，对数组的操作，实际上是对指针的操作。如果对数组使用auto变量的初始值时，推断得到的类型是指针而非数组。

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto ia2(ia);	// ia2是一个整型指针，指向ia的第一个元素，等价于 auto ia2(&ia[0])
ia2 = 42;	// 错误。ia2是个指针
```

​	但是如果用decltype关键字时，decltype(ia)返回的类型是由10个整数构成的数组：

```c++
decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;	// 错误，ia3不能用整型指针给数组赋值
ia3[4] = i;	// 正确
```

```c++
int *e = &arr[10];	// arr数组只有10个元素，arr[10]是arr数组的最后一个元素指向的下一个位置
for(int *b = arr; b != e; ++b)
{
    cout << *b << endl;	// 输出arr的元素
}
```

### 标准库函数begin和end

​	C++11标准引入两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。这两个函数定义在头文件**iterator**中。

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7 , 8, 9};
int *beg = begin(ia);	// 指向ia首元素的指针
int *last = end(ia);	// 指向arr尾元素的下一位置的指针
```

```c++
int *pbeg = begin(arr), *pend = end(arr);
// 寻找第一个负值元素，如果已经检查完全部元素则结束
while(pbeg != pend && *pbeg > 0)
    pbeg++;
```

### 指针运算

​	可以把指针看做是一种迭代器，可以解引用、递增、比较、与整数相加、两个指针相减。

```c++
constexpr size_t sz = 5;
int arr[sz] = {1, 2, 3, 4, 5};
int *ip = arr;
int *ip2 = ip + 4;	// ip2指向arr的尾元素arr[4]
```

```c++
// 正确，arr转换成指向它的首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz;	// 不要使用解引用
int *p2 = arr + 10;	// 指向了未知内存
```

​	如果指针指向的位置超过了数组的尾元素，则会指向未知内存，访问未知内存可能引发无法意料的后果。编译器编译过程中无法发现类似的问题。

​	两指针相减是他们之间的距离。两指针相减的结果类型是名为ptrdiff_t的标准库类型，定义在cstddef头文件中的机器相关的类型。是一种有符号类型。

```c++
auto n = end(arr) - begin(arr);	// n的值是5
```

​	如果两个指针指向不相关的数组，他们之间的运算是毫无意义的。

### 解引用和指针运算的交互

​	指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。

```c++
int ia[] = {0,2,4,6,8};
int last = *(ia + 4);	// 等价于last = ia[4];
```

### 下标和指针

```c++
int ia[] = {0,2,4,6,8};
int i = ia[2];

int *p = ia;
i = *(p+2);	// 等价于i=ia[2]
```

只要指针指向的是数组中的元素，都可以执行下标运算。

```c++
int *p = &ia[2];	// p指向索引为2的元素
int j = p[1];	// p[1] 等价于*(p+1),就是ia[3]表示的那个元素
int k = p[-2];	// p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组和它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

### 练习

**练习3.34**：假定p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？

```
p1 += p2 - p1;
```

p1指向数组元素不变。如果p1和p2分别指向不同的数组，那么是非法的。

**练习3.35**：编写一段程序，利用指针将数组中的元素置为0。

```c++
int arr[sz] = { 1, 2, 3, 4, 5 };
auto pbegin = begin(arr);
auto pend = end(arr);
while (pbegin != pend)
{
    (*pbegin) = 0;
    pbegin++;
}
```

**练习3.36**：编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。

```c++
// 比较两个数组是否相等
int a1[] = {1,2,3,4,5};
int b1[] = {1,2,3,4,5};
bool ret = true;

// 长度不等，数组直接不相等
if(sizeof(a1) != sizeof(b1))
{
    ret = false;
}
else{
    for(int index = 0; index < sizeof(a1); index ++)
    {
        if(a1[index] != b1[index])
        {
            ret = false;
        }
    }    
}

if(ret)
{
    cout << "数组相等" << endl;
}
else
{
    cout << "数组不相等" << endl;
}
```

```c++
vector<int> vect1 = {1,2,3,4,5};
vector<int> vect2 = {1,2,3,4,5};

if(vect1 == vect2)
{
    cout << "两个vector对象相等" << endl;
}
else
{
    cout << "两个vector对象不等" << endl;
}
```

### 3.5.4 C 风格字符串

字符串字面值是一种通用结构的实例，是C++继承C而来的C风格字符串。字符串存放在字符数组中以空字符（'\0'）结束。

### C 标准库 String 函数

cstring头文件提供了一组用于操作C风格字符串的函数。

| 函数名         | 释义                                                         |
| -------------- | ------------------------------------------------------------ |
| strlen(p)      | 返回p的长度，空字符不计算在内。                              |
| strcmp(p1, p2) | 比较p1和p2的相等性。如果 p1 和 p2 相等，返回0；如果 p1 > p2，返回一个正值；如果 p1 < p2，返回一个负值。 |
| strcat(p1, p2) | 将 p2 附加到 p1 之后，返回 p1。要注意p1的容量是否足够容纳下追加之后的字符串，如果不够，会报弹窗。 |
| strcpy(p1, p2) | 将 p2 拷贝给 p1，返回 p1。要注意p1的容量是否足够容纳下p2的字符串，如果不够，会报弹窗。 |

```c++
char s1[80] = "this is a world station6";
char s3[] = "this is a world station3";
char s2[] = "Don't go into the night with gentle.";

auto x = strcat_s(s1, s3);
cout << strlen(s1) << endl;

// 输出 48
// strcat函数现在的编译器会报不安全，使用strcat_s函数，功能一样
// 同理strcpy也由strcpy_s代替。 
```

