# 6.6 函数匹配

```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);	// 调用 void f(double, double);
```

 当我们调用函数时，需要确定调用的是哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，就不容易确定到底是调用哪个重载函数了。

### 确定候选函数和可行函数

​	函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为**候选函数**。候选函数具备两个特征：一是被调用的函数同名，而是其声明在调用点可见。

​	第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

​	在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。

### 寻找最佳匹配

​	函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

## 6.6.1 实参类型转换

​	为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：

1. 精确匹配，包括以下情况：

   实参类型和形参类型相同。

   实参从数组类型或函数类型转换成对应的指针类型。

   想实参添加顶层 const 或从实参中删除顶层 const。

2. 通过 const 转换实现的匹配。

3. 通过类型提升实现的匹配。

4. 通过算术类型转换或指针转换实现的匹配。

5. 通过类类型转换实现的匹配。

### 需要类型提升和算术类型转换的匹配

​	分析函数调用前，应该知道小整型一般都会提升到 int 类型或更大的整数类型。假设有两个函数，一个接受 int、另一个接受 short，则只有当调用提供的是 short 类型的值时，才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int类型；此时 short 版本反而会导致类型转换。

```c++
void ff(int);
void ff(short);
ff('a');		// char 提升成int；调用ff(int)
```

​	所有算术类型转换的级别都一样。列如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高。

```c++
void mainp(long);
void mainp(float);
mainp(3.14);	// 错误，二义性使用
```

### 函数匹配和 const 实参

​	如果重载函数的区别在于它们的引用类型的形参是否引用了 const，或者指针类型的形参是否指向 const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。

```c++
Record lookup(Account&);
Record lookup(const Account&);

const Account a;
Account b;

lookup(a);	// 调用 lookup(const Account&)
lookup(b);	// 调用 lookup(Account&);
```

