# 6.1 函数基础

​	函数定义包括：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。形参以逗号隔开，形参列表位于一对括号内。函数执行操作在语句块中，也称为函数体。

**写一个阶乘函数**

```c++
// 1 * 2 * 3 * 4 *5
int fact(int val)
{
    int ret = 1;	// 保存结果。
    while (val > 1)
        ret *= val--;
    return ret;
}

int main()
{
    int j = fact(5);
    cout << "5! is " << j << endl;
    return 0;
}
```

### 形参和实参

​	实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。编译器能以任意可行的顺序对实参求值。不一定从左到右或从右到左逐个赋值。

​	实参的类型必须与对应的形参类型匹配，这一点与之前的规则一致。函数有几个形参，必须提供相同数量的实参。

### 函数的返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

## 6.1.1 局部对象

* 名字的作用域是程序文本的一部分，名字在其中可见。

* 对象的生命周期是程序执行过程中该对象存在的一段时间。

  形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域可见，局部变量还会隐藏在外层作用域中同名的其他所有声明中的变量。

  在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。

### 自动对象

​	对于普通局部变量对应的对象，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为**自动对象**。当块的执行结束后，块中创建的自动对象的值就变成了未定义的了。

```c++
string* getString()
{
    string s = "this is a string";
    return &s;
}

int main()
{ 
    auto p = getString();
    cout << *s << endl;
    return 0;
}

// 输出空字符串，因为程序控制出了函数体getString之后，s对象已经销毁了
```

​	形参也是一种自动对象。函数开始时为形参申请空间，函数结束，形参对象被销毁。

### 局部静态变量

​	局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显示的初始化，它将执行值初始化，内置类型的局部静态变量初始化为0。

```c++
size_t count_calls()
{
    static size_t ctr = 0;	// 调用结束后，这个值仍然有效
    return ++ctr;
}

int main()
{
    for(size_t i = 0; i != 10; ++i)
    {
        cout << count_calls() << " ";
    }
    return 0;
}

// 输出：1 2 3 4 5 6 7 8 9 10
```

##  6.1.2 函数声明

​	函数名字必须在使用之前声明。函数只能定义一次，但是可以声明很多次。可以只声明不定义。函数声明和函数定义的区别就是函数声明无须函数体，用一个分号代替即可。函数声明可以省略形参的名字，但是形参的类型还是要保留的。函数的三要素：返回类型，函数名，形参类型，说明了函数所需的全部信息。函数声明也称作**函数原型**。

```c++
size_t count_calls(int, int);

int main()
{
    for (size_t i = 0; i != 10; ++i)
    {
        cout << count_calls(4, 5) << " ";
    }

    return 0;
}

size_t count_calls(int x, int y)
{
    static size_t ctr = 0;	// 调用结束后，这个值仍然有效
    return ++ctr + x + y;
}
```

### 在头文件中进行函数声明

​	可以将函数声明放在头文件中，就能确保同一函数的所有声明保持一致。如果想改变函数的接口，只需改变一条声明即可。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

## 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

### 编译和链接多个源文件

假设 fact 函数定义位于一个名为 fact.cc 的文件中，它的声明位于名为 Chapter6.h 的头文件中。显然与其他所有用到 fact 函数一样， fact.cc 应该包含 Chapter6.h 头文件。另外，我们在名为 factMain.cc 的文件中创建 main 函数， main 函数将调用 fact 函数。要生成可执行文件，必须告诉编译器我们用到的代码在哪里。分离式编译的一个好处是，如果修改其中的一个源文件，那么只需要重新编译那个改动了的文件。如果一个项目很大的话，这一机制可以节省编译时间。

​                                                                                                                                                                                                                                                    