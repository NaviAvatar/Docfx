# 12.1 动态内存和智能指针

先了解几个名词。

静态内存：操作系统保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量。

栈内存：保存定义在函数内的非 static 对象。

堆内存：动态分配的对象的存储地区。

操作系统分配在静态或栈内存中的对象由编译器自动创建和销毁。栈对象仅在其定义的程序块运行时才存在。static 对象在使用之前分配，在程序结束时销毁。

存放在堆内存的对象，由程序控制，如果不在需要这些对象，就应该手动显示释放掉，否则就存在内存泄漏。

动态内存容易出现的问题：

* 对象不需要了忘记显示释放。
* 对象还需要，但是提前释放了，等到再去访问，就出现非法访问的情况。

为了解决上述问题，新的标准库引入了两种智能指针类型来管理动态对象。智能指针负责自动释放所指向的对象。

| 智能指针   |                                        |
| ---------- | -------------------------------------- |
| shared_ptr | 允许多个指针指向同一个对象             |
| unique_ptr | “独占” 所指向的对象                    |
| weak_ptr   | 弱引用，指向 shared_ptr 所管理的对象。 |

上述三种指针都定义在头文件 memory 中。

## 12.1.1 shared_ptr 类

智能指针是一种模板。创建智能指针时，必须提供额外的信息——指针可以指向的类型。

```c++
shared_ptr<string> p1;	// 指向 string
shared_ptr<list<int>> p2;	// 指向int的list
```

默认初始化的智能指针中保存着一个空指针。

智能指针解引用得到其指向的对象：

```c++
if(p1 && p1->empty())
    *p1 = "Hi";
```

操作表：

| Shared_ptr 和 unique_ptr 支持的操作 |                                                              |
| ----------------------------------- | ------------------------------------------------------------ |
| shared_ptr<T> sp                    | 空智能指针，可以指向类型为T的对象                            |
| unique_ptr<T> up                    | 空智能指针，可以指向类型为T的对象                            |
| p                                   | 将 p 用作一个条件判断，若 p 指向一个对象，则为true           |
| *p                                  | 解引用 p，获得它返回的对象                                   |
| p->mem                              | 等价于(*p).mem，mem是p指向对象的一个成员                     |
| p.get()                             | 返回 p 中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| swap(p, q)                          | 交换p 和 q中的指针                                           |
| p.swap(q)                           | 交换p 和 q中的指针                                           |

| Shared_ptr 独有的操作 |                                                              |
| --------------------- | ------------------------------------------------------------ |
| make_shared<T> (args) | 返回一个 shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 |
| shared_ptr<T>p (q)    | p 是 shared_ptr q 的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q                 | p 和 q 都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放。 |
| p.unique()            | 若 p.use_count() 为1，返回true；否则返回false。              |
| p.use_count()         | 返回与p共享对象的智能指针数量；可能很慢，主要用于调试。      |

### make_shared 函数

​	最安全的分配和使用动态内部的方法是调用一个名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。

​	使用 make_shared 时，必须指定想要创建的对象的类型。定义方式与模板类型相同，在函数名之后跟一个尖括号，在其中给出类型：

```c++
// 指向一个值为 42 的 int 的 shared_ptr
shared_ptr<int> p3 = make_shared<int>(43);

// 指向一个值为 “9999999999” 的string
shared_ptr<string> p4 = make_shared<string>(10, '9');

// 指向一个值初始化的int，值为0
shared_ptr<int> p5 = make_shared<int>();
```

类似容器的 emplace 成员，make_shared 用其参数来构造给定类型的对象。

### shared_ptr 的拷贝和赋值

​	当进行拷贝或赋值操作时，每个shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象：

```c++
auto p = make_shared<int>(42);	// 此时 p指向对象只有一个引用者
auto q(p);	// 此时 p 和 q指向相同对象，此对象有两个引用者
```

​	我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个 shared_ptr，计数器都会递增。列如，当用一个 shared_ptr 初始化另一个 shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁（列如一个局部的shared_ptr 离开其作用域时），计数器就会递减。

​	当一个 shared_ptr 的计数器为0时，他就会自动释放自己所管理的对象：

```c++
auto r= make_shared<int>(42);	// r 指向的对象此时只有一个引用者
r = q;	// 将 q 赋值给r，r 指向另一地址
		// 递增q指向对象的引用计数
		// 递减r 原来指向对象的引用计数
		// r 原来指向的对象已经没有引用者，会自动释放
```

### shared_ptr 自动销毁所管理的对象

shared_ptr 的析构函数会递减它所指向对象的引用计数。如果引用计数变为 0，shared_ptr 的析构函数就会销毁对象，并释放它占用的内存。

由于在最后一个 shared_ptr 销毁前内存都不会释放，保证 shared_ptr 在无用之后不再保留就非常重要。shared_ptr 在无用之后仍然保留的一种情况是：将 shared_ptr 存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，应该确保用 erase 删除那些不再需要的 shared_ptr 元素。

```c++
class Student {
public:
    string Name;
    int Age;
    Student() = default;
    Student(string name, int age) :Name(name), Age(age) {}
    ~Student() {
        cout << "Student destroy" << endl;
    }
};

shared_ptr<Student> factory(string name, int age = 18)
{
    return make_shared<Student>(name, age);
}

void testF()
{
    vector<shared_ptr<Student>> svec = { make_shared<Student>("vincent", 16),
                                      make_shared<Student>("clock", 12),
                                      make_shared<Student>("ted", 16),
                                      make_shared<Student>("smith", 19) };

    sort(svec.begin(), svec.end(), [](const shared_ptr<Student>& s1, const shared_ptr<Student>& s2) {
        return s1->Age < s2->Age;
    });

	// 打印
    for (auto s : svec)
    {
        cout << " Name: " << s->Name << "  age: " << s->Age << endl;            
    }
}

int main(int argc, char* argv[])
{ 
    testF();
    return 0;
}
```

这里看了一下，最后的输出信息显示所有的智能指针指向的对象都清除了：

```c++
Name: clock  age: 12
Name: vincent  age: 16
Name: ted  age: 16
Name: smith  age: 19
Student destroy
Student destroy
Student destroy
Student destroy
```

也就是说，只要容器能够被销毁，那么智能指针也会随着销毁。没必要担心，可能文中说的是一个常驻的容器吧。

