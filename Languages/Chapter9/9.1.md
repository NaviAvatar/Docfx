# 9.1 顺序容器

<font color= 'red'>以下列表中的顺序容器都提供了快速顺序访问元素的能力。但是在一些方面的性能不同：</font>

* 向容器添加或从容器中删除元素的代价。
* 非顺序访问容器中元素的代价。

| 容器名       |                                                              |
| ------------ | ------------------------------------------------------------ |
| vector       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| deque        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |
| list         | 双向链表。支持双向顺序访问。在 list 中任何位置进行插入/删除操作速度很快。 |
| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| array        | 固定大小数组。支持快速随机访问。不能添加或删除元素。         |
| string       | 与 vector 相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |

string 和 vector 将元素保存在连续的内存空间中，可以由元素的下标计算地址，速度很快。但是在容器的**中间位置**添加或删除元素就会很耗时：因为在一次 插入/删除元素操作后，需要移动插入/删除元素位置后面的所有元素，来保持连续存储。而且添加一个元素有时可能需要分配额外的存储空间。每个元素都必须移动到新的存储空间中。

list 和 forward_list 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。但是容器不支持元素的随机访问，也就是说不能通过下标去访问，要访问一个元素，只能从头到尾一个一个去遍历。额外内存开销也相对较大。

deque 支持快速的随机访问。在中间位置插入/删除元素代价高。在两端插入/删除元素很快，性能与 list 相当。

forward_list 和 array 是新C++标准增加的。与内置数组相比，array 是一种更安全、更容易使用的数组类型。

### 选用容器准则参考

* 一般都是用 vector。
* 如果程序有很多小的元素，而且空间的额外开销很重要，则不要使用 list 或 forward_list。
* 如果程序要求随机访问元素，应使用 vector 或 deque。
* 如果程序要求在容器的中间插入或删除元素，应该使用 list 或 forward_list。
* 如果程序需要在头尾位置插入或删除原，但不会在中间位置进行插入或删除元素，使用deque。
* 如果程序需要在输入时才需要在容器中间插入元素，随后随机 访问元素。
  * 先使用 vector，还可以进行排序。
  * 此外，可以考虑先用 list，然后再把数据拷贝到 vector。

# 9.2 容器库

下面的操作是所有容器共有的操作：

| 操作名                 |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| iterator               | 此容器类型的迭代器类型                                       |
| const_iterator         | 可以读取元素，但不能修改元素的迭代器类型                     |
| size_type              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小       |
| difference_type        | 带符号整数类型，足够保存两个迭代器之间的距离                 |
| value_type             | 元素类型                                                     |
| reference              | 元素的左值类型；与value_type& 含义相同                       |
| const_reference        | 元素的const左值类型（即，const value_type&)                  |
|                        |                                                              |
| C c;                   | 默认构造函数，构造空容器                                     |
| C c1(c2);              | 构造 c2 的拷贝 c1                                            |
| C c(b, e);             | 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c (array不支持) |
| C c{a, b, c...};       | 列表初始化 c                                                 |
|                        |                                                              |
| c1 = c2                | 将 c1 中的元素替换为 c2 中元素                               |
| c1 = {a,  b, c... }    | 将 c1 中的元素替换为列表中元素（不适用array）                |
| a.swap(b)              | 交换 a 和 b 的元素                                           |
| swap(a, b)             | 与 a.swap(b) 等价                                            |
|                        |                                                              |
| c.size()               | c 元素的数目（不支持 forward_list）                          |
| c.max_size()           | c 中可保存的最大元素的数目                                   |
| c.empty()              | 若 c 中存储了元素，返回 false，否则返回 true                 |
|                        |                                                              |
| c.insert(args)         | 将 args的元素拷贝到 c                                        |
| c.emplace(inits)       | 使用 inits 构造 c 中的一个元素                               |
| c.erase(args)          | 删除 args 指定的元素                                         |
| c.clear()              | 删除 c 中所有元素，返回 void                                 |
|                        |                                                              |
| ==, !=                 | 所有容器都支持相等，不相等运算符                             |
| <，<=，>，>=           | 关系运算符                                                   |
|                        |                                                              |
| c.begin()，c.end()     | 返回指向 c 的首元素和尾元素之后位置的迭代器                  |
| c.cbegin()，c.cend()   | 返回 const_iterator                                          |
|                        |                                                              |
| reverse_iterator       | 按逆序寻址元素的迭代器                                       |
| const_reverse_iterator | 不能修改元素的逆序迭代器                                     |
| c.rbegin()，c.rend()   | 返回指向 c 的尾元素和首元素之前位置的迭代器                  |
| c.crbegin()，c.crend() | 返回 const_reverse_iterator                                  |

## 9.2.1 迭代器

之前的章节已经介绍过了通过迭代器去遍历和访问容器：通过迭代器进行++或--操作，可以移动迭代器指向的元素，读取元素值通过解引用运算符读取。forward_list 不支持 -- 操作。

### 迭代器范围

由两个迭代器组成，分别指向同一个容器中的元素和尾元素之后的位置。数学描述：

[begin，end)

称为**左闭合区间**。

## 9.2.2 容器类型成员

### 反向迭代器

方向迭代器是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作也都发生了颠倒。对一个反向迭代器执行++操作，会得到上一个元素。

### 类型别名

在不了解容器中的元素类型的情况下，如果需要元素类型，可以使用容器中的 value_type。如果需要元素类型的一个引用，可以使用 reference 或 const_reference。这些元素相关的类型别名在泛型编程中非常有用。

```c++
list<string>::iterator iter;
vector<int>::difference_type count;
```

## 9.2.3 begin 和 end 成员

begin 和 end 操作，生成指向容器中第一个元素和尾元素之后位置的迭代器。

带r的版本返回反向迭代器；

以c开头的版本返回 const 迭代器。

## 9.2.4 容器定义和初始化

除了 array 外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。

```c++
C seq(n);	// seq 包含 n 个元素，这些元素进行了值初始化
C seq(n, t)	// seq 包含 n 个初始化为值 t 的元素
```

### 将一个容器拷贝给另一个容器

* 将容器直接拷贝给另一个容器

  要求两个容器的类型及元素的类型必须匹配。

  ```c++
  list<string> authors = {"Mike", "Vincent", "cristal"};
  list<string> authorlist(authors);	// 正确
  list<char*> al(authors);	// 错误
  vector<string> vec(authors);	// 错误
  ```

* 由一对迭代器指定范围

  要求元素类型一致或者能转换。

  ```c++
  list<string> authors = {"Mike", "Vincent", "cristal"};
  vector<string> authorlist(begin(authors), end(authors));	// 正确
  list<char*> al(begin(authors), end(authors));	// 正确
  
  // it 是 authors 有效迭代器
  deque<string> de(begin(athuors), it);
  ```

### array

 array 的大小也是类型的一部分。定义一个 array 时，除了指定元素类型，还要指定容器大小：

```c++
array<int, 42>	// 类型为：保存 42 个 int 的数组
array<string, 10> // 类型为：保存 10 个 string 的数组
```

必须指定元素类型和大小。

```c++
array<int, 10>::size_type i;	// 即使要用size_type 也要把大小标出
array<int>::size_type j;		// 错误
```

一个默认构造的 array 是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，和内置数组中的元素那样。

如果对 array 进行列表初始化，初始值的数目必须等于或小于 array 的大小。

如果初始值列表的数目小于 array 的大小，则它们被用来初始化 array 靠前的元素，剩下的元素都会进行值初始化。因此，如果 array 元素是类类型，最好这个类型有一个默认构造函数。

```c++
array<int, 10> ia1;	// 10 个默认初始化的 int
array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> ia3 ={42};	// ia3[0]=42，其余为0
```

与内置数组的区别：

```c++
int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int cpy[10] = digs;	// 错误

array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> copy = digits;	// 正确。 
```

## 9.2.5 赋值和 swap

与内置数组不同，array 类型允许赋值。

```c++
array<int, 10> a1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> a2 = {0};	// 所有元素值均为0
a1 = a2;		// 正确
a2 = {0};	// 错误
```

array 类型不止 assign， 也不允许用花括号包围的值列表进行赋值。

| 容器赋值运算      |                                                              |
| ----------------- | ------------------------------------------------------------ |
| c1 = c2           | 将 c1 中的元素替换为 c2 中元素的拷贝。c1 和 c2 必须具有相同的类型。 |
| c={a, b, c...};   | 将 c1 中元素替换为初始化列表中元素的拷贝(array不适用)        |
| swap(c1, c2);     | 交换 c1 和 c2 中的元素。c1 和 c2 必须具有相同的类型。swap 通常比从 c2 向 c1 拷贝元素快得多。 |
| c1.swap(c2);      | 等同 swap(c1, c2);                                           |
| seq.assign(b, e)  | 将 seq 中的元素替换为迭代器 b 和 e 所表示的范围中的元素。迭代器 b 和 e 不能指向 seq 中的元素。 |
| seq.assign(il);   | 将 seq 中的元素替换为初始化列表il中的元素。                  |
| seq.assign(n, t); | 将 seq 中的元素替换为 n 个值为 t 的元素。                    |

### 使用 assign（仅顺序容器）

赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为 assign 的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign 操作用参数所指定的元素的拷贝替换左边容器中的所有元素。

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误，容器类型不匹配
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

**为什么调用assign时不能用容器自身的迭代器？**

自身的旧元素被替换。

```c++
// 等价于 slist1.clear();
//       slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);	
slist1.assign(10, "Hiya!");	// 10 个元素，每个都是 “Hiya!”
```

### 使用 swap

```c++
vector<string> vec1(10);
vector<string> vec2(24);
swap(vec1, vec2);
```

swap 交换两个类型相同的容器。

交换后，vec1 将有 24个元素，vec2 将有 10个元素。除了 array 外，交换两个容器的内容很快，元素本身并未交换，只是交换了两个容器的内部数据结构。

除 array 外，swap 不会对任何元素进行拷贝、删除或插入操作，所以可以很快就实现交换。

除 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效。它们仍指向 swap 操作之前所指向的那些元素。但是，在 swap 之后，这些元素已经属于不同的容器了。列如，iter 在 swap 之前指向 vec1[3] 的 string，在 swap 之后它指向 vec2[3]的元素。与其他容器不同，对一个 string 调用 swap 会导致迭代器、引用和指针失效。

用 swap 交换 array，会真正地交换它们的元素，所以耗费时间比其他容器贵。交换后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个 array 中对应元素的值进行了交换。

## 9.2.6 容器大小操作

每个容器类型都有三个与大小相关的操作：

| 成员       |                                                    |
| ---------- | -------------------------------------------------- |
| size()     | 返回容器中元素的数目                               |
| empty()    | size 为 0 返回 true；否则返回 false。              |
| max_size() | 返回一个大于或等于该类型所能容纳的最大元素数的值。 |

```c++
vector<int> vect;
cout << vect.max_size() << endl;
vector<double> vectd;
cout << vectd.max_size() << endl;

// 输出 ：
// 1073741823
// 536870911
```

forward_list 不支持 size。

## 9.2.7 关系运算符

每个容器都支持相等和不等运算符（== 和 !=）。

除了无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）。

关系运算符必须保证两边的容器类型相同，且容器中的元素类型相同。

这些容器的关系运算符工作方式与 string 的关系运算符类似。

### 关系运算符实现的背后

容器相等运算符实际上是使用元素的 == 运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持上述运算符，那么就不可能实现容器的比较。

