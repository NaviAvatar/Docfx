# 4.2 串的模式匹配

## 4.2.1 简单的模式匹配算法

​	子串的定位操作通常称为串的模式匹配，它求的是子串在主串中的首次出现的位置。本章节的字符串起始位置从 0 开始算起。

```c++
/// <summary>
/// 返回-1，表示匹配失败。返回大于等于0，则表示匹配成功，返回值是子串在主串中的位置
/// </summary>
/// <param name="source">主串</param>
/// <param name="pattern">模式串</param>
int Index(SString source, SString pattern)
{
    int sIndex = 0;	// 主串下标索引
    int pIndex = 0; // 子串下标索引
    while(i < source.length && j < pattern.length)
    {
        if(source.ch[i] == pattern.ch[j])
        {
            ++sIndex;
            ++pIndex;
        }
        else
        {
            sIndex = sIndex - pIndex + 1;	// sIndex 回退到上一次开始比较的下一个字符
            pIndex = 0;				// pIndex 回退到子串第一个字符
        }
    }
    
    if(pIndex == pattern.length) return sIndex - pIndex;
    else	return -1;
}

// 在debug编译模式下，没有弹出警告窗口，说明测试通过了
void IndexTestCast()
{
    SString s;
    SString pattern;
    strcpy_s(pattern.ch, "is a");
    s.length = 16;
    strcpy_s(s.ch, "this is a string");
    pattern.length = 4;
    int index = Index(s, pattern);

    assert(index == 5);
}
```

该模式的最坏时间复杂度为O(nm)，其中 n 为主串的长度，m 为模式串的长度。

## 4.2.2 KMP算法

​	可以说 4.2.1节的内容是一种暴力匹配算法。暴力匹配的基本思想是滑动窗口（计算机网络知识），即每次循环匹配不成功，就在上一次匹配的基础上，向右移动一位继续重新匹配。

​	KMP 算法可以从模式自身已经匹配相等的前缀序列中有某个后缀正好是模式的前缀，则直接将模式向后滑动到与这些相等字符对齐的位置进行匹配，而不是只移动一位。

比如主串是 "abaabaabcabaabc"，模式串是 “abaabc”。

如果是**暴力匹配算法**，匹配执行过程是这样的：

第一趟：

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
| a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |      |      |      |

第二趟：移动1位

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
|      | a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |      |      |

第三趟：移动1位

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
|      |      | a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |      |

第四趟：移动1位

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
|      |      |      | a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |

在第四趟的时候匹配成功！

**KMP 算法**匹配的执行过程：

第一趟：

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
| a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |      |      |      |

第二趟：移动3位

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
|      |      |      | a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |

匹配成功！

可以看出，在这个例子中，kmp 只跑了两趟就匹配成功了。那怎么确定每次应该移动多少位呢？

### 模式串解析

| 名词       | 解释                                                         |
| ---------- | ------------------------------------------------------------ |
| 前缀       | 不看最后一个字符，字符串的所有以头部字符开始的子串。         |
| 后缀       | 不看第一个字符，字符串的所有以尾部字符结束的子串。           |
| 部分匹配值 | 字符串的前缀集合和后缀集合中的相等子串解中，取最长相等子串的长度。 |

比如上面的 abaabc 模式串中，以第一个字符开头的子串一共有6个：

| 第一个字符开头的子串 | 前缀                      | 后缀                      | 匹配值 |
| -------------------- | ------------------------- | ------------------------- | ------ |
| "a"                  | ∅                         | ∅                         | 0      |
| “ab”                 | {a}                       | {b}                       | 0      |
| "aba"                | {a, ab}                   | {a, ba}                   | 1      |
| "abaa"               | {a, ab, aba}              | {a, aa, baa}              | 1      |
| "abaab"              | {a, ab, aba, abaa}        | {b, ab, aab, baab}        | 2      |
| "abaabc"             | {a, ab, aba, abaa, abaab} | {c, bc, abc, aabc, baabc} | 0      |

所以模式串的**部分匹配值表**为：

| index   | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Pattern |      | a    | b    | a    | a    | b    | c    |
| Next    |      | 0    | 0    | 1    | 1    | 2    | 0    |

得出上面的表格后，即得到每次移动多少位：

<font color='red'>移动位数 = 已匹配字符数 - 最后一个匹配字符对应的部分匹配值</font>

在整个匹配过程中，主串没有回退，而且模式串也不一定每一次都回到首个字符开始匹配，如果有部分匹配值 t 大于 0 的情况，直接从子串的第 t+1个位置开始比较，因为滑动后，模式串前面 t 位已经匹配了。所以 KMP 算法在时间算法复杂度上为 O(n+m)。

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a    | a    | b    | c    | a    | b    | a    | a    | b    | c    |
| a    | b    | a    | a    | b    | c    |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      | fail |      |      |      |      |      |      |      |      |      |

从这个例子来看，在位置6出现匹配失败。那么下一轮比较到来时，模式串的指针应该为 pIndex = 2，指向从左数起的第一个 b 字符的下一个字符。而对主串来说，从最后一个匹配成功的下一个字符开始比较，即 sIndex = 5。（pIndex和sIndex均是从1开始的下标）

| 1    | 2    | 3    | 4    | 5    | 6        | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | a    | a    | b    | a        | a    | b    | c    | a    | b    | a    | a    | b    | c    |
|      |      |      |      |      | sIndex=6 |      |      |      |      |      |      |      |      |      |
|      |      |      | a    | b    | a        | a    | b    | c    |      |      |      |      |      |      |
|      |      |      |      |      | pIndex=3 |      |      |      |      |      |      |      |      |      |

移动位数的代码：

```c++
move = pIndex - 1 - Next[pIndex - 1]
```

观察部分匹配值表，每当匹配失败，就去找匹配失败元素的前一个元素的部分匹配值。可以将数组往右移动一位。右移后，每个元素对应的 Next[pIndex] 即是自己的匹配值，而对于第一个元素，用-1，是因为第一个元素匹配失败，需要右移一位。没有右移前，最后一位元素的部分匹配值是给下一位使用的，但是没有下一位，所以可以丢掉。

| index   | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Pattern |      | a    | b    | a    | a    | b    | c    |
| Next    |      | -1   | 0    | 0    | 1    | 1    | 2    |

移动位数代码就变成了：

```
move = pIndex - 1 - Next[pIndex];
```

相应的子串的指针回退代码为：

```c++
pIndex = Next[pIndex] + 1;
```

可以将数组整体加1，move 和 pIndex 的求值变成：

```c++
pIndex = Next[pIndex];
move = pIndex - Next[pIndex];
```

此时数组：

| index   | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Pattern |      | a    | b    | a    | a    | b    | c    |
| Next    |      | 0    | 1    | 1    | 2    | 2    | 3    |

### 求数组NEXT

用上述的方法手工去算next数组，确实很方便，但是用代码实现比较难。下面看一个例子求next数组：

| pIndex  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| pattern | a    | b    | a    | a    | b    | c    | a    | b    | a    |
| next    | 0    | 1    | 1    | 2    | 2    | 3    |      |      |      |

已求得6个字符的next值，求next[7]值：

①因为next[6] = 3，pattern[6] = "c" ≠ pattern[3]，需比较pattern[6]和pattern[1]。

②pattern[6]≠pattern[1]，而next[1] = 0，所以next[7] = 1。

求next[8]：

①因为pattern[7]=pattern[1]，那么next[8] = next[7] + 1= 2。

求next[9]:

①因为pattern[8] = pattern[2]，那么next[9] = next[8] + 1 = 3。

```c++
void get_next(SString T, int next[])
{
    int i = 1, j =0;
    next[1] = 0;
    while(i < T.length)
    {
        if(j == 0 || T.ch[i] == T.ch[j]){
            i++;j++;
            next[i] = j;	// 若 pattern[i]=pattern[j]，则next[j+1] = next[j] + 1
        }
        else
        {
        	j = next[j];	// 令j=next[j],继续循环    
        }
    }
}
```

### KMP 算法实现

```c++
int Index_KMP(SString source, SString pattern, int next[])
{
    int sIndex = 1, pIndex = 1;
    while(sIndex <= source.length && pIndex <= pattern.length)
    {
        if(pIndex == 0 || source.ch[sIndex] == pattern.ch[pIndex])
        {
            ++sIndex;
            ++pIndex;
        }
        else{
            pIndex = next[pIndex];	// 和暴力匹配不同，模式串并不是每次都是从第一个字符开始对比的
        }
    }
    
    if(pIndex > pattern.length)
        return sIndex - pattern.length;
    else 
        return 0; // 失败
}
```

