{
  "Algorithm/Chapter1/1.1.html": {
    "href": "Algorithm/Chapter1/1.1.html",
    "title": "1.1 简介",
    "keywords": "1.1 简介 1.1.1 基本概念 1. 基本概念 ​ 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。 2. 数据元素 ​ 数据元素是数据的基本单位。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。如下，一条学生的信息就是一个数据元素，一个数据元素是有一个个数据项构成。 3. 数据对象 ​ 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是{±1，±2，...} 4. 数据类型 ​ 数据类型是一个值得集合和定义在此集合上的一组操作的总称。 原子类型。其值不可再分的数据类型。 结构类型。其值可以再分解为若干成分的数据类型。 抽象数据类型。抽象数据组织及其与之相关的操作。 5. 数据结构 ​ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。 ​ 数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。 1.1.2 三要素 数据的逻辑结构 ​ 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。 数据的存储结构 ​ 存储结构是指数据结构在计算机中的表示，即物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。 顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。优点是可以随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。典型代表：数组。 链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。典型代表：链表。 索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是(关键字,地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。此外，增加和删除数据时也要修改索引表，故会消耗大。 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。其有点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销。 数据的运算 ​ 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。"
  },
  "Algorithm/Chapter1/1.2.html": {
    "href": "Algorithm/Chapter1/1.2.html",
    "title": "1.2 算法和算法评价",
    "keywords": "1.2 算法和算法评价 1.2.2 算法效率的度量 描述算法主要通过两个度量：时间复杂度和空间复杂度。 时间复杂度 一个语句在算法中被重复执行的次数 ，也称一个语句的频度。算法的时间复杂度不仅依赖于问题的规模，也和待输入的数据相关。比如在一个仅仅10个数字集合中找出最大的数和在一个含10亿个数字集合中找出最大的数，这是规模对算法时间复杂度的影响；再比如，拥有相同个数的两个集合，它们是数组，但是数组A是个排好序的数组，数组B是个无序的数组，找出最大的数，算法的时间复杂度也不一样。 名称 解释 最坏时间复杂度 指在最坏的情况下，算法的时间复杂度。 平均时间复杂度 所有可能输入实例在等概率出现的情况下，算法的期望运行时间。 最好时间复杂度 指在最好的情况下，算法的时间复杂度。 一般总是考虑最坏时间复杂度，以确保算法的运行时间不会过长。 空间复杂度 ​ 该算法运行过程中所耗费的存储空间。它是问题规模n的函数。一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储空间。若输入数据所占用空间取决于问题本身，和算法无关，则只需分析输入和程序之外的额外空间。 ​ 算法原地工作是指算法所需的辅助空间为常量。"
  },
  "Algorithm/Chapter1/1.3.html": {
    "href": "Algorithm/Chapter1/1.3.html",
    "title": "练习",
    "keywords": "练习 1.以下算法时间复杂度为： void fun(const int n) { int i = 1; while (i <= n) { i = i*2; } } 这里主要是算出 “i = i*2;” 语句的执行次数和n规模之间的关系。 通过计算等比数列求和公式知： 其中x是运行次数。x即为所求的算法复杂度。所以算法复杂度为： 2.求以下算法时间复杂度： x = 2; while(x < n/2) { x=2*x; } 循环语句 x=2*x; 执行次数i和n规模的关系为: 所以算法复杂度为： 3.求整数n的阶乘的算法如下，计算时间复杂度： int fact(int n) { if(n <= 1){ return 1; } return n*fact(n-1); } 这是个递归方法计算n的阶乘。显然一共调用fact函数n次，故其算法时间复杂度为O(n); 4.下列程序段的时间复杂度是？ count = 0; for(k = 1; k <= n;k *= 2) for(j = 1; j <= n; j++) count++; 第一层for循环执行了 次，第二层for循环每次执行n次，故算法时间复杂度为："
  },
  "Algorithm/Chapter2/2.1.html": {
    "href": "Algorithm/Chapter2/2.1.html",
    "title": "2.1 线性表的定义和基本操作",
    "keywords": "2.1 线性表的定义和基本操作 2.1.1 定义 ​ 线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当 n=0 时线性表是个空表。可以理解为一串元素构成的数据结构，因为看起来像一条线一样，所以叫线性表。除表头元素外，每个元素有且仅有一个直接前驱。除表尾元素外，每个元素有且仅有一个直接后继。 线性表的一些特性： 表中元素个数有限。 表中元素具有逻辑上的顺序性，表中元素有其先后次序。 表中元素都是数据元素，每个元素都是单个元素。 表中元素的数据类型都相同，每个元素占用相同大小空间。 2.1.2 线性表的基本操作 方法名 解释 InitList(&L) 初始化列表，构造一个空线性表。 Length(L) 返回表当前拥有的元素个数。 LocateElem(L, e) 按值查找，在表L中查找给定关键字e的元素。 GetElem(L, i) 按位查找，返回L中第i个位置的元素的值，如果不存在，返回失败。 ListInsert(&L, i, e) 插入操作，在表L中第i个位置插入元素e。 ListDelete(&L,i,&e) 删除操作，删除表L中第i个位置的元素，并通过参数e返回已经删除的元素的值。 PrintList(L) 输出操作，按前后顺序输出线性表L的所有元素值。 Empty(L) 判空操作，如果L为空表，返回true，否则返回false。 DestroyList(&L) 销毁操作，销毁线性表，并释放线性表L所占用内存空间。 这里只是给出基本的接口名，具体怎么实现要还要看条件和需求。"
  },
  "Algorithm/Chapter2/2.2.html": {
    "href": "Algorithm/Chapter2/2.2.html",
    "title": "2.2 线性表的顺序表示",
    "keywords": "2.2 线性表的顺序表示 2.2.1 顺序表的定义 线性表的顺序存储叫顺序表。它是一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。特点是表中元素的逻辑顺序与其物理顺序相同。 ​ 每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表中的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。在c++语言中表现为数组。 用c++描述一个顺序表： #include <iostream> // #include \"Sales_item.h\" using namespace std; template<class t> class SqList{ private: t* arr; // 动态分配，当插入溢出时，方便扩容 unsigned int Maxsize; // 最大个数 unsigned int length; // 当前个数 public: SqList(unsigned int size = 1024); ~SqList(); // ... 这里待加入增删改查 }; template<class t> SqList<t>::SqList(unsigned int size) { Maxsize = size; // 顺序表的最小容纳个数为10个 if (Maxsize < 10) { Maxsize = 10; } arr = new t[size]; length = 0; } template<class t> SqList<t>::~SqList() { delete arr; arr = nullptr; } 此处实现采用动态分配数组，是为了应对当插入新的数据时若数组已满，则可以通过动态的扩容，使得插入成功。 顺序表的特点主要是可以随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素，这是因为电脑的硬件设计支持这么做。顺序表的存储密度高，每个结点只存储数据元素。顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素，消耗大。 2.2.2 顺序表基本操作的实现 插入操作 ​ 在顺序表L的第i个位置插入新元素e。如i不合法，则返回false，插入失败。否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，表长+1，返回true。 /// <summary> /// 插入数据 /// </summary> /// <typeparam name=\"t\">类型</typeparam> /// <param name=\"index\">插入位置</param> /// <param name=\"e\">新插入的元素</param> /// <returns>插入成功结果</returns> template<class t> bool SqList<t>::ListInsert(unsigned int index, t e) { if (index < 1 || index > length + 1) // 插入位置超出链表所在位置 { return false; } if (length >= Maxsize) // 当前数组满了，扩容 { Maxsize = Maxsize * 2; // 扩容为原来的两倍 t* temp = arr; arr = new t[Maxsize]; for (unsigned int i = 0; i < length; i++) // 将原数组数据拷贝到新的数组中 { arr[i] = temp[i]; } delete temp; // 删除原数组空间 temp = nullptr; } for (unsigned int j = length; j >= index; j--) { arr[j] = arr[j - 1]; // 数据后移 } arr[index - 1] = e; // 插入新元素 length++; // 表长加一 return true; } 删除操作 删除顺序表L中第i个位置的元素，用引用变量e返回。如i不合法，则返回false，删除失败。否则，将第i+1个元素及其后的所有元素依次往前移动一个位置，表长-1，返回true。 template<class t> bool SqList<t>::ListDelete(unsigned int index, t& e) { if (index<1 && index >length) // 判断index有效性 { return false; } e = arr[index - 1]; // 读取第index个数据元素 for (unsigned int i = index; i < length; i++) // 第index后的数据元素往前移动 { arr[i - 1] = arr[i]; } length--; // 表长减一 return true; } 按值查找 /// <summary> /// 按值查找值等于e的元素的位置 /// </summary> /// <param name=\"e\">待查找值</param> /// <returns>值为e的元素在顺序表中的位置；返回0表示返回失败</returns> template<class t> unsigned int SqList<t>::LocateElem(t e) { for (unsigned int i = 0; i < length; i++) { if (arr[i] == e) { return i + 1; } } return 0; // 返回0表示查找失败 } 按位查找 /// <summary> /// 按位取值 /// </summary> /// <param name=\"index\">第几个元素，输入0和输入超过表长的数将会抛出异常。</param> /// <returns>返回表中第index位数据元素的副本</returns> template<class t> t SqList<t>::GetElem(unsigned int index) { if (index < 1 || index > length + 1) { std::cout << \"out of range in SqList\" << std::endl; throw exception ex; } t e = arr[index - 1]; return e; } 获取表长 template<class t> unsigned int SqList<t>::GetLength() { return length; } 判空 template<class t> bool SqList<t>::Empty() { return length == 0; } 2.2.3 练习题目 题目一 ：倒置数组 设将n(n>1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(0，1，…，p，p+1，n-1)变换为(p，p+1，…，n-1，0，1，…，p-1)。给出算法的基本设计思想。说明算法时间复杂度和空间复杂度。 设计思路： 1）创建一个大小为p的一维数组temp，将从下标从0到p-1的数据元素保存到赋值数组temp中。 2）将R中下标为p到n-1的数据元素左移p个位置。 3）将辅助数组temp中的数据依次拷贝到R中下标为n-p到n-1位置中。 代码以int数组为示例。 /// <summary> /// 在位置pos处倒置 /// </summary> /// <param name=\"arr\">数组地址</param> /// <param name=\"len\">数组长度</param> /// <param name=\"pos\">倒置的位置p</param> void Reverse(int arr[], int len, int pos) { if (pos <= 0 || pos >= len) // 保证 0<p<n return; int* temp = new int[pos]; // 辅助数组 // 将下标0到pos-1的数组元素备份 for (int i = 0; i < pos; i++) { temp[i] = arr[i]; } // 下标 pos 到数组尾部数据左移pos个单位 for (int j = 0; j < len - pos; j++) { arr[j] = arr[pos + j]; } // 将辅助数组的数据拷贝回去 for (int k = 0; k < pos; k++) { arr[len - pos + k] = temp[k]; } delete [] temp; // 释放辅助数组 temp = nullptr; } // 主函数调用 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; Reverse(arr, 10, 6); 时间复杂度为O(n)；空间复杂度为O(p)。 另外一种解法是： 1）先倒置R中下标0到p-1的元素，倒置后序列为：（p-1，…，1,0，p，…，n-1）。 2）倒置R中下标p到n-1的元素，倒置后序列为：（p-1，…，1,0，n-1，…，p）。 3）倒置R中下标0到n-1的元素，倒置后序列为：（p，…，n-1，0，1，…，p-1）。 /// <summary> /// 倒置数组 /// </summary> /// <param name=\"arr\">数组地址</param> /// <param name=\"from\">倒置起始下标</param> /// <param name=\"to\">倒置末尾下标</param> void Reverse2(int arr[], int from, int to) { int count = (to - from + 1) / 2; // 循环次数 for (int i = 0; i < count; i++) { int temp = arr[from + i]; arr[from + i] = arr[to - i]; arr[to - i] = temp; } } // 主函数调用 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; Reverse2(arr, 0, 6-1); Reverse2(arr, 6, 9); Reverse2(arr, 0, 9); 时间复杂度为O(n)；空间复杂度为O(1)。 题目二：中位数 一个长度为L（L≥1）的生序序列S，处在第⌈L/2⌉个位置的数称为S的中位数。列如，若序列S1=(11,13,15,17,19)，则S1中的中位数是15，两个序列的中位数是含它们所有元素的生序序列的中位数。列如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间算法两方面都尽可能高效的算法，找出A和B的中位数。要求：给出算法设计的基本思路。说明算法时间复杂度和空间复杂度。 设计思路： 分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下： ① 若a=b，则a或b即为所求中位数，程序结束。 ②若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等。 ③若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等。 在保留的两个升序序列中，重复过程①②③，直到两个序列中均只有一个元素为止，较小者即为所求的中位数。 int M_Search(int a[], int b[], int len) { int aBegin = 0, aEnd = len - 1, bBegin = 0, bEnd = len - 1; int aMin = (aBegin + aEnd) / 2, bMin = (bBegin + bEnd) / 2; // aMin是a数组的中位数下标，bMin是b数组的中位数下标 while ((aBegin != aEnd || bBegin != bEnd)) { if (a[aMin] < b[bMin]) { if ((aBegin + aEnd) % 2 == 0) { // 元素个数为寄数个 aBegin = aMin; // 舍弃序列A中间点以前部分，保留中间点 bEnd = bMin; // 舍弃序列B中间点后面部分，保留中间点 } else { // 元素个数为偶数个 aBegin = aMin + 1; // 舍弃序列A中间点以前部分及中间点 bEnd = bMin; // 舍弃序列B中间点后面部分且保留中间点 } } else if(a[aMin] > b[bMin]) { if ((bBegin + bEnd) % 2 == 0) // 元素个数为奇数个 { aEnd = aMin; // 舍弃序列A中间点后面部分，保留中间点 bBegin = bMin; // 舍弃序列B中间点以前部分，保留中间点 } else{ aEnd = aMin; // 舍弃序列A中间点后面部分，保留中间点 bBegin = bMin + 1; // 舍弃序列B中间点以前部分，保留中间点 } } else // 中位数相等 { return a[aMin]; } aMin = (aBegin + aEnd) / 2, bMin = (bBegin + bEnd) / 2; // 计算新序列的中位数下标 } return a[aMin] < b[bMin] ? a[aMin] : b[bMin]; // 当保留的序列只剩一个时，返回最小的那个数。 }"
  },
  "Algorithm/Chapter2/2.3.html": {
    "href": "Algorithm/Chapter2/2.3.html",
    "title": "2.3 线性表的链式表示",
    "keywords": "2.3 线性表的链式表示 ​ 顺序表可以随时存取表中的任一一个元素，它的存储位置可以用一个简单直观的公式表示，但是出入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元。不要求逻辑上相邻的元素物理上位置也相邻。因此插入和删除操作不需要移动元素，只需要修改指针。但是查询只能沿着链一个一个查找，查询性能就降低了。 2.3.1 单链表的定义 线性表的链式存储又称单链表。 单链表结点代码结构 template<class t> class LNode { public: t data; // 数据域 LNode<t> *next; // 指针域 public: LNode(t e):data(e), next(nullptr){} }; ​ 单链表可以解决顺序表需要大量连续存储单元的缺点（数组并不需要为其下标开辟存储空间），但是单链表附加指针域，也存在浪费存储空间的缺点。单链表的元素离散分布在存储空间中，是非随机存取的存储结构。不能直接定位某个特定的结点，只能从表头沿着链域一个一个的遍历。 ​ 带头结点：通常用头指针来标识一个链表，如单链表L，头指针为NULL时表示一个空表。为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点，结点的data不存数据。 链表结构 template<class t> class LinkList { private: LNode<t>* phead; // 头指针 LNode<t>* ptail; // 尾指针 public: LinkList(); // 初始化 void Insert(t e); bool Insert(int i, t e); LNode<t>* GetElem(int i); // 按序号查找结点 LNode<t>* LocateElem(t e); // 按值查找结点 bool Delete(int i); // 按序号删除结点 size_t GetLength(); // 求表长 }; template<class t> inline LinkList<t>::LinkList() { // 创建头结点，结点不存内容。 phead = new LNode<t>(); ptail = phead; // 尾指针指向头结点 } 2.3.2 单链表上基本操作的实现 插入操作 /// <summary> /// 尾部插入新的结点 /// </summary> /// <param name=\"e\">数据</param> template<class t> void LinkList<t>::Insert(t e) { // ptail 永远不为空，因为有头结点 ptail = ptail->next; ptail = new LNode<t>(); ptail->data = e; ptail->next = nullptr; } 查找操作 按序号查找结点值 ​ 在单链表中从第一个结点出发，顺着指针 next 域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。 template<class t> inline LNode<t>* LinkList<t>::GetElem(int i) { if (i < 1) // i的值不能小于1 return nullptr; int j = 1; LNode<t>* temp = phead->next; // 获取将头指针的next // 沿着链找到对应位置的结点 while (temp && j < i) { temp = temp->next; j++; } return temp; } 按值查找表结点 ​ 从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该节点的指针；若整个单链表中没有这样的结点，则返回NULL。 template<class t> inline LNode<t>* LinkList<t>::LocateElem(t e) { LNode<t>* temp = phead->next; while (temp && temp != e) { temp = temp->next; } return temp; } 插入新结点 ​ 插入结点操作将值为x的新结点插入到链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第 i-1 个结点，再在其后插入新结点。 /// <summary> /// 按位置插入法。 /// </summary> /// <param name=\"i\">插入的位置</param> /// <param name=\"e\">插入的结点数据</param> /// <returns>true，插入成功；false，插入失败</returns> template<class t> inline bool LinkList<t>::Insert(int i, t e) { if (i < 1) return false; LNode<t>* p = GetElem(i - 1); if (p) return false; LNode<t>* temp = new LNode<t>(); temp->data = e; temp->next = p->next; // 原链表中第i个位置的元素，可能为空，由新元素的next指向 p->next = temp; if (temp->next == nullptr) // temp的next是空指针，则temp是个尾部结点 ptail = temp; } 删除操作 ​ 删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第 i-1 个结点，即被删结点的前驱结点，再将其删除。 template<class t> inline bool LinkList<t>::Delete(int i) { LNode<t>* p = GetElem(i - 1); // 找到第i-1个位置结点 if (p || p->next) // 第i-1个位置的结点为空或者第i个位置结点为空，删除失败 { return false; } LNode<t>* pnext = p->next; p->next = pnext->next; // 将第i-1个结点的next域指向第i个结点的next域 delete pnext; if (p->next == nullptr) // 删除的i结点时ptail，则需要修改ptail的指向 ptail = p; return true; } 求表长 ​ 求表长，不算头结点。 template<class t> inline size_t LinkList<t>::GetLength() { int len = 0; auto current = phead; // 获取头指针 while ( current && ptail != current) { len++; current = current->next; } return len; } 2.3.3 双链表 ​ 单链表结点中，只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头再遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 ​ 双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点。 双链表结点代码结构 template<class t> class LNode { private : t data; // 数据域 LNode<t>* next; // 后继结点的指针域 LNode<t>* pre; // 前继结点的指针域 }; ​ 双链表在单链表道德结点中增加了一个指向其前驱的 prior 指针，因此双链表中的按值查找和按位查找的操作与单链表相同。不同的是在插入和删除操作上，需要额外对前继结点指针域进行操作。 双链表的插入操作 尾部插入 // 在链表尾部插入新结点 template <class t> void LinkList<t>::Insert(t e) { LNode<t>* temp = new LNode<t>(e); temp->pre = ptail; // 将新结点的前继指针指向原链表中的tail指向的结点 ptail->next = temp; // 将链表原结点的尾结点的next指针指向新插入的结点 ptail = temp; // 尾指针移到最后一个结点 } 按序号插入 /// <summary> /// 按位置插入法。 /// </summary> /// <param name=\"i\">插入的位置</param> /// <param name=\"e\">插入的结点数据</param> /// <returns>true，插入成功；false，插入失败</returns> bool LinkList<t>::Insert(int i, t e) { if(i < 1) // 序号不能小于1 return false; // 找到第 i-1个位置的结点 LNode<t>* pi = GetElem(i - 1); if(pi) // 如果第i-1个结点不存在，插入失败， return false; LNode<t>* t = pi->next; // 插入前第i个结点 LNode<t>* temp = new LNode<t>(e); // 申请新结点 pi->next = temp; // 将新结点插入链表 temp->pre = pi; if(ptail == pi) // 如果第i-1个结点时链表尾结点，则移动尾结点 { ptail = temp; } else // 第i-1个结点不是尾结点 { t->pre = temp; temp->next = t; } return true; } 删除结点 // 按位删除结点 template <class t> void Delete(int i) { LNode<t>* pi = GetElem(i - 1); // 获取第i-1个结点 if(!pi || !(pi-next)) // 第i-1个结点不存在或者第i个结点不存在，程序结束 return; if(pi->next) LNode<t>* t = pi->next->next; // t 指向第 i+1个结点 delete pi->next; // 释放第i个结点的空间 if(t == nullptr) // 删除后第i+1个结点不存在，那第i-1个结点就成为了尾结点，需要将尾指针移动到对应的位置 { ptail = pi; } else { pi->next = t; t->pre = pi; } }"
  },
  "Algorithm/Chapter4/4.1.html": {
    "href": "Algorithm/Chapter4/4.1.html",
    "title": "4.1 串的定义和实现",
    "keywords": "4.1 串的定义和实现 ​ 字符串简称串，计算机上非数值处理的对象基本都是字符串数据。比如百度搜索，google搜索；一些商品网站，如淘宝，京东，都会有搜索框提供给用户进行商品的搜索，好不夸张的说，一些网站门户和 APP，均提供了搜索功能，甚至连一些黄色网站也提供了搜索功能。当然也有一些不走主流趋势的公司门户网站没有站内搜索，比如猿辅导。 4.1.1 串的定义 ​ 串是由零个或多个字符组成的有限序列。记为： S='a1a2...an'(n>=0) 串中任意多个连续的字符组成的子序列称为该串的 子串 ，包含字串的串称为 主串 。某个字符在串中的序号称为该字符在串中的位置。字串在主串中的位置以子串的第一个字符在主串中的位置来表示。当两串的长度相等且对应每个位置的字符相等时，称这两个串相等。 A=\"this is a string\"; B=\"is\"; C=\"string\"; B 在 A 中的位置为 6；C 在 A 中的位置为 11。 4.1.2 串的存储结构 定长存储 #define MAXLEN 255 typedef struct{ char ch[MAXLEN]; int length; // 串的实际长度 } SString; 用一组地址连续的存储单元存储串值的字符序列。串有一个最大的长度。 堆存储 typedef struct{ char *ch; // 按串长分配存储区，ch是存储区的首地址 int length; // 串的实际长度 }SString; 这种存储结构比起定长存储又一点好处，就是不限制长度，当ch指向的数组不够长时，可以申请更长的数组。 块链存储 借用链表，将字符存到节点中，每个结点有指向下一节点的指针。 typedef struct{ char ch[5]; node* next; // 指向下一个块的指针 }node; typedef struct{ node* head; // 首地址 } 4.13 串的基本操作 操作名 释义 StrAssign(&T, chars) 赋值操作。把串 T 赋值给 chars。 StrCopy(&T, S) 复制操作。由串 S 复制得到串 T。 StrEmpty(S) 判空操作。S 串为空串，返回 true，否则返回 false。 StrCompare(S, T) 比较操作。若 S > T，返回值 1；若 S = T，返回 0；若 S < T，返回 0。 StrLength(S) 求串长。返回串 S 的元素个数。 SubString(&Sub, S, pos, len) 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。 Concat(&T, S1, S2) 串连接。用 T 返回由 S1 和 S2 联接而成的新串。 Index(S, T) 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。 ClearString(&S) 清空操作。将 S 串清空。 DestroyString(&S) 销毁串。将串 S 销毁。 上述的接口仅是王道书给出的，我们应该向开源或者语言通用的接口靠近，比如 C++里的 string 类型的 substr，第一个字符的下标是从 0开始算起的。"
  },
  "Algorithm/Chapter4/4.2.html": {
    "href": "Algorithm/Chapter4/4.2.html",
    "title": "4.2 串的模式匹配",
    "keywords": "4.2 串的模式匹配 4.2.1 简单的模式匹配算法 ​ 子串的定位操作通常称为串的模式匹配，它求的是子串在主串中的首次出现的位置。本章节的字符串起始位置从 0 开始算起。 /// <summary> /// 返回-1，表示匹配失败。返回大于等于0，则表示匹配成功，返回值是子串在主串中的位置 /// </summary> /// <param name=\"source\">主串</param> /// <param name=\"pattern\">模式串</param> int Index(SString source, SString pattern) { int sIndex = 0; // 主串下标索引 int pIndex = 0; // 子串下标索引 while(i < source.length && j < pattern.length) { if(source.ch[i] == pattern.ch[j]) { ++sIndex; ++pIndex; } else { sIndex = sIndex - pIndex + 1; // sIndex 回退到上一次开始比较的下一个字符 pIndex = 0; // pIndex 回退到子串第一个字符 } } if(pIndex == pattern.length) return sIndex - pIndex; else return -1; } // 在debug编译模式下，没有弹出警告窗口，说明测试通过了 void IndexTestCast() { SString s; SString pattern; strcpy_s(pattern.ch, \"is a\"); s.length = 16; strcpy_s(s.ch, \"this is a string\"); pattern.length = 4; int index = Index(s, pattern); assert(index == 5); } 该模式的最坏时间复杂度为O(nm)，其中 n 为主串的长度，m 为模式串的长度。 4.2.2 KMP算法 ​ 可以说 4.2.1节的内容是一种暴力匹配算法。暴力匹配的基本思想是滑动窗口（计算机网络知识），即每次循环匹配不成功，就在上一次匹配的基础上，向右移动一位继续重新匹配。 ​ KMP 算法可以从模式自身已经匹配相等的前缀序列中有某个后缀正好是模式的前缀，则直接将模式向后滑动到与这些相等字符对齐的位置进行匹配，而不是只移动一位。 比如主串是 \"abaabaabcabaabc\"，模式串是 “abaabc”。 如果是 暴力匹配算法 ，匹配执行过程是这样的： 第一趟： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第二趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第三趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第四趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 在第四趟的时候匹配成功！ KMP 算法 匹配的执行过程： 第一趟： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第二趟：移动3位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 匹配成功！ 可以看出，在这个例子中，kmp 只跑了两趟就匹配成功了。那怎么确定每次应该移动多少位呢？ 模式串解析 名词 解释 前缀 不看最后一个字符，字符串的所有以头部字符开始的子串。 后缀 不看第一个字符，字符串的所有以尾部字符结束的子串。 部分匹配值 字符串的前缀集合和后缀集合中的相等子串解中，取最长相等子串的长度。 比如上面的 abaabc 模式串中，以第一个字符开头的子串一共有6个： 第一个字符开头的子串 前缀 后缀 匹配值 \"a\" ∅ ∅ 0 “ab” {a} {b} 0 \"aba\" {a, ab} {a, ba} 1 \"abaa\" {a, ab, aba} {a, aa, baa} 1 \"abaab\" {a, ab, aba, abaa} {b, ab, aab, baab} 2 \"abaabc\" {a, ab, aba, abaa, abaab} {c, bc, abc, aabc, baabc} 0 所以模式串的 部分匹配值表 为： index 0 1 2 3 4 5 6 Pattern a b a a b c Next 0 0 1 1 2 0 得出上面的表格后，即得到每次移动多少位： 移动位数 = 已匹配字符数 - 最后一个匹配字符对应的部分匹配值 在整个匹配过程中，主串没有回退，而且模式串也不一定每一次都回到首个字符开始匹配，如果有部分匹配值 t 大于 0 的情况，直接从子串的第 t+1个位置开始比较，因为滑动后，模式串前面 t 位已经匹配了。所以 KMP 算法在时间算法复杂度上为 O(n+m)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c fail 从这个例子来看，在位置6出现匹配失败。那么下一轮比较到来时，模式串的指针应该为 pIndex = 2，指向从左数起的第一个 b 字符的下一个字符。而对主串来说，从最后一个匹配成功的下一个字符开始比较，即 sIndex = 5。（pIndex和sIndex均是从1开始的下标） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c sIndex=6 a b a a b c pIndex=3 移动位数的代码： move = pIndex - 1 - Next[pIndex - 1] 观察部分匹配值表，每当匹配失败，就去找匹配失败元素的前一个元素的部分匹配值。可以将数组往右移动一位。右移后，每个元素对应的 Next[pIndex] 即是自己的匹配值，而对于第一个元素，用-1，是因为第一个元素匹配失败，需要右移一位。没有右移前，最后一位元素的部分匹配值是给下一位使用的，但是没有下一位，所以可以丢掉。 index 0 1 2 3 4 5 6 Pattern a b a a b c Next -1 0 0 1 1 2 移动位数代码就变成了： move = pIndex - 1 - Next[pIndex]; 相应的子串的指针回退代码为： pIndex = Next[pIndex] + 1; 可以将数组整体加1，move 和 pIndex 的求值变成： pIndex = Next[pIndex]; move = pIndex - Next[pIndex]; 此时数组： index 0 1 2 3 4 5 6 Pattern a b a a b c Next 0 1 1 2 2 3 求数组NEXT 用上述的方法手工去算next数组，确实很方便，但是用代码实现比较难。下面看一个例子求next数组： pIndex 1 2 3 4 5 6 7 8 9 pattern a b a a b c a b a next 0 1 1 2 2 3 已求得6个字符的next值，求next[7]值： ①因为next[6] = 3，pattern[6] = \"c\" ≠ pattern[3]，需比较pattern[6]和pattern[1]。 ②pattern[6]≠pattern[1]，而next[1] = 0，所以next[7] = 1。 求next[8]： ①因为pattern[7]=pattern[1]，那么next[8] = next[7] + 1= 2。 求next[9]: ①因为pattern[8] = pattern[2]，那么next[9] = next[8] + 1 = 3。 void get_next(SString T, int next[]) { int i = 1, j =0; next[1] = 0; while(i < T.length) { if(j == 0 || T.ch[i] == T.ch[j]){ i++;j++; next[i] = j; // 若 pattern[i]=pattern[j]，则next[j+1] = next[j] + 1 } else { j = next[j]; // 令j=next[j],继续循环 } } } KMP 算法实现 int Index_KMP(SString source, SString pattern, int next[]) { int sIndex = 1, pIndex = 1; while(sIndex <= source.length && pIndex <= pattern.length) { if(pIndex == 0 || source.ch[sIndex] == pattern.ch[pIndex]) { ++sIndex; ++pIndex; } else{ pIndex = next[pIndex]; // 和暴力匹配不同，模式串并不是每次都是从第一个字符开始对比的 } } if(pIndex > pattern.length) return sIndex - pattern.length; else return 0; // 失败 }"
  },
  "Algorithm/Chapter5/5.1.html": {
    "href": "Algorithm/Chapter5/5.1.html",
    "title": "5.1 什么是树？",
    "keywords": "5.1 什么是树？ ​ 树是 n 个结点的有限集，n非负。当 n = 0 时，称为空树。任意非空树有以下特点： 有且仅有一个特定的称为根的结点。 n > 1 时，其余结点可分为 m(m > 0)个互不相交的有限集T1，T2，......，Tm。其中每个集合本身又是一颗树，称为根的子树。 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。 树中所有结点可以有零个或多个后继。 如上图所示： A 为 E、F、G、H、I、J 的 祖先 。E、F、G、H、I、J 是 A 的 子孙 。 A 是 B、C、D 的 双亲 ，B、C、D 是 A 的 孩子 。 B、C、D是 兄弟 ，H、I也是兄弟。 树中一个结点的孩子个数称为该结点的 度 。树中结点的最大度数称为 树的度 。A的度为3，C的度为0，D的度为2。 度大于0的结点称为 分支结点 。度为0的结点称为 叶子结点 。 结点的层次从树根开始定义，根结点第1层，它的子结点第2层，以此类推。上图的树为4层。双亲在同一层的结点称为 堂兄弟 。E、F、G、H、I 是堂兄弟。 结点的深度：从根结点往下数，每下一层就+1。 结点的高度：从当前结点网上数，没上去一层+1。 数的高度就是有几层。图中为4。 有序树：树结点的各子树从左到右有次序，不能互换， 路径：树的路径指祖先到孙子（双亲到孩子）的路径，堂兄弟或者远亲的路径不算。 路径长度：就是路径所含的边数。 森林：n 颗互不相交的树。"
  },
  "Algorithm/Chapter5/5.2.html": {
    "href": "Algorithm/Chapter5/5.2.html",
    "title": "5.2 二叉树",
    "keywords": "5.2 二叉树 每个结点至多只有两颗子树，有左右子树之分。如果某个结点的左右子树互换，那么就不是原来的树。 度为2的树，至少有3个结点，二叉树可以为空树。 二叉树就算某个结点只有一个孩子，也要区分左右孩子。 满二叉树 ：一颗高度为 h，且含有（2的h次方-1）个结点的二叉树称为满二叉树。树中每层还有最多结点。满二叉树的叶子结点都集中在最下面一层，除叶子结点外，每个结点的度为2。 自上而下，自左向右，以1起始开始编号，对于编号为 i 的结点，若有双亲，双亲的编号为 i/2； 若有左孩子，左孩子编号为 2i。若有右孩子，右孩子编号为 2i+1。 完全二叉树 ：高度为h、有 n个结点的二叉树，当且仅当其每个结点都与沟渎为h的满二叉树中编号为1-n的结点一一对应，称为完全二叉树。 完全二叉树的特征： 若 i ≤ n/2，则结点 i 为分支结点，否则为叶子结点。 叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点，都依次排列在该层最左边的位置上。 若有度为1的结点，则只可能出现一个，且该结点只有左孩子没有右孩子。 按层序编号后，一旦出现某结点为叶子结点或只有左孩子，则编号大于该结点的结点均是叶子结点。 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点只有左孩子，没有右孩子，其余分子结点左右孩子都有。 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一个二叉排序树。 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。 非空二叉树的叶子结点数等于度为2的结点树加1，即n0=n2+1。 结点数量为n，则边的数量为n-1。 非空二叉树的第k层上至多有2的（k-1）次方个结点。（k≥1） 高度为h的二叉树至多有2的h次方减1个结点。（h≥1） 顺序存储结构 顺序存储就是用一组连续地址来存储结点，在C++中就是数组。 如上述两个图，红色的结点就是空结点，在数组中表示如下： 那么怎么判断数组中各个结点之间的关系？ 根据前文的双亲结点和左右孩子结点之间的关系，通过下标来管理。 链式存储 顺序存储多出了很多的空结点，对空间利用率低。二叉树一般采用链式存储，用链表结点表示二叉树中各个结点之间的关系。 同样的一棵树，链式存储如下： 代码结构： template<class t> class TreeNode { t Data; // 数据域 TreeNode<t> *lChild, *rChild; // 左右孩子 } 含有n个结点的二叉链表中，含有n+1的空指针域。"
  },
  "Algorithm/Chapter5/5.3.html": {
    "href": "Algorithm/Chapter5/5.3.html",
    "title": "5.3 二叉树的遍历",
    "keywords": "5.3 二叉树的遍历 ​ 二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，且仅被访问一次。说白了，就是树是一种分叉结构，怎么想办法转换成线性结构。 概念：根结点N，左孩子L，右孩子R。 常见的遍历方法有 先序遍历NLR ， 中序遍历LNR ， 后序遍历LRN 。 如果是先序遍历的话，就是先访问根结点，再访问左孩子结点，再访问右孩子结点：ABDEC。 如果是中序遍历的话，就是先访问左孩子结点，再访问根结点，再访问右孩子结点：DBEAC。 如果是先序遍历的话，就是先访问左孩子结点，再访问右孩子结点，再访问根结点：DEBCA。 先序遍历 递归实现 void PreOrder(TreeNode<t> root) { if(root!=NULL) { visit(root); // 直接访问当前结点 PreOrder(root->lChile); // 递归左子树 PreOrder(root->rChild); // 递归右子树 } } 非递归实现 template <class t> void PreOrder2(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; // 辅助栈 TreeNode<t>* current = root; while (current != NULL || !st.empty()) // 当前遍历指针不为空或者栈不为空，则执行遍历 { if (current != NULL) { visit(current); st.push(current->rChild); // 右孩子入栈 current = current->lChild; // 指向当前结点的左孩子 } else { current = st.top(); // 出栈 st.pop(); } } } 这里借助一个std域的栈类辅助。 中序遍历 递归实现 void InOrder(TreeNode T) { if(T!=NULL) { InOrder(T->lChile); // 递归左子树 visit(T); // 直接访问当前结点 InOrder(T->rChild); // 递归右子树 } } 非递归实现 template<class t> void InOrder2(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; TreeNode<t>* current = root; while (current != nullptr || !st.empty()) { if (current != nullptr) // 一直往左字符下沉 { st.push(current); // 下沉过程中把遇到的结点入栈 current = current->lChild; } else { current = st.top(); // 出栈 st.pop(); visit(current); // 访问结点 current = current->rChild; // 指向右子树 } } } 后序遍历 递归实现 void PostOrder(TreeNode T) { if(T!=NULL) { PostOrder(T->lChile); // 递归左子树 PostOrder(T->rChild); // 递归右子树 visit(T); // 直接访问当前结点 } } 递归实现的本质，其实是利用了语言本身断点栈的特点，而非递归是要我们自己额外申请一个栈，用于保存当前循环有哪些待访问的结点。 非递归实现 template<class t> void PostOrder(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; TreeNode<t>* current = root; TreeNode<t>* r = nullptr; // 标记右子树是否被访问过 while (current != nullptr || !st.empty()) { if (current != nullptr) // 下沉至左边 { st.push(current); current = current->lChild; } else { current = st.top(); // 查看栈顶元素 if (current->rChild && current->rChild != r) // 右子树存在且未访问过 { current = current->rChild; } else { st.pop(); visit(current); r = current; // 记录最近访问过的点 current = nullptr; // 结点访问完后，重置指针 } } } }"
  },
  "Algorithm/Popular/1.1.html": {
    "href": "Algorithm/Popular/1.1.html",
    "title": "反转链表",
    "keywords": "反转链表 来源：牛客网 NC78 反转链表 翻转，可以利用栈的知识去解决，先把链表从表头到表尾的顺序按序入栈。然后再出栈，按照先出栈的结点顺序串起来的链表便是目标要求的新链表。但是如果用栈，空间复杂度就是O(n)，所以用指针来解决。 以四个结点为例： 第一轮循环： 第一轮循环结束后： 第二轮循环结束后： 第三轮循环结束后： 跳出 while 循环后，将新链表的末尾结点的next域指向nullptr。 struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (pHead == nullptr) return pHead; ListNode* pNewHead = pHead; // 新链的链头 ListNode* nextNode = pHead->next; // 下一下待翻转结点 ListNode* curList; // 当前待翻转链表链头 while (nextNode != nullptr) { curList = nextNode->next; nextNode->next = pNewHead; pNewHead = nextNode; nextNode = curList; } pHead->next = nullptr; // 令新链表的尾部元素的next域指向空指针 return pNewHead; } void Print(ListNode* pHead) { while (pHead != nullptr) { cout << pHead->val << \" \"; pHead = pHead->next; } } }; int main(int argc, char *argv[]) { Solution s; ListNode* pHead = new ListNode(1); ListNode* p = pHead; for (int i = 2; i < 10; i++) { p->next = new ListNode(i); p = p->next; } cout << \"before ReverseList: \" << endl; s.Print(pHead); pHead = s.ReverseList(pHead); cout << \"\\nafter ReverseList: \" << endl; s.Print(pHead); return 0; } 输出： before ReverseList: 1 2 3 4 5 6 7 8 9 after ReverseList: 9 8 7 6 5 4 3 2 1"
  },
  "CCP/intro.html": {
    "href": "CCP/intro.html",
    "title": "",
    "keywords": "这里是计算机组成原理的内容。"
  },
  "ComputerNetwork/intro.html": {
    "href": "ComputerNetwork/intro.html",
    "title": "",
    "keywords": "这里是计算机网络的内容。"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE.",
    "keywords": "This is the HOMEPAGE . 网页主要用于学习408综合基础知识。由于本人主要跟着王道团队线上线下学习，因此大多资料也出自王道团队的教学内容。 主要科目有： 科目名称 参看书籍 操作系统 王道 计算机网络 王道 数据结构与算法 王道 计算机组成原理 王道"
  },
  "Languages/Chapter1/1.2_IOstream.html": {
    "href": "Languages/Chapter1/1.2_IOstream.html",
    "title": "流的解释",
    "keywords": "流的解释 在1.1节中代码开头<iostream>是c++语言的一个标准库，提供IO机制。 ​ IO库包含两个基础类型： 名称 含义 istream 输入流 ostream 输出流 流的含义：一个流就是一个字符序列，随着时间的推移，字符是顺序生成或消耗的。 标准输入输出对象 标准库定义了4个IO对象。 名称 含义 cin 标准输入 cout 标准输出 cerr 输出警告信息 clog 输出日志打印信息 [^书上是这么说，但是在窗口使用cout\\cerr\\clog，看起来没什么区别。]: 上述四个关键字是在std命名空间下的，使用要加命名空间在前面，如std::cout。 如何使用输入输出流： #include <iostream> int main() { std::cout << \"input two numbers: \" << std::endl; int v1, v2; std::cin >> v1 >> v2; std::cout << \"v1 add v2 equals \" << v1 + v2 << std::endl; return 0; } 运行结果： input two numbers: 5 6 v1 add v2 equals 11 向流写入数据 先熟悉两个运算符： 运算符 含义 << 输出运算符 >> 输入运算符 std::cout << \"input two numbers: \" << std::endl; << 运算符接受两个运算对象，左侧运算对象必须是ostream对象，右侧运算对象是要打印的值。 << 运算符的结果是返回左侧的运算对象，因此可以连续使用两次 << 。 endl关键字是结束当前行，与设备关联的缓冲区中的内容全部刷到设备中。确保关联的缓冲中所有内容输出出来。 从流读取数据 std::cin>>v1>>v2; 和<<运算符类似。"
  },
  "Languages/Chapter1/1.3_Comments_Intro.html": {
    "href": "Languages/Chapter1/1.3_Comments_Intro.html",
    "title": "注释简介",
    "keywords": "注释简介 ​ 通常注释用于解释代码的功能或者代码即将要做的功能，编译时编译器会忽略注释。 错误的注释比没有注释更加糟糕！ 因此更新代码时，确保注释也得到对应的更新。 c++语言的注释： 注释方法 解释 // 注释内容 单行注释 /* 注释内容 */ 界定符注释 界定符注释可以放置任何允许放置制表符、空格符、换行符。还可以跨行。 #include <iostream> /* * 完成一个整数加法功能 * */ int main() { std::cout << \"input two numbers: \" << std::endl; // 提示信息 int v1, v2; std::cin >> v1 >> v2; std::cout << \"v1 add v2 equals \" << v1 + v2 << std::endl; return 0; } 界定符注释不能嵌套 /* * 注释对/**/ * */ 这个注释就是个错误的示范。"
  },
  "Languages/Chapter1/1.4_Control_Stream.html": {
    "href": "Languages/Chapter1/1.4_Control_Stream.html",
    "title": "控制流",
    "keywords": "控制流 语句一般是顺序执行的。 1 while语句 ​ while语句反复执行一段代码，知道给的条件为假为止。 示例：使用while语句求和1到10 #include <iostream> using namespace std; int main() { int i = 0 ,sum = 0; while (i <= 10) { sum += i; i++; } cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 while(condition) ​ statement; 其执行过程是交替执行condition和statement,直至condition为假为止。 2 do ... while语句 示例：使用doWhile语句求和1到10 #include <iostream> using namespace std; int main() { int i = 0 ,sum = 0; do { sum += i; i++; } while (i <= 10); cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 do{ ​ statement; }while(condition) 其执行过程是交替执行statement和condition，直至condition条件为假为止。和while区别是先执行statement语句。 3 for 语句 示例：使用for语句求和1到10 #include <iostream> using namespace std; int main() { int sum = 0; for (int i = 0; i <= 10; i++) { sum += i; } cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 for(statment1; condition; statment2) { ​ statement3; } 其执行过程是statement1,交替执行condition，statement3,statement2。 4 if语句 if语句是支持条件执行，是众多语言中最简单的语句之一。 if(condition1) { statement1; } else if(condition2) { statement2; } ... else if(conditionx) { statementx; } else{ statementlast; } 从上往下执行，最先遇到condition为true的是statement执行，其余不执行。 5 读取数量不定的输入数据 有一组数据，预先不知道其数据是多少。要计算这组数据的求和，只能一个一个读取。 int main() { int sum = 0, value = 0; while (cin >> value) { sum += value; // 把每个数据和加到sum } cout << \"result is \" << sum << endl; return 0; } 输入数据：10 43 92 result is 145 当使用istream流对象作为condition的时候，while判断条件时是检测流的状态。即如果流有效，没有遇到错误那么就是true。当流遇到文件结束符，或遇到一个无效输入时（输入的不是一个int类型的数），那么istream对象就会变为无效。 从键盘输入文件结束符 不同操作系统不同操作，在windows下是ctrl+z，然后按回车。"
  },
  "Languages/Chapter1/1.5_Class_Intro.html": {
    "href": "Languages/Chapter1/1.5_Class_Intro.html",
    "title": "类简介",
    "keywords": "类简介 类是对具有相同属性的事物的抽象，是一种数据结构。一个类定义了一个类型，以及与其相关的一组操作(方法)。类机制是C++最重要的特性之一。C++设计最初的一个初衷就是能定义使用上像内置类型一样自然的类类型。 类一般定义在头文件中。 定义一个Sales_Item类 从https://www.informit.com/store/c-plus-plus-primer-9780321714114网站摘抄，本人在此去掉代码前面的作者署名的大量注释。 /* * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B. * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the * copyright and warranty notices given in that book: * * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\" */ #ifndef SALESITEM_H // we're here only if SALESITEM_H has not yet been defined #define SALESITEM_H // Definition of Sales_item class and related functions goes here #include <iostream> #include <string> class Sales_item { // these declarations are explained section 7.2.1, p. 270 // and in chapter 14, pages 557, 558, 561 friend std::istream& operator>>(std::istream&, Sales_item&); friend std::ostream& operator<<(std::ostream&, const Sales_item&); friend bool operator<(const Sales_item&, const Sales_item&); friend bool operator==(const Sales_item&, const Sales_item&); public: // constructors are explained in section 7.1.4, pages 262 - 265 // default constructor needed to initialize members of built-in type #if defined(IN_CLASS_INITS) && defined(DEFAULT_FCNS) Sales_item() = default; #else Sales_item(): units_sold(0), revenue(0.0) { } #endif Sales_item(const std::string &book): bookNo(book), units_sold(0), revenue(0.0) { } Sales_item(std::istream &is) { is >> *this; } public: // operations on Sales_item objects // member binary operator: left-hand operand bound to implicit this pointer Sales_item& operator+=(const Sales_item&); // operations on Sales_item objects std::string isbn() const { return bookNo; } double avg_price() const; // private members as before private: std::string bookNo; // implicitly initialized to the empty string #ifdef IN_CLASS_INITS unsigned units_sold = 0; // explicitly initialized double revenue = 0.0; #else unsigned units_sold; // 一条销售记录的售卖书本数量 double revenue; // 一条销售记录的收入 #endif }; // used in chapter 10 inline bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) { return lhs.isbn() == rhs.isbn(); } // nonmember binary operator: must declare a parameter for each operand Sales_item operator+(const Sales_item&, const Sales_item&); inline bool operator==(const Sales_item &lhs, const Sales_item &rhs) { // must be made a friend of Sales_item return lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue && lhs.isbn() == rhs.isbn(); } inline bool operator!=(const Sales_item &lhs, const Sales_item &rhs) { return !(lhs == rhs); // != defined in terms of operator== } // assumes that both objects refer to the same ISBN Sales_item& Sales_item::operator+=(const Sales_item& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; } // assumes that both objects refer to the same ISBN Sales_item operator+(const Sales_item& lhs, const Sales_item& rhs) { Sales_item ret(lhs); // copy (|lhs|) into a local object that we'll return ret += rhs; // add in the contents of (|rhs|) return ret; // return (|ret|) by value } // 对>>运算符进行重写，输入书本条目时，需要输入isbn号、多少本书、单本书籍价格 std::istream& operator>>(std::istream& in, Sales_item& s) { double price; in >> s.bookNo >> s.units_sold >> price; // check that the inputs succeeded if (in) s.revenue = s.units_sold * price; else s = Sales_item(); // input failed: reset object to default state return in; } // 对 <<运算符进行重写，输出销售记录的isbn号，销售数量，销售数量，销售收入，每本书的平均价格 std::ostream& operator<<(std::ostream& out, const Sales_item& s) { out << s.isbn() << \" \" << s.units_sold << \" \" << s.revenue << \" \" << s.avg_price(); return out; } // 计算书的平均价格 double Sales_item::avg_price() const { if (units_sold) return revenue/units_sold; else return 0; } #endif 研读完上述代码后，输入一条销售记录的正确操作不仅仅是输入书籍isbn号码，而是要输入当前销售记录的isbn号，卖了几本，该书籍的售卖的单价。 如果一条销售记录输入的数据无效，只要三者有其一无效，当前写入的记录条目的数据全部默认为0。 Sale_Item类的应用 #include <iostream> #include \"Sales_item.h\" using namespace std; int main() { Sales_item total; // 保存下一条交易记录 // 读入第一条交易记录，并确保有数据处理 if (cin >> total) { Sales_item trans; // 保存和的变量 // 读入并处理剩余交易记录 while (cin >> trans) { // 如果任然在处理相同的书 if (total.isbn() == trans.isbn()) { total += trans; // 更新总销售额 } else { // 打印前一本书的结果 cout << total << endl; total = trans; // total 现在表示下一本书的销售额 } } cout << total << endl; // 打印最后一本书的结果 } else { // 没有输入！警告读者 cerr << \"No data?!\" << endl; return -1; } return 0; // 表示失败 }"
  },
  "Languages/Chapter1/intro.html": {
    "href": "Languages/Chapter1/intro.html",
    "title": "",
    "keywords": "#include <iostream> int main() { std::cout << \"Hello World!\\n\"; return 0; } 运行结果：Hello world!"
  },
  "Languages/Chapter2/2.1.html": {
    "href": "Languages/Chapter2/2.1.html",
    "title": "2.1 基本内置类型",
    "keywords": "2.1 基本内置类型 2.1.1 算术类型 c++定义了一套基本算术类型，包括算术类型和空类型。 算术类型 字符 整型数 浮点数 布尔值 还有一个空类型，常见用于当函数不返回任何值时使用。 常见的算术类型如下表： 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode字符 16位 char32_t Unicode字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 支持国际化的基本的字符类型是 char ，一个 char 类型的大小和机器字节大小一样。 ​ c++ 规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 浮点数可表示单精度、双精度和扩展精度值。 c++ 标准只是指定了一个浮点数有效位数的最小值，大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64比特）来表示， long double 以3个或4个字来表示。（这依赖于编译器和机器）。类型 float 和 double 分别有7和16位个有效位；类型 long double 带符号类型和无符号类型 ​ 除了布尔型和扩展的字符型，其他整型可以分为带符号的和无符号的。带符号类型可以表示正数、零和负数，无符号仅能表示大于等于0的数值。 带符号类型 无符号类型 int unsigned int short unsigned short long unsigned long long long unsigned long long 字符型比较特殊，被分为三种： char 、 signed char 、 unsigned char 。 char 和 signed char 不一定一样，取决于编译器，char可能是 signed char ，也可能是 unsigned char 。 无符号类型中，所有的数据比特都用于表示存储值，有符号类型则用一个比特表示符号，即 0 表示 + ， 1 表示 - 。 如何选择类型 当明确知道数值不可能为负数时，选用无符号类型。 使用 int 执行整数运算。现实中 short 太小而 long 一般和 int 一样，如果 int 范围不够，则用 long long 。 在算术表达式中不要使用 char 和 bool ,只有在存放字符或布尔值时才使用它们。因为 char 在一些机器上是有符号，在一些机器上是无符号。 执行浮点数运算使用 double ，因为 float 往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器， double 的运算比 float 还要快。而 long double 在一般情况下没必要，且计算代价高。 练习 练习2.1 类型 int 、 long 、 long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？ float 和 double 的区别是什么？ int 、 long 、 long long 和 short 都表示整形，在C++标准中，这四个类型定义的最小尺寸不一样。 short 短整形的最小尺寸是16位， int 整形的最小尺寸是16位， long 长整形的最小尺寸是32位， long long 长整形的最小尺寸是64位。一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 float 和 double 都表示浮点数， float 用一个字表示， double 用两个字表示， float 有效为为7位， double 有效位为16位。 练习2.2 计算按揭贷款，对于利率、本金和付款分别选择何种数据类型？说明你的理由。 应选择double类型，执行浮点数运算使用 double ，因为 float 往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器， double 的运算比 float 还要快。而 long double 在一般情况下没必要，且计算代价高。 2.1.2 类型转换 类型转换就是将对象从一种给定的类型转换为另一种相关类型。 bool b = 42; // b 为真 int i = b; // i 的值为1 i = 3.14; // i的值为3 double pi = i; // pi的值为3.0 unsigned char c = -1; // 假设 char占8比特，c的值为255 signed char c2 = 256; // 假设 char占8比特，c2的值时未定义的 把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为 false ，否则结果为 true 。 把一个布尔值赋给非布尔类型时，初始值为 false 则结果为0，初始值为 true 则结果为1。 把一个浮点数赋给整型类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当把一个整数值赋值给浮点类型时，小数部分记为0。如果整数所占空间超过浮点类型的容量，精度可能有损失。 当赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如8比特大小的 unsigned char 可以表示0至255区间的值，如果给我们赋一个区间以外的值，则实际结果该值对256取模后所得的余数。比如把-1赋给8比特大小的 unsigned char 所得结果是255。 一般不在算术表达式中使用布尔类型，因为布尔类型转换为整形后非零即一。 含有无符号类型的表达式 当一个表达式中含有无符号和 int 类型变量值时， int 值就会转换成无符号数。 unsigned u =10; int i = -42; cout << i + i << endl; // 输出-84 cout << u + i << endl; // 输出 4294967264 这是因为32位的 unsigned int 类型的u值为10的机器码表示为 (0000 0000 0000 0000 0000 0000 0000 1010）(二进制)，而 int 类型的i值为-42的机器码表示为(1111 1111 1111 1111 1111 1111 1101 0110 )（负数的机器码为真值的原码取反加1，高位为1），相加后得到的机器码为(1111 1111 1111 1111 1111 1111 1110 0000)，是一个 unsigned int 类型，所以打印输出时结果为 4294967264。 // 错误示范：这个循环会是个死循环，因为u不可能小于0。 for(unsigned u =10; u>=0;u--) { cout << u << endl; } 因此不要在计算表达式中混用带符号类型的变量和无符号类型的变量。 练习 练习2.3 读程序写结果： unsigned u =10, u2 = 42; cout << u2 - u << endl; cout << u - u2 << endl; int i = 10, i2 =42; cout << i2 - i << endl; cout << i - i2 << endl; cout << i - u << endl; cout << u - i << endl; unsigned int 和 int 是32位的机器上的类型。 真值 机器码（补码） 10 0000 0000 0000 0000 0000 0000 0000 1010 42 0000 0000 0000 0000 0000 0000 0010 1010 -10 1111 1111 1111 1111 1111 1111 1111 0110 -42 1111 1111 1111 1111 1111 1111 1101 0110 u2 - u ， 的结果是 0000 0000 0000 0000 0000 0000 0010 0000 ，类型是 unsigned int ，打印的值为32。 u - u2 ， 相当于10的机器码加上 -42的机器码，返回的类型是 unsigned int 类型。相加后的值为 1111 1111 1111 1111 1111 1111 1110 0000 ，打印得值为 4294967264。 i2 - i , 就是42的机器码加上-10的机器码，返回类型是 int 类型。相加后的值为 0000 0000 0000 0000 0000 0000 0010 0000 ，打印的值为32。 i - i2 ，就是10的机器码加上-42的机器码，返回类型是 int 类型。相加后的值为 1111 1111 1111 1111 1111 1111 1110 0000 ，打印的值为 -32。 i - u ，就是10的机器码加上 - 10的机器码，返回的是 unsigned int 类型 ，相加后的值为 0000 0000 0000 0000 0000 0000 0000 0000 。打印的值为0。 u - i ，就是10的机器码加上-10的机器码，返回的是 unsigend int 类型，相加后的值为 0000 0000 0000 0000 0000 0000 0010 0000 ,打印的值为0。 2.1.3 字面值常量 如“42”，”A“，这样的值，一望而知，称为字面值常量，每个字面值常量对应一种数据类型。 整型和浮点型字面值 整型字面值 十进制 八进制 十六进制 20 024 0x14 以0开头 以0x或0X开头 浮点型字面值 3.14159 3.14E1 .001 字符和字符串字面值 字符字面值 字符串字面值 'a' \"hello world\" 字符串由常量字符构成数组，编译器在每个字符串的结尾处添加一个空字符('\\0')，因此，字符串字面值的实际长度要比它的内容多1。 两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则实际上它们是个整体。 // 一行写不下，可以换行 cout << \"a really, really long string literal \" \"that spans two lines\" <<endl; // 相当于 \"a really, really long string literal that spans two lines\" 转义序列 两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是c++语言中有特殊含义的字符。需要转义序列，转义序列均以反斜线开始。 名称 换行符 \\n 纵向制表符 \\v 反斜线 \\\\ 回车符 \\r 横向制表符 \\t 退格符 \\b 问号 ? 进纸符 \\f 报警符 \\a 双引号 \\\" 单引号 \\' 泛化的转义序列，形式是\\x后紧跟1个或多个十六进制数字，或\\后紧跟1个或2个或3个八进制数字，其中数字部分表示的是字符对应的数值。因此， 反斜线\\后面紧跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。如“\\1234”表示两个字符，“\\123”和“4”。 指定字面值的类型 字符和字符串字面值 前缀 含义 类型 u Unicode16字符 char16_t U Unicode32字符 char32_t L 宽字符 wchar_t u8 UTF-8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double L'a' // 宽字符类型字面值，类型是 wchar_t u8 \"hi!\" // utf-8字符串字面值(utf-8用8位编码一个unicode字符) 42ULL // 无符号整数字面值，类型是unsigned long long 1E-3F // 单精度浮点型字面值，类型是float 3.14159L // 扩展精度浮点型字面值，类型是 long double 布尔字面值和指针字面值 布尔字面值 指针字面值 true和false。 nullptr 练习 练习2.5 指出下述字面值的数据类型并说明每一组内几种字面值的区别： (a) 'a'，L'a'，“a”，L\"a\" (b) 10, 10u, 10L，10uL，012，0xC (c) 3.14，3.14f，3.14L (d) 10，10u，10.，10e-2 答： ​ (a)组，'a'是 char 类型，内存占用1个字节。L'a'是 wchar_t 类型，内存占2个字节。“a”是字符串，存储串尾部还有一个'\\0'，编码格式为ASCIII编码格式。L\"a\"编码格式为 Unicode 编码格式，每个字符占用两个字节，因为串尾部结束符'\\0'也占两个字节，故该串占用4个字节。 (b)组， 10 是int类型常量，默认为有符号整型，最小尺寸为16位。 10u 是 unsigned int 类型，最小尺寸为16位。 10L 是 Long 类型，最小尺寸为32位。 10uL 是 unsigned long 类型，无符号长整型，最小尺寸为32位。012 是八进制的int类型常量，表示数值10（十进制）。0xC表示十六进制的int类型，数值为10。 (c)组，3.14表示双精度浮点数，类型为double，最小尺寸为10位有效数字。3.14f为单精度浮点数，类型为float，最小尺寸为6位有效数字.3.14L，表示 long double 类型，最小尺寸为10位有效数字。 (d)组，10表示int类型。10u表示 unsigned int 类型。10.表示双精度浮点数类型double。10e-2，用科学计数法表示的浮点数0.1。 练习2.6 下面两组定义是否有区别，如果有，请叙述之。 int month = 9,day = 7; int month = 09, day =07; 有区别，第一行是用十进制表示month和day，值分别为9和7。第二行用八进制表示month和day，但是month的值为无效字符，八进制的位不能大于7，是错误的，编译时不通过。 练习2.7 下述字面值表示何种含义？它们各自的数据类型是什么？ (a) \"who goes with F\\145rgus?\\012\"、 (b) 3.14e1L （c）1024f (d) 3.14L (a) \\145表示小写字母e，\\012表示换行符。为字符串类型，因此表示字符串为 who goes with Fergus? (b) 3.14e1L表示类型为 Long double 类型，值为31.4。 (c) 表示类型为 float 类型值为1024。 (d) long double 类型的3.14。 练习2.8 请利用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。 #include <iostream> using namespace std; int main() { cout << \"2\\115\\012\" << endl; // 输出2M和换行 cout << \"2\\t\\115\\012\" << endl; // 输出2 制表符 M 换行 return 0; }"
  },
  "Languages/Chapter2/2.2.html": {
    "href": "Languages/Chapter2/2.2.html",
    "title": "2.2 变量",
    "keywords": "2.2 变量 ​ 变量提供一个具名的、可供程序操作的存储空间。c++中每个变量都有其数据类型，数据类型决定着变量所占内存空间大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。 2.2.1 变量定义 基本形式：类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。 int sum = 0, value, units_sold = 0; // 其中sum 和 units_sold 初始值为0 Sales_item item; // item的类型是 Sales_item std::string book(\"0-201-78345-X\"); // book 通过一个string 字面值初始化 当对象在创建时获得一个特定的值，就做对象初始化。 列表初始化 初始化的形式有几种，如下，是给int类型变量进行初始化。 int units_sold = 0; // 常用 int units_Sold = {0}; int units_sold{0}; int units_sold(0); 用花括号来初始化变量，作为C++11新标准的一部分，已经得到全面应用，过去这种花括号初始化仅限在某些场合下使用。 使用花括号初始化存在丢失精度的风险时，编译器会报错。 long double ld = 3.1415926536; int a{ld}, b = {ld}; // 错误，转换为执行，因为存在丢失精度的风险 int c(ld), d =ld; // 正确，转换执行，且确实存在丢失了部分值 去掉上述第二行代码，加上两行打印代码运行，编译器会报警： 警告 C4244 “初始化”: 从“long double”转换到“int”，可能丢失数据 1.1.cpp 12 ，并且打印的值为 3，3。 cout << \"c: \" << c << endl; cout << \"d: \" << d << endl; 默认初始化 ​ 定义变量时没有指定初值，则变量被<font color= blue >默认初始化，此时变量被赋予默认值。默认值到底是什么取决于变量类型，同时定义变量的位置也会对此有影响。 ​ 如果是内置类型的变量被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不会被初始化。 一个未被初始化的内置类型变量的值是未定义的，试图拷贝或者以其他形式访问该类值将会引发错误。 ​ 每个类各自决定其初始化对象的方式。是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 ​ 绝大多数类都支持无需显式初始化而定义对象，这样的类提供了一个合适的默认值。比如std::string 类型，默认初始化为一个空串。自定义类Sales_item类也有其默认构造函数初始化。 练习 练习2.9 解释下列定义的含义。对于非法的定义，请说明在何处并将其改正。 (a) std::cin >> int input_value; (b) int i = {3.14}; (c) double salary = wage = 9999.99; (d) int i = 3.14; 答：(a) cin右侧紧跟的是已经定义的对象。此处应改为： int input_value; std::cin >> input_value; (b) 花括号初始化，如果存在精度丢失风险，编译器会报错。此处应改为： int i =3.14; // 或者 double i = {3.14}; (c) 定义double类型变量salary和wage，并显示初始化9999.99。定义形式错误，应该用逗号 隔开。此处应改为： double salary = 9999.99, wage = 9999.99; (d)定义一个int变量并初始化3.14，存在精度丢失，但是编译器允许编译通过。 练习2.10 下列变量的初值分别是什么？ std::string global_str; int global_int; int main() { int local_int; std::string local_str; } global_str初始化为一个空串；global_int初始化为0；local_int未执行初始化，因为定义在函数体内部，编译报错！ local_str初始化为一个空窜，即使在函数体内部定义了并没初始化，编译时也会通过。 因此，应当都每一个内置类型变量进行初始化，虽然不是必须，但是不这样做，可能存在访问时对时错的风险。 2.2.2 变量声明和定义的关系 ​ c++支持分离式编译机制，这个机制允许将程序分为若干文件，每个文件可被独立编译。 声明 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<font color= blue >定义负责创建与名字关联的实体。 ​ 变量声明规定了变量的类型和名字。定义也规定了变量的类型和名字，但是还要申请存储空间，也可能进行初始化。 ​ 如果仅仅是声明一个变量而不是定义它，那么在变量名前面添加关键字 extern ，而且不要显示初始化变量。 extern int i; // 声明i 而非定义i int j; // 声明并定义 j ​ 任何包含了显示初始化的声明即称为定义。 在函数体内部，试图初始化一个由 extern 关键字标记的变量，将会引发错误。 变量能且只能被定义一次，但是可以被多次声明。 ​ 如果在多个文件中使用同一个变量，就必须将声明和定义分离。变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 练习 练习2.11 指出下面的语句是声明还是定义。 (a) extern int ix = 1024; (b) int iy; (c) extern int iz; （a)是定义。(b)是声明。(c)是声明。 2.2.3 标识符 C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是大小写敏感。 C++关键字 alignas continue friend register true alignof decltype goto reinterpret_cast try asm default if return typedef auto delete inline short typeid bool do int signed typename break double long sizeof union case dynamic_cast mutable static unsigned catch else namespace static_assert using char enum new static_cast virtual char16_t explicit noexcept struct void char32_t export nullptr switch volatile class extern operator template wchar_t const false private this while constexpr float protected thread_local const_cast for public throw C++操作符代替名 and bitand compl not_eq or_eq xor_eq and_eq bitor not or xor 上述两个表格的关键字不能用作标识符。 练习 练习2.12 请指出下面的名字中哪些是非法的？ (a) int double = 3.14; (b) int _; (c) int catch-32; (d) int 1_or_2 =1; (e) double Double = 3.14; (a)显然非法，变量名的位关键字double。 (b)编译通过，但是一般不会这样命名，命名要准守一定的规范外最好做到 见名知意 。 (c)非法，变量名不能有“-”符号。 (d) 非法，必须以下划线开头或者字母开头。 (e)编译通过，变量名字是大小写敏感的，Double首字母大写，与double关键字不冲突。 2.2.4 名字作用域 代码中同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。 作用域是程序的一部分，在其中名字有其特定的含义。c++语言中大多数作用域都以花括号分隔。 同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 #include <iostream> using namespace std; int _testData; std::string global_str; int global_int; int main() { double local_data = 3.14; cout << local_data << endl; { int block_data = 10; cout << block_data << endl; } int data = block_data; // 访问block_data失败 return 0; } 代码中， _testData ， global_str 的作用域是 全局作用域 ，在整个程序代码中都能访问到，而像 local_data 的作用域是 块作用域 ，在声明之后的代码都能访问到，但是离开 main 函数再去访问 local_data ，就访问不到。而 block_data 这样的变量，定义在一个花括号括起来的块，出了块之后就不能再访问到。 嵌套作用域 作用域能包含彼此，被包含的作用域称为内层作用域，包含着别的作用域的作用域称为外层作用域。作用域一旦声明了某个名字，它所嵌套着的所有作用域都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。 #include <iostream> using namespace std; int _testData = 10; // _testData 为全局作用域 int main() { cout << _testData << endl; // 输出 10 double local_data = 3.14; double _testdata = 5; cout << _testdata << endl; // 优先使用距离代码最近的作用域，即输出 5 return 0; } 因此，当函数内部某个地方使用到全局变量，就不应该再定义一个同名的局部变量 。 练习 练习 2.13 下面程序中j的值是多少？ int i =42; int main() { int i = 100; int j = i; } j的值为100，给j赋值的i优先使用内部作用域。 练习2.14 下面的程序合法吗？如果合法，它将输出什么？ int i = 100, sum = 0; for(int i =0; i != 10; ++i) { sum+=i; } std::cout << i << \" \"<< sum <<std::endl; 合法，输出：100 45"
  },
  "Languages/Chapter2/2.3.html": {
    "href": "Languages/Chapter2/2.3.html",
    "title": "2.3 复合类型",
    "keywords": "2.3 复合类型 ​ 符合类型指基于其他类型定义的类型。这里仅介绍 引用 和 指针 。 2.3.1 引用 ​ 引用为对象起了另一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名： int ival = 1024; int &refVal = ival; // refVal指向ival（相当于给ival起了另一个名字） int &refVal2; // 报错，引用必须初始化 ​ 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。 引用即别名 ​ 引用不是一个对象，它只是一个已存在的对象所起的另一个名字，对其操作是在与之绑定的对象基础上进行操作。 int ival = 1024; int &refVal = ival; // refVal指向ival（相当于给ival起了另一个名字） refVal = 2048 cout << ival << endl; // 打印 2048 引用的定义 ​ 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头。 int i = 1024, i2 = 2048; int &r = i, r2 = i2; int i3 = 1024, &ri = i3; int &r3 = i3, &r4 = i2; ​ 引用只能绑定在对象上，不能绑定在字面值或某个表达式的计算结果。 int &refVal = 1024; // 报错 double dVal = 3.14; int refVal2 = dVal; // 报错，引用类型的初始值类型不匹配 练习 练习2.15 下面的哪个定义是不合法的？ (a) int ival= 1.01; (b) int &rvall = 1.01; (c) int &rval2 = ival; (d) int &rval3; ​ 答：(a)和(c)合法，(b)绑定只能绑定到对象上，不能绑定到具体的字面值上，(d)绑定必须初始化。 练习2.16 考查下面所有的赋值然后回答，哪些赋值是不合法的，为什么?哪些赋值是合法的，他们执行了什么操作？ int i = 0,&r1 = i; double d= 0, &r2 = d; (a) r2 = 3.14159; (b) r2 = r1; (c) i = r2; (d) r1 = d; ​ 答：(a) 合法，将3.14159赋值给了与r2绑定的对象。(b) 合法，将 r1绑定对象的值，赋值给 r2绑定的对象，因为r2绑定的对象是double类型，r1 是int类型，所以是可以运行的。(c) 不合法，会报警提示可能存在数据精度丢失。(d) 不合法。会报警提示可能存在数据精度丢失。 练习2.17 执行下面的代码段将会输出什么？ int i, &ri = i; i = 5; ri = 10; cout << i << \" \" << ri <<endl; ​ 输出10 10，这里ri与i的对象绑定在一起，对ri的任何操作都是对i的操作。 2.3.2 指针 ​ 指针是指向另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。指针是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象。指针无须在定义时赋初始值。 int *ip1, *ip2; // 两个指向int类型的指针 int dp, *ip3; // dp是int类型对象，ip3是指向int类型的指针。 获取对象的地址 ​ 指针存放某个对象的地址，而给指针赋值地址时需要 取地址符& 。 int ival = 42; int *p = &ival; // p指针指向ival对象 ​ 引用不是对象，无实际地址，所以不能将指针指向引用。 ​ 一般情况下，指针的类型要和它所指向的对象类型严格匹配。 double ival; double* pd = &ival; int* p1 = pd; // 报错，类型不匹配 int* p = &ival; // 报错，类型不匹配 指针值 ​ 指针的值是地址。指针要么指向一个对象，要么指向紧邻对象所占空间的下一个位置，要么是个空指针（因此对指针操作一般要进行判空），或者是个无效指针，随意访问可能导致程序崩溃。 利用指针访问对象 ​ 要知道指针指向一个对象，直接访问指针名，其实访问的是对象的地址，而一般数据是对象的内容，因此需要一个 解引用符* 来访问对象内容。 int ival = 42; int *p = &ival; // p 指向ival cout << p; // 输出p的地址 cout << *p; // 输出 42 ​ 给指针指向的对象赋值，也需要 解引用符* 。 *p=1024; // 给p指向的对象赋值 cout << *p; // 输出 1024 cout << ival; // 输出 1024 ​ 解引用符只适用于指针指向了明确的对象。 int ival = 42; int* p = NULL; // p 指向ival cout << *p << endl; // 运行时报错 空指针 ​ 空指针不指向任何对象，在试图使用一个指针之前代码可以先判空。三种生成空指针的方法。 int *p1 = nullptr; // c++11标准推荐使用这种方式赋值空指针 int *p2 = 0; int *p3 = NULL; // NULL实际就是0 赋值和指针 ​ 引用一旦绑定到某个对象之后，再解绑并对另一个对象绑定是不可能的。而指针就不同，指针可以再指向另一个对象。给指针赋值(地址)，就是令指针重新存放了一个地址，从而指向一个新的对象。 ​ 任何非0地址的指针在条件判断是都是true。 void* 指针 ​ void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个 void* 指针存放一个地址，存放什么类型地址我们不得而知。 double obj = 3.14159, * pd = &obj; void* pv = &obj; pv = pd; cout << *pv << endl; // 报错，void* 类型不允许访问，必须提前知道void*指针指向什么类型的地址，再用该类型的指针指向void*指向的指针，方可访问对象 return 0; 练习 练习2.18 编写代码分别更改指针的值以及指针所指向对象的值。 double obj = 3.14159, * pd = &obj; // pd指向obj对象 double x = 1919; pd = &x; // 更改pd的值，令其指向x对象 *pd = 1024; // 更改pd指向对象的值，即x值为1024 练习2.19 说明指针和引用的主要区别。 答，引用不是一个对象，没有实际地址，引用一旦绑定到某个对象，要再绑定到另一个对象是不可能的，因此引用必须初始化。指针是一个对象，有实际地址，指针可以更改值，从而指向新的对象，也不用初始化。 练习2.20 请叙述下面这段代码的作用。 int i =42; int *p1 = &i; *p1 = *p1 * *p1; 答：定义一个int类型变量i，指针p1指向i对象，将p1指向对象的值相乘然后赋值给pi指向的对象，因此i对象的值最后变为42*42。 练习2.21 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？ int i = 0; (a) double* dp = &i; (b) int *pi = i; (c) int *p = &i; 答：(a)非法，非空指针要和指向的对象严格类型匹配。(b) 指针初始化时是赋值地址，而非具体对象的值。 练习2.22 假设p是一个int型指针，请说明下述代码的含义。 if(p) // p如果是非空指针，则执行if后的代码块 if(*p) // 指针p指向的对象如果值不为0，这执行if后的代码块 练习2.23 给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断思路；如果不能，也请说明原因。 答：可以通过判空来确定是否指向了一个合法的对象。 练习2.24 在下面这段代码中为什么p合法而lp非法？ int i = 42; void *p = &i; long *lp = &i; 答：void*指针是特殊的指针，可以指向任意对象。而long指针只能指向long类型的对象。 2.3.3 理解复合类型的声明 int i = 1024, *p = i, &r = i; ​ 只需在某行代码前面写一个关键字 int ，然后声明变量的名字用逗号分隔，可以定义不同类型的变量。 指向指针的指针 ​ 不像引用，指针是内存中的对象，有自己的地址，因此可以将指针的地址存放到另一个指针中。通过*符号的个数可以区分指针的级别。 ** 表示指向指针的指针， *** 表示指向指针的指针的指针。 int ival = 1024; int *pi = &ival; // 指向ival的指针 int **ppi = &pi; // 指向pi指针的指针 cout << *pi << endl; // 输出 1024 cout << *ppi << endl; // 输出 pi的地址 cout << **ppi << endl; // 输出 1024 指向指针的引用 ​ 引用本身不是一个对象，因此不能定义一个指向引用的对象。但是指针是一个对象，可以定义一个指向指针的引用。 int i = 42; int *p; int *&r = p; // r是指向p的引用，相当于p有另一个名字：r r=&i; // 相当于将p指向了i *r=0; // 将i的值改为0 练习 练习2.25 说明下列变量的类型和值。 (a) int* ip, i, &r = i; (b) int i, *ip = 0; (c) int * ip, ip2; 答：(a) ip是个int类型指针，i是int类型对象，r是一个指向i对象的int类型引用。 (b) i是个int类型对象，ip是个空的int类型指针。 (c) ip是个int类型的指针，ip2是个int类型的对象。"
  },
  "Languages/Chapter2/2.4.html": {
    "href": "Languages/Chapter2/2.4.html",
    "title": "2.4 const 限定符",
    "keywords": "2.4 const 限定符 ​ const 关键字修饰的变量，它在初始化之后值不可再变。因此 const 修饰的的变量必须初始化。 const int value = 1024; // 正确 const int key; // 错误，const修饰必须初始化 默认状态下， const 对象仅在文件内有效 。 ​ 当以编译时初始化的方式定义一个 const 对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。即编译器会找到代码中所有用到变量的地方，替换成变量具体值。比如上述value，用到value的代码的地方，编译后全部被替换成1024。 ​ 编译器为了替换操作，必须在程序运行前知道变量的初始值。如果程序包含多个文件，则每个用了 const 对象的文件都必须能够访问到它的初始值。因此，必须在每个用到变量的文件中都对它进行定义。为了支持这一做法，同时避免对同一变量的重复定义，默认情况下， const 对象被设定为仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。 本人在vs2019的环境下，建立两个头文件test1.h和test2.h的头文件，分别定义const int data变量，一个初始化10，另一个初始化20，但是运行时报data重复定义(头部的#programe once去掉）。 ​ 如果不希望编译器为每个文件分别生成独立的变量，可以在变量声明定义时加上 extern 关键字。 // file_1.cc 定义初始化一个常量 extern const int bufSize = fcn(); // file_1.h extern const int bufSize; // 与file_1.cc中定义的bufSize是同一个 ​ file_1.h头文件的声明中也加了extern关键字，说明bufSize并非本文件所独有，它的定义在别处。 练习 练习2.26 下面哪些句子是合法的？如果有不合法的句子，请说明为什么？ (a) const int buf; (b) int cnt = 0; (c) const int sz = cnt; (d) ++cnt; ++ sz; (a) 不合法，常量必须初始化。(b)合法。(c)合法。(d)不合法，常量sz初始化之后不能再更改值。 2.41 const 的引用 ​ 可以把引用绑定到const对象上，即对常量的引用。其实就是给常量变量起了个别名，和正常的const对象一样，不能通过别名去更改const对象的值。 const int ci = 1024; const int &r1 = ci; r1 = 42; // 错误 int &r2 = r1; // 错误，不能将非常量引用指向一个常量引用。 初始化和对const的引用 ​ 引用的类型必须与其所引用对象的类型匹配，这里算是个特例：初始化常量时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。因此，允许一个常量引用绑定到非常量的对象、字面值，甚至一个表达式。 int i = 42; const int &r1 = i; const int &r2 = 42; const int r3 = r1 * 2; int &r4 = r1 * 2; // 不允许，r4是个非常量引用 编译器可能在运行过程中产生一个 临时量 。 double dval = 3.14; const int &ri = dval; 编译器编译后为了确保ri能绑定上一个数，自动添加代码： const int temp = dval; const int &ri = temp; 如果ri不是常量，编译器不会让代码编译通过，因为如果编译通过，那么ri绑定到的是temp，而非dval。 对const的引用可能引用一个并非const的对象 ​ 常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量不关心，所以引用的对象可能是个非常量，如果是个非常量，那就可以通过其他方法改变对象的值。因此对某些数据处理时，不希望处理的方法中改变原有数据，则可以对参数进行一个常量引用。 int i = 42; int &r1 = i; const int &r2 = i; r1 = 0; r2 = 0; // 不允许，r2是常量引用，不允许通过r2操作改变对象值 2.4.2 指针和 const ​ 可以令指针指向常量或非常量。 指向常量的指针 不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 const double pi = 3.14; double *ptr = &pi; // 错误，ptr是一个普通指针 const double *cptr = &pi; *cptr = 42; // 错误，不能给*cptr赋值 ​ 之前提到指针的类型必须与其所指向对象的类型一至，这里是特例，允许令一个指向常量的指针指向一个非常量对象： double dval = 3.14; cptr = dval; // 编译通过，但不能通过cptr改变dval的值 const 指针 ​ 常量指针就是把一个指针定为常量。常量指针必须初始化，一旦初始化完成，则它的值就不能再改变。把 * 放在 const 关键字之前用以说明指针是一个常量。即不可以改变指针的地址，但是可以改变指针所指向的对象的内容。 class Test{ public: double x; double y; Test() { x = 0.0; y = 0.0; } }; int main() { Test t; const Test* ptr = &t; // 指针常量 cptr->x = 10; // 错误，不能改变ptr指向对象的内容，但是可以改变ptr的地址 Test *const cptr = &t; // 常量指针 cptr->x = 10; // 正确，可以改变cptr指向对象的内容，但是不能改变cptr的地址 return 0; } 指向常量对象的常量指针 const double pi = 3.1415; const douboe *const ptr = &pi; // 意味着不能改变指针的地址，也不能改变指针指向对象的内容 练习 练习2.27 下面哪些初始化是合法的？ (a) int i = -1, &r = 0; (b) int *const p2 = &i2; (c) const int i = -1, &r = 0; (d) const int *const p3 = &i2; (e) const int *p1 = &i2; (f) const int &const r2; (g) const int i2 = i, &r = i; 答： (a)普通引用r绑定到字面值0上，这是不允许的。 (b)合法，p2是个常量指针，指向的地址不能变，但是可以改变i2对象的值。 (c)合法。 (d)合法。p3是一个指向常量的常量指针，不能改变指向的地址，也不能改变指向i2对象的内容。 (e)合法。p1是一个指向常量对象的指针，可以改变p1指向的地址，但是不能改变p1指向对象的内容。 (f)非法。引用本身不是一个对象。 (g)合法。 练习2.28 说明下面的这些定义是什么意思。挑出其中不合法的。 (a) int i, *const cp; (b) int *p1, *const p2; (c)const int ic, &r = ic; (d) const int *const p3; (e)const int *p; 答： (a) 不合法，i 是个int类型的普通变量。cp是个int类型的常量指针，必须要初始化。 (b) 不合法，p2是个常量指针，必须初始化。 (c)不合法， ic是个常量，必须初始化。 (d)不合法，p3是个指向常量对象的常量指针，必须要初始化。 (e) 合法，p是个指向常量的指针，不需要初始化。 练习2.29 假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？ (a) i = ic; (b) p1 = p3; (c) p1 = &ic; (d)p3 = &ic; (e) p2 = p1; (f)ic = *p3; 答： (a)合法，可以将int类型的常量赋值给普通变量i。 (b)不合法，不可以将普通变量指针指向一个指向常量的常量指针。 (c)不合法，不可以将普通变量指针指向一个常量对象。 (d)不合法，p3是个常量指针，不能再次赋值，应该在声明定义时对其进行初始化。 (e)不合法。p2是个常量指针，不能再次赋值，应该在声明定义时对其进行初始化。 (f)不合法。ic初始化之后不能再次赋值。 2.4.3 顶层 const ​ 顶层 const 表示指针本身是个常量，而 底层 const 表示指针所指的对象是个常量。 ​ 顶层const 可以表示任意的对象是常量， 底层const 则与指针和引用等复合类型的基本类型部分相关。 int i = 0; int *const p1 = &i; // 不能改变p1的值，可以改变p1指向对象的内容，这是一个顶层const const int ci = 42; // 不能改变ci的值，这是一个顶层const const int *p2 = &ci; // 允许改变p2的值，这是一个底层const const int *const p3 = p2; // 靠右的const是顶层const，靠左的const是底层const const int &r = ci; // 用于声明引用的const都是底层const 执行对象的拷贝操作时， 顶层const 几乎没什么影响。 i = ci; p2 = p3; 对 底层const 而言，拷贝和赋值的对象必须具有相同的 底层const 。 int *p = p3; // 错误，p3包含底层const，p是个普通变量指针， p2 = p3; // 正确，p2和p3都是底层const p2 = &i; // 正确，int*能转换成const int* int &r = ci; // 错误，普通的int&不能绑定到int常量上 const int &r2 = i; // 正确，const int&可以绑定到一个普通int上 练习 练习2.30 对于下面的这些语句，请说明对象被声明成了 顶层const 还是 底层const ？ const int v2 = 0; int v1 = v2; int *p1 = &v1, &r1 = v1; const int *p2 = &v2, *const p3 = &i, &r2 = v2; v2是顶层const；p2是底层const，p3及时底层const也是顶层const，r2是底层const。 2.4.4 constexpr 和常量表达式 ​ 常量表达式 是指值不会变并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。 const int max_files = 20; // max_files 是常量表达式 const int limit = max_files + 1; // limit是常量表达式 int staff_size = 27; // staff_size 不是常量表达式 const int sz = get_size(); // sz不是常量表达式 ​ sz是因为它的具体值直到运行时才能取到，所以也不是常量表达式。 constexpr 变量 ​ 在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始化值并非常量表达式的情况。在此种情况下，对象的定义和使用时两回事。 ​ c++11新标准规定，允许将标量声明为 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 。 constexpr int mf = 20; // 20 是常量表达式 constexpr int limit = mf + 1; // mf + 1是常量表达式 constexpr int sz = size(); // 只有当size是一个constexpr函数时，才是一条正确的声明语句 字面值类型 ​ 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。 ​ 算术类型、引用和指针都属于字面值类型。自定义类Sale_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。 ​ 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 ​ 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体外的变量一样有固定地址。constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。 指针和constexpr ​ 在 constexpr 声明中如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。 const int *p = nullptr; // p是一个指向整型常量的指针 constexpr int *q = nullptr; // q是一个指向整型的常量指针 constexpr把它所定义的对象置为了 顶层const 。 constexpr int *np = nullptr; // np是一个指向整数的常量指针，其值为空 int j = 0; constexpr int i = 42; // i的类型是整型常量 // i和j都必须定义在函数体之外 constexpr const int *p = &i; // p是常量指针，指向整型常量i constexpr int *p1 = &j; // p1是常量指针，指向整数j 练习 练习2.32 下面的代码是否合法？如果非法，请设法将其修改正确。 int null = 0, *p = null; 答：非法， int null = 0, *p = &null;"
  },
  "Languages/Chapter2/2.5.html": {
    "href": "Languages/Chapter2/2.5.html",
    "title": "2.5 处理类型",
    "keywords": "2.5 处理类型 ​ 程序越是复杂，程序用到的类型也越复杂。一些类型难于拼写，名字难记容易拼错，程序员不能望明知意，有时不清楚需要定义什么类型，得联系程序的上下文。 2.5.1 类型别名 ​ 类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。 ​ 两种方法定义类型别名。传统方法是使用关键字typedef: typedef double wages; // wages 是double的同义词 typedef wages base, *p; // base 是double的同义词，p是double*的同义词 含有typedef关键字的声明语句定义的不再是变量而是类型别名。 新标准规定了一种新的方法，使用别名声明类定义类型的别名： using SI = Sales_item; // SI 是Sales_item的别名 如何使用类型别名 ​ 相当于类型别名就是绑定的类型的一个别名，就当一种类型使用即可。事实上，编译器编译的时候就是把使用wages的地方替换成double。 wages mike = 5000; // 相当于 double mike = 5000; 指针、常量和类型别名 ​ 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生一些意想不到的后果。 typedef char *pstring; // 是类型char*的别名 const pstring cstr = 0; // cstr 是指向char的常量指针 const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针。 ​ 因为 pstring 是指向 char 的指针， const pstring 就是指向char类型的常量指针，意味着cstr一旦初始化之后，就不能再次更改其所指向的地址。因此不能把 const pstring cstr = 0 等同于 const char* cstr = 0 。 2.5.2 auto类型说明符 ​ 编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引进auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须知道初始值。 auto item = val1 + val2; // item的类型通过val1和val2相加的结果推算出来 ​ 同时也要注意，在一条语句声明多个变量中，变量的初始值要确保类型相同。 auto i = 0, * p = &i; // 正确，auto为int类型 auto sz = 0, pi = 3.14; // 错误，sz为int，而pi为double 复合类型、常量和auto ​ 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。 ​ auto一般会忽略掉顶层const，保留底层const。 const int ci = i, &cr = ci; auto b = ci; // b 是个int类型，而不是const int auto c = cr; // c 是个int类型，而不是const int auto d = &i; // d 是个整型指针 auto e = &ci; // e 是个指向整数常量的指针 因此如果希望推断出的auto类型是个顶层const，需要显示定义出来。 const auto f = ci; // ci 推演出int类型，则f是const int 和引用结合： auto &g = ci; // g是一个整型常量引用，绑定ci auto &h = 42; // 错误，不能为非常量引用绑定字面值 const auto &j = 42; // 正确 练习 练习 2.33 判断下列语句的运行结果 a = 42; b = 42; c = 42; d = 42; e = 42; g = 42; a是int类型，可再次赋值，运行正确。 b是int类型，可再次赋值，运行正确。 c是int类型，可再次赋值，运行正确。 d是整型指针，赋值42是错误的行为。 e是一个指向整数常数的指针，赋值42是错误行为。 g是一个整型常量引用，不可再次赋值。错误行为。 练习2.34 略 练习2.35 判断下列定义推断出的类型是什么，然后编写程序进行验证。 const int i = 42; auto j = i; const auto &k = i; auto *p = &i; const auto j2 = i, &k2 = i; j是int类型变量； k是对i对象的const int类型引用。 p是指向常量int的指针。 j2是常量int类型变量。 k2是对i对象的常量引用。 2.5.3 decltype 类型指示符 ​ 希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。C++11新标准引入第二种类型说明符 decltype ，其作用是选择并返回操作数的数据类型。在编译过程中，编译器分析表达式并得到其类型，却不实际计算表达式的值。 decltype(f()) sum = x; // sum类型就是函数f的返回类型 编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。 ​ decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用表达式是一个变量，则decltype返回该变量的类型。 const int ci = 0, &cj = ci; decltype(ci) x = 0; // x 的类型是const int decltype(cj) y = x; // y 的类型是const int&,y绑定到变量x decltype(cj) z; // 错误，z是一个引用，必须初始化 decltype和引用 ​ 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。 // decltype 的结果可以是引用类型 int i = 42, *p = &i, &r = i; decltype(r+0) b; // 正确，加法结果是int类型，所以b是一个int类型变量 decltype(*p) c; // 错误，c是int&, 必须初始化 如果表达式的内容是解引用操作，decltype将得到引用类型。 ​ decltype与auto的一个重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有所不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型。如果给变脸加上一层或多层括号，编译器就会把它当成一个表达式。变量时一种可以作为赋值语句左值的特殊表达式。 // decltype的表达式如果是加了括号的变量，结果将是引用 decltype((i)) d; // 错误，d是int&，必须初始化 decltype(*p) c; // 正确，e是一个int decltype((variable))（双层括号）的结果永远是引用，而decltype(variable)结果是只有当variable本身就是一个引用时才是引用。 练习 练习 2.36 请指出每一个变量的类型以及程序结束时它们各自的值。 int a = 3, b = 4; decltype(a) c = a; decltype((b)) d = a; ++c; ++d; a是int类型变量； b是int类型变量； c是int类型变量； d是int&类型变量，是对a的引用； 程序结束时，a的值为4；b是4；c是4；d是4； 练习2.37 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果i是int类型，则表达式i=x的类型是int&。根据这一特点，指出下面代码中每一个变量的类型和值。 int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // 这里d的类型是int& 变量名 类型 程序运行结束时的值 a int 3 b int 4 c int3 3 d int 3 练习2.38 说明decltype指定类型和由auto指定类型有何区别。 // case1: int i = 10； auto x = i; // x是int类型 decltype(i) v = i; // v是int类型 //case2: const int i = 10; auto x = i; // x 是int类型 decltype(i) v = i; // v是const int类型"
  },
  "Languages/Chapter2/2.6.html": {
    "href": "Languages/Chapter2/2.6.html",
    "title": "2.6 自定义数据结构",
    "keywords": "2.6 自定义数据结构 ​ 数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。C++允许用户以类的形式自定义数据雷兴国，而库类型string、istream、ostream等也都是以类的形式定义的。 此处内容不做笔记，详情参考第一章1.5节相关类的介绍。"
  },
  "Languages/Chapter3/3.1.html": {
    "href": "Languages/Chapter3/3.1.html",
    "title": "3.1 命名空间 using 的声明",
    "keywords": "3.1 命名空间 using 的声明 std::cin表示从标准输入中读取内容。作用域操作符::的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。故std::cin 的意思就是使用命名空间std中的名字cin。 如果在代码文件的前部使用：using namespace::name; 声明了语句，就可以直接访问命名空间name中的名字。 #include <iostream> using std::cin; int main() { int i; cin >> i; // 正确 cout << i; // 错误 std::cout << i; // 正确 return 0; } 每个名字都需要独立的using声明 如果想用std作用域下的所有名字，可以使用这样的声明方式： using namespace std; #include <iostream> using namespace std; int main() { int i; cin >> i; // 正确 cout << i; // 正确 std::cout << i; // 正确 return 0; } 头文件不应包含using声明 头文件的代码不应使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。"
  },
  "Languages/Chapter3/3.2.html": {
    "href": "Languages/Chapter3/3.2.html",
    "title": "3.2 标准库类型 string",
    "keywords": "3.2 标准库类型 string 标准库类型 string 表示可变长的字符序列，使用 string 类型必须首先包含 string 头文件。string 定义在命名空间 std 中。 3.2.1 定义和初始化 string 对象 初始化 string 对象常用的一些方式： string s1; // 空字符串 string s2 = s1; // s2是s1的副本 stirng s3 = \"hello\"; // s3是字符串hello的副本 string s4(10,'c'); // s4的内容是cccccccccc 如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所以的字符都被拷贝到新建的 string 对象中去。 代码 解释 string s1; 默认初始化，空串。 string s2(s1); s2是s1的副本。 string s2=s1; s2是s1的副本。 string s3(\"value\"); s3是字面值“value”的副本，除了字面值最后的那个空字符。 string s3 = \"value\"; 等价于 string s3(\"value\");。 string s4(n,'c'); 把s4初始化为连续n个字符c组成的串。 直接初始化和拷贝初始化。 使用等号(=)初始化一个变量，实际上是执行拷贝初始化，编译器把等号右侧的初始值拷贝到新建的对象中去。如果不使用等号，则执行的是直接初始化。(对基本类型也是适用的) int s(5); cout << s << endl; // 输出 5 3.2.2 string 对象上的操作 一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义<<、+等各种运算符在该类的新含义。 接口名 解释 os << s 将 s 写到输出流 os 当中，返回 os。 is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给s，返回 is。 s.empty() s 为空返回true，否则返回false。 s.size() 返回 s 中字符的个数。 s[n] 返回 s 中第n个字符的引用，位置 n 从0开始。 s1 + s2 返回 s1 和 s2 连接后的结果。 s1=s2 用 s2 的副本代替 s1 中原来的字符。 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等，返回true，否则返回false；判断对字母的大小写敏感。 s1!=s2 如果s1和s2中所含的字符完全一样，返回false，否则返回true；判断对字母大小写敏感 <，<=，>，>= 利用字符在ASCII字典中的顺序进行比较，且对字母大小写敏感。 string s1 = \"aacdaa\"; string s2 = \"abcd\"; if(s1 > s2) { cout << \"hit true s1 < s2\"; } // 如果s1 = \"accdaa\",则hit ture,因为第二个字符，c比b大 else { cout << \"hit false s\";} // hit false getline 代替>>运算符可以得到输入时的空白符。 string line; while (getline(cin, line)) cout << line << endl; empty和size的应用。 string line; while (getline(cin, line)) if(!line.empty()) // 空串不输出 cout << line << endl; string line; while (getline(cin, line)) if(line.size() > 20) // 超过20个字符才会输出 cout << line << endl; string::size_type 类型 size函数返回的是一个string::size_type类型而不是int类型。可以通过auto或decltype来推断变量的类型： auto len = line.size(); // len的类型是string::size_type size_type是一个无符号类型的值而且足够存放下任何string对象的大小。因此所有用于存放string类型的size函数返回值的变量，都应该是string::size_type类型。 因此应当小心使用带有int类型的变量与size()构成表达式，因为形如s.size()<n的判断结果，如果n是负数，则表达式中，赋值n会自动转换成一个比较大的无符号值 。 比较 string 对象 ==和!=分别检验两个 string 对象相等或不相等，string 对象相等意味着它们长度相同而且所包含的字符也全都相同。关系运算符>、<、>=、<=分别校验一个 string 对象是否小于、大于、小于等于、大于等于另外一个 string 对象。上述运算符依照ASCII码(大小写敏感)字典顺序: 如果两个 string 对象的长度不同，而且较短 string 对象的每个字符都与较长 string 对象对应位置上的字符相同，就说较短 string 对象小于较长 string 对象。 如果两个 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实是 string 对象中第一对相异字符比较的结果。 字面值和string对象相加 标准库允许字符字面值和字符串字面值转换成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面值代替。 当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算(+)的两侧的运算对象至少有一个是 string类型。 string s4 = s1 + \",\"; // 正确 string s5 = \"hello\" + \", world!\"; // 错误 string s6 = \"hello\" + s2 + \",please.\"; // 正确 string s7 = \"hello\" + \", world\" + s2; // 错误 string s7 = s2 + \"hello\" + \", world\"; // 正确，s2 + \"hello\"返回的是一个string对象，所以可以继续和后面的字符串相加 C++语言中的字符串字面值不是标准库中的string类型对象。 练习 练习 3.2 ：编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词。 int main() { string line; while (getline(cin, line)) // 读入一行 { cout << line << endl; // 打印 } return 0; } ----------------------------------------------- int main() { string word; while (cin >> word) // 读入数据，遇见空格符进入循环体 { cout << word << endl; // 打印 } return 0; } 练习 3.3 ：请说明 string 类的输入运算符和 getline 函数分别是如何处理空白字符的。 ​ 输入运算符遇到空白符就结束输入，因此输入的串中不会保留有空白字符。getline是保留输入时的空白符，从给定的输入流中读入内容，知道遇到换行符为止（换行符也被读进来了），之后把所读的内容存入到参数string对象中（去掉换行符）。总结就是，输入运算符是遇到空白符就停止输入并返回结果，getline函数是遇到换行符就停止输入并返回结果。 练习 3.4 ：编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等，输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。 int main() { string line1, line2; cout << \"input first line:\" << endl; getline(cin, line1); cout << \"input second line:\" << endl; getline(cin, line2); if (line1 == line2) // 字符串相等 { cout << \"相等：\" << line1 << endl; } else if (line1 > line2) // line1 比较大，输出line1 { cout << line1 << endl; } else // line2 比较大，输出line2 { cout << line2 << endl; } return 0; } 改写后： int main() { string line1, line2; cout << \"input first line:\" << endl; getline(cin, line1); cout << \"input second line:\" << endl; getline(cin, line2); auto len1 = line1.size(); auto len2 = line2.size(); if (len1 == len2) // 两个string对象长度相等 { cout << \"相等：\" << line1 << endl; } else if (len1 > len2) // line1 长度更长 { cout << line1 << endl; } else // line2 长度更长 { cout << line2 << endl; } return 0; } 练习 3.5 ：编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。 int main() { string line, sum; int count = 5; for (; count > 0; count--) // 输入5个字符串 { getline(cin, line); sum += line; // 拼接起来 } cout << sum << endl; return 0; } 改写： int main() { string line, sum; int count = 5; for (; count > 0; count--) // 输入5个字符串 { getline(cin, line); sum += line + \" \"; // 拼接起来 } cout << sum << endl; return 0; } 3.2.3 处理 string 对象中的字符 有时候需要单独处理 string 对象中的字符： 检查一个 string 对象是否有空白字符。 把字符中的大写变小写。 查看某个特定字符是否出现。 cctype头文件中定义了一组标准库函数处理这部分工作。 函数名 解释 isalnum(c) 当c是字母或者数字时为真。 isalpha(c) 当c是字母时为真。 iscntrl(c) 当c是控制字符时为真。 isdigit(c) 当c是数字时为真。 isgraph(c) 当c不是空格但可打印时为真。 islower(c) 当c是小写字母时为真。 isprint(c) 当c是可打印字符时为真。（即c是空格或c具有可视形式） ispunct(c) 当c是标点符号时为真。（即c不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当c是大写字母时为真。 isxdigit(c) 当c是十六进制数字时为真。 tolower(c) 如果c是大写字母，输出对应的小写字母；否则原样输出。 toupper(c) 如果c是小写字母，输出对应的大写字母；否则原样输出。 因此如果检查一个 string 对象是否包含某种空白字符，就可用到cctype头文件中的函数，遍历string对象串中每个字符进行处理。 遍历 string 对象可以用C++11最新提供的范围 for 语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作： for (declaration : expression) statement; 示例：统计字符串中标点符号的个数 #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"hello, world.\"; decltype(s1.size()) punct_nt = 0; // 标点符号个数 for (auto c : s1) { if (ispunct(c)) { punct_nt++; } } cout << punct_nt << \" punctuation characters in \" << s1 << endl; return 0; } // 输出结果： 2 punctuation characters in hello, world. 示例：将串改成小写字母 #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"HELLO, WORLD.\"; string s2; // 用于保存结果 for (auto c : s1) { s2 += tolower(c); } cout << \"after translate: \" << s2 << endl; return 0; } // 输出结果：after translate: hello, world. 书本上的示例： #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"HELLO, WORLD.\"; for (auto &c : s1) { c = tolower(c); // 如果s1是const常量类型，就不可用这种方式实现 } cout << \"after translate: \" << s1 << endl; return 0; } 使用下标运算符 将一行的首字母改为大写： #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"hello, world.\"; if (!s1.empty()) // 判断是否为空，如果为空，不能访问下标，这样会造成越界 { s1[0] = toupper(s1[0]); } cout << \"after translate: \" << s1 << endl; // 输出结果：after translate: Hello, world. return 0; } 使用下标执行遍历： int main() { string s1 = \"hello, world.\"; for (decltype(s1.size()) index = 0; index != s1.size() && !isspace(s1[index]); index++) { s1[index] = toupper(s1[index]); } cout << \"after translate: \" << s1 << endl; // 运行结果：after translate: HELLO, world. return 0; } 使用下标执行随机访问 编写一个程序把0到15之间的十六进制数转换成对应的十六进制数形式，只需初始化一个字符串令其存放16个十六进制“数字”。 int main() { const string hexdigits = \"0123456789ABCDEF\"; // 可能的十六进制数字 cout << \"enter a series of number between 0 to 15\" << \"separated by spaces. Hit ENTER when finished: \" << endl; string result; // 用于保存十六进制的字符串 string::size_type n; // 用于保存从输入流读取的数 while (cin >> n) { if (n < hexdigits.size()) { result += hexdigits[n]; // 得到对应的十六进制数字 } } cout << \"Your hex number is :\" << result << endl; return 0; } 练习 练习3.6 ：编写一段程序，使用范围for语句将字符串内的所有字符用X代替。 int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; for (auto& c : s1) // 范围for遍历 { if (isalpha(c)) { c = 'X'; } } cout << s1 << endl; return 0; } // 运行： // since i own you 3000 dollars, i will give you 2000 two days late. // XXXXX X XXX XXX 3000 XXXXXXX, X XXXX XXXX XXX 2000 XXX XXXX XXXX. 练习 3.7 ：就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什么？先预估一下结果，再实际编程进行验证。 一样啊，没什么变化。 练习 3.8 ：分别用while循环和传统for循环重写第一题的程序，你觉得那种形式更好？为什么？ while循环： int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; decltype(s1.size()) index = 0; while (index !=s1.size()) { if (isalpha(s1[index])) { s1[index] = 'X'; } index++; } cout << s1 << endl; return 0; } 传统for： int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; for (decltype(s1.size()) index = 0; index != s1.size(); index++) { if (isalpha(s1[index])) { s1[index] = 'X'; } } cout << s1 << endl; return 0; } 运行结果都一样，如果字符串不是const常量，用范围for更简洁。while和传统for没什么区别。 练习 3.9 ：下面的程序有何作用？它合法吗？如果不合法，为什么？ string s; cout << s[0] << endl; 输出s串的第一个字符。不合法，因为没对s串进行判断第一个字符串是否存在，如果不存在，就存在越界访问的行为，后果可能导致软件程序崩溃。 练习 3.10 ：编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。 int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; string temp; // 保存结果 for (auto& c : s1) { if (!ispunct(c)) { temp += c; } } s1 = temp; cout << s1 << endl; return 0; } // 运行结果: since i own you 3000 dollars, i will give you 2000 two days late. // since i own you 3000 dollars i will give you 2000 two days late 练习 3.11 ：下面的范围for语句合法吗？如果合法，c的类型是什么？ const string s = \"keep out!\"; for(auto &c : s){/*...*/} 不合法，s是个const string类型，是不允许再次更改内容，而&c是引用，可能导致在for循环体内对c进行赋值操作。 c的类型是char&。"
  },
  "Languages/Chapter3/3.3.html": {
    "href": "Languages/Chapter3/3.3.html",
    "title": "3.3 标准库类型 vector",
    "keywords": "3.3 标准库类型 vector ​ 标准类型库 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。也称为容器。使用 vector，必须包含头文件 #include<vector> using std::vector; // vector是一个类模板 vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不包含引用的vector。组成vector的元素也可以是vector（有点像二维数组）。 某些编译器可能需以老式声明语句处理元素为vector的vector对象，如 vector<vector<int> > ，而不是 vector<vector<int>> 。 3.3.1.定义和初始化 vector 对象 定义 vector 对象的常用方法。 定义 释义 vector v1 v1 是一个空 vector，它潜在的元素T类型，执行默认初始化。 vector v2(v1) v2中包含有v1所有元素的副本。 vector v2=v1 等价于v2(v1)。 vector v3(n, val) v3 包含了n个重复的元素，每个元素的值都是val。 vector v4(n) v4 包含了n个重复执行了值初始化的对象。 vector v5{a,b,c,d} v5 包含了初始值个数的元素，每个元素被赋予相应的初始值。 vector v5={a,b,c,d} 等价于vector v5{a,b,c,d} vector 拷贝需要注意两个vector对象类型必须相同： vector<int> ivec; vector<int> ivec2(ivec); vector<int> ivec3 = ivec2; vector<string> ivec4 = ivec2; // 错误，类型不一样 列表初始化 vector 对象 vector<string> articles = {\"a\", \"an\", \"the\"}; 含三个元素，“a”、“an”、“the”。 创建指定数量的元素 vector<int> ivec(10,-1); // 10 个int类型的元素，每个都被初始化为-1 vector<string> svec(10,\"hi!\"); // 10 个string类型的元素，每个都被初始化为 hi! 值初始化 只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋值给容器中的所有元素。这个初始值由vector对象中元素的类型决定。 vector<int> ivec(10); // 10个元素，每个都初始化为0 vector<string> svec(10); // 10个元素，每个都是空string对象 如果有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。 如果只提供了元素数量而没有设定初始值，只能使用直接初始化。 vector<int> vi = 10; // 错误 圆括号和尖括号初始化的不同 vector<int> v1(10); // v1有10个元素，每个元素值为0 vector<int> v2{10}; // v2有1个元素，值为10 vector<int> v3(10, 1); // v3有10个元素，每个值为1 vector<int> v4{10, 1}; // v4有两个元素，值分别为10,1 vector<string> v5{\"hi\"}; // 列表初始化：v5只有一个元素 vector<string> v6(\"hi\"); // 错误 vector<string> v7{10}; // v7有10个默认初始化的元素 vector<string> v8{10, \"hi\"}; // v8有10个值为hi的元素 练习 练习3.12 ：下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。 (a) vector<vector<int>> ivec; (b) vector<string> svec= ivec; (c) vector<string> svec(10, \"null\"); (a) 对c++11来说是正确的，老版c++不正确。 (b) 不正确，svec和ivec类型不匹配。 (c) 对。 练习3.13 ：下列的vector对象各包含多少个元素？这些元素的值分别是多少？ (a) vector<int> v1; (b) vector<int> v2(10); (c) vector<int> v3(10, 42); (d) vector<int> v4{10}; (e) vector<int> v5{10, 42}; (f) vector<string> v6{10}; (g) vector<string> v7{10, \"hi\"}; (a) 包含0个元素。 (b) 包含10个元素，每个元素值为0。 (c) 包含10个元素，每个元素值为42。 (d) 包含1个元素，值为10。 (e) 包含2个元素，值分别为10和42。 (f) 包含10个元素，值为空串。 (g) 包含10个元素，每个值为“hi”。 3.3.2 向 vector 中添加元素 push_back函数可以向vector函数中添加新的元素。新元素会被添加到vector尾部。 vector<int> v2; for(int i =0; i < 10; i++) { v2.push_back(i); } // 将1-9一共10个int类型对象按序放到v2尾部 vector对象能高效增长。不需要初始化时指定vector的大小。指定大小了反而会导致动态添加元素时性能的降低。 练习 练习3.14 ：编写一段程序，用cin读入一组整数并把它们存入一个vector对象。 int i; vector<int> ivec; while(cin>i) { ivec.push_back(i); } 练习3.15 ：改写上题的程序，不过这次读入的是字符串。 string word; vector<string> ivec; while(cin > word) { ivec.push_back(word); } 3.3.3 vector 其他操作 方法名 释义 v.empty() 如果v不含有任何元素，返回true；否则返回false。 v.size() 返回v中元素的个数。 v.push_back(t) 向v的尾部添加一个值为t的元素。 v[n] 返回v中第n个位置上元素的引用。 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a, b, c, d} 用列表中的元素拷贝替换v1中的元素v1 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <，<=，>，>= 以字典顺序比较。 计算 vector 内对象的索引 使用下标运算符能获取到指定的元素。vector 对象下标的起始是从0开始记起，下标对应的类型是size_type: vector<int>::size_type // 正确 vector::size_type // 错误 // 以 10分为一个分数段统计成绩的数量：0-9,10-19，...，90-99，100 vector<unsigned> scores(11, 0); // 11个分数段，全都初始化为0 unsigned grade; while(cin >> grade) // 读入成绩 { if(grade <= 100) // 只处理有效的成绩 ++scores[grade/10]; // 将对应分数段的计数值+1 } for(auto count: socres) { cout << count << \" \"; } // 输入 42 65 95 100 39 67 95 76 88 76 83 92 76 93 // 输出 0 0 0 1 1 0 2 3 2 4 1 不能用下标形式添加元素 vector不能通过下标的方式添加vector集合中的元素。 vector<int> ivec; for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec[ix] = ix; // 错误 } // 可以理解为vector长度为0的数组，因此，不能通过下标的方式添加新元素 ----------------------------------------------------------------- vector<int> ivec(10); for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec[ix] = ix; // 正确 } ----------------------------------------------------------------- vector<int> ivec; for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec.push_back(ix); // 错误 } 练习 练习3.16 ：编写一段程序，把 练习3.13 中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确。 vector<int> v2; for(int i =0; i < 10; i++) { v2.push_back(i); } // 将1-9一共10个int类型对象按序放到v2尾部 for(auto i : v2) { cout << i << \" \"; } 练习3.17 ：从 cin 读入一组词并把它们存入一个 vector 对象，然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。 string word; vector<string> svec; while (cin >> word) { svec.push_back(word); } for (auto& s : svec) { for (auto& c : s) { c = toupper(c); } } for (auto s : svec) { cout << s << endl; } return 0; 练习3.18 ：下面的程序合法吗？如果不合法，你准备如何修改？ vector<int> ivec; ivec[0]=42; 不合法，修改： vector<int> ivec; ivec.push_back(42); ---------------------------------- // 或者 vector<int> ivec(1); ivec[0] = 42; 练习3.19 ： 如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请列举三种不同的实现方法。哪种方法更好呢？为什么？ // 方法一： vector<int> vec(10, 42); // 方法二： vector<int> vec{42, 42, 42, 42, 42, 42, 42, 42, 42, 42}; // 方法三： vector<int> vec = {42, 42, 42, 42, 42, 42, 42, 42, 42, 42}; 当然是第一种方法好，理由是代码更简洁。 练习3.20 ：读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒数第2个元素的和，以此类推。 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; decltype(vect.size()) len = vect.size(); // 从第一个和第二个元素开始计算，依次类推 for (int i = 0; i < len - 1; i++) { cout << (vect[i] + vect[i + 1]) << endl; } 改写后： vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; decltype(vect.size()) len = vect.size(); // 奇数个数则不再计算中间的数 for (int i = 0; i < len / 2; i++) { cout << (vect[i] + vect[len -i -1]) << endl; }"
  },
  "Languages/Chapter3/3.4.html": {
    "href": "Languages/Chapter3/3.4.html",
    "title": "3.4 迭代器介绍",
    "keywords": "3.4 迭代器介绍 对于string和vector对象，可以通过下标的方式访问其中的元素，也可以通过迭代器的机制访问元素。 3.4.1使用迭代器 和指针不同，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。 // b表示v的第一个元素，e表示v尾元素的下一位置 auto b = v.begin(), e = v.end(); 迭代器运算符 运算符 释义 *iter 返回迭代器iter所指元素的引用。 iter->mem 解引用并获取该元素的名为mem的成员，等价于(*iter).mem ++iter 令iter指示容器的下一个元素。 --iter 令iter指示容器的上一个元素。 iter1 == iter2 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾后迭代器，则相等。反之，不等。 iter1 != iter2 与iter1 == iter2 相反。 和指针类似，可以通过解引用迭代器获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或尾后迭代器都是未被定义的行为。 string s(\"some thing\"); if(s.begin()!s.end()){ // 确保s非空 auto it = s.begin(); // it 表示s的第一个字符 *it = toupper(*it); // 首个单词的首字母大写。 } 将迭代器从一个元素移动到另一个元素 使用递增运算符（++）： for( auto it = s.begin(); it != s.end(); it++) { *it = toupper(*it); // 依次将当前字符改写成大写形式 } 迭代器类型 我们不知道也无需知道迭代器的精确类型。那些拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型。 vector<int>::iterator it; // it 能读写vector<int> 的元素。 string::iterator it2; // it2 能读写 string 对象中的字符 vector<int>::const_iterator it3; // it3只能读元素，不能写元素 string::const_iterator it4; // it4 只能读元素，不能写元素 可以理解为iterator是个指针，指向对象可读可写。const_iterator 是个指向常量的指针变量，指向的对象可读不可写。 begin和end运算符 begin和end运算符返回的具体类型由对象是否是常量决定。 运算符 常量对象的返回类型 非常量对象的返回类型 begin const_iterator iterator end const_iterator iterator C++11专门引入两个新函数。cbegin和cend。无论对象是否是常量，cbegin和cend返回值都是const_iterator类型。 结合解引用和成员访问操作 // 假如需要读取 vector<string> 对象的内容，判断是否为空串 (*it).empty() // 解引用it，然后调用结果对象的empty()成员 *it.empty() // 错误，尝试读取it的empty成员，it是个迭代器，没有empty成员 箭头运算符将解引用和成员访问操作结合在一起。 it->empty() //等价于(*it).empty() 注意事项 不能在范围for循环中向vector对象添加元素。任何一种可能改变vector对象容量的操作，如push_back，都会使该vector对象的迭代器失效。 3.4.2 迭代器运算 迭代器的算术运算 迭代器和一个整数值相加或相减，其返回值是向前或向后移动了若干个位置的迭代器。类似指针在迭代器“连续”的地址中前进或后退。 可以运用运算符(>、>=、<、<=)进行指向同一个容器的两个迭代器之间的前后关系。 // 计算得到最接近vi中间元素的一个迭代器 auto mid = vi.begin() + vi.size() / 2; if(it < mid) // 处理vi的前半部分元素 使用迭代器运算 二分搜索： // text 必须有序 auto beg = text.begin(), end = text.end(); auto mid = text.begin() + (end - beg) / 2; // 初始状态下的中间点 // 当还有元素尚未检查并且还没有找到sought时执行循环 while(mid != end && *mid != sought) { if(sought < *mid) end = mid; // 在 mid 之前找 else beg = mid + 1; // 在 mid 之后找 mid = beg + (end - beg) / 2; // 新的中间点 } 练习 练习3.24 ：请使用迭代器重做3.3.3节的最后一个练习。 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; for (auto beg = vect.cbegin(); beg != vect.cend() - 1; beg++) { cout << (*beg) + *(beg + 1) << endl; } // 输出结果 15 15 15 15 15 15 15 改写后： // 奇数个数，则不输出中间位和自己相加 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 }; auto mid = vect.cbegin() + vect.size() / 2; // 中间位置 for (auto cbeg = vect.cbegin(), cend =vect.cend() - 1; cbeg != mid; cbeg++, cend--) { cout << (*cbeg) + (*cend) << endl; } // 输出结果 16 16 16 16 16 16 练习3.25 ：3.3.3节划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序并实现完全相同的功能。 // 以 10分为一个分数段统计成绩的数量：0-9,10-19，...，90-99，100 vector<unsigned> scores(11, 0); // 11个分数段，全都初始化为0 unsigned grade; auto beg = scores.begin(); while (cin >> grade) // 读入成绩 { if (grade <= 100) // 只处理有效的成绩 *(beg+ grade / 10) = *(beg + grade / 10) + 1; // 将对应分数段的计数值+1 } for (auto count : scores) { cout << count << \" \"; } 练习3.26 :在100页的二分搜索程序中，为什么用的是mid=beg+(end - beg) / 2，而非mid = (beg + end) / 2？ end - beg 表示两个迭代器的距离，除2再加上beg就得到了中间位置。显然(beg + end)/2得到的并不是迭代器的中间位置。"
  },
  "Languages/Chapter3/3.5.html": {
    "href": "Languages/Chapter3/3.5.html",
    "title": "3.5 数组",
    "keywords": "3.5 数组 ​ 数组是一种类似标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。数组是存放类型相同的对象的容器，这些对象本身没有名字，可以通过其所在位置访问。数组大小固定不变，不能随意向数组中添加元素。可见灵活性差了点。 3.5.1 定义和初始化内置数组 数组中的元素个数必须大于0；编译时维度，即数组个数应该是已知的。 unsigned int cnt = 42; // 不是常量表达式 constexpr unsigned int sz = 42; // 常量表达式 int arr[10]; // 含有10个整数的数组 int* parr[sz]; // 含有42 个整型指针 string bad[cnt]; // 错误，cnt不是常量表达式 string strs[get_size()]; // 当get_size是constexpr 时正确，否则错误 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 显示初始化数组 const unsigned sz = 3; int ia1[sz] = {0, 1, 2}; // 含有3个元素的数组，元素值分别是0 ， 1， 2 int a2[] = {0, 1, 2}; //维度是3的数组 int a3[5] = {0, 1, 2}; // 等价于 a3={0,1,2,0,0} string a4[3] = {\"hi\", \"bye\"}; // 等价于a4[] = {\"hi\", \"bye\", \"\"} int a5[2] = {0, 1, 2}; // 错误，初始值过多 字符数组的特殊性 字符字面值的结尾处有一个空字符，不显示在代码中。 char a1[] = {'C', '+', '+'}; // 列表初始化，没有空字符 char a2[] = {'C', '+', '+', '\\0'}; // 列表初始化，含有显式的空字符 char a3[] = \"c++\"; // 自动添加表示字符串结束的空字符 const char a4[6] = \"Daniel\"; // 错误，没有空间可存放空字符 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： int a[] = {0, 1, 2}; int a2[] = a; // 错误 a2 = a; // 错误 理解复杂的数组声明 int *ptrs[10]; // ptrs是含有10个整型指针的数组 int &refs[10] = /*?*/; // 错误，不存在引用数组 int (*Parray)[10] = &arr; // Parray 指向一个含有10个整数的数组。 int (&arrRef)[10] = arr; // arrRef 引用一个含有10个整数的数组。 (*Parray)[0] = 10; // 正确使用 arrRef[0] = 100; // 正确使用 int* (&array)[10] = ptrs; // array 是数组的引用，该数组含有10个指针 练习 练习3.27 假设 txt_size 是一个无参数的函数，它的返回值是 int。请回答下列哪个定义是非法的，为什么？ unsigned buf_size = 1024; (a)int ia[buf_size]; (b)int ia[4 * 7 - 14]; (c)int ia[txt_size()]; (d) char st[11] = \"fundamental\"; a是非法的，buf_size不是常量，数组在编译时就必须知道其大小。 c是非法的，理由同a。 d是非法的，字符串字面值结尾有一个隐含的空格字符，\"fundamental\"实际上的长度为12。 练习3.28 下列数组中元素的值是什么？ string sa[10]; int ia[10]; int main() { string sa2[10]; int ia2[10]; } sa中含有10个空字符串； ia含有10个初始化为0的字符串； sa2数组有10个未定义的string类型； ia2数组含有10个未定义的值。 如果打印每个数组的信息的话： ia的打印信息为： 0 0 0 0 0 0 0 0 0 0 ia2的打印信息为： -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有为定义的值。 3.5.2 访问数组元素 可以使用范围for语句或者下标运算符访问数组元素。数组索引从0开始。 unsigned scores[11] = {}; // 11 个分数段，全部初始化为0 unsigned grade; while( cin>> grade) { if(grade <= 100) ++scores[grade/10]; // 将当前分数段的计数值加1 } for( auto i : scores) { cout << i << \" \"; } 检查下标的值 编译器编译时并不会检查数组下标是否越界，要靠人工检查。要防止越界行为，因为越界产生各种意想不到的后果。 练习 练习3.30 指出下面代码中的索引错误。 constexpr size_t array_size = 10; int ia[array_size]; for(size_t ix = 1; ix <= array_size; ++ ix) ia[ix] = ix; 数组索引的下标从0开始，而for语句中的ix从1开始，遍历下标从1到10，ia[10]导致数组越界。 练习3.31 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。 int arr[10]={}; for(int index = 0; index < 10; index++) { arr[index] = index; } 练习3.32 将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。 int arr2[10]; for(int i = 0;i < 10; i++) { arr2[i] = arr[i]; } 练习3.33 对于104页的程序来说，如果不初始化scores将会发生什么？ 因为函数内部定义的数组默认初始化是未定义的值，因此可能导致数据并不是预期的。 3.5.3 指针和数组 ​ 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针。 string nums[] = {\"one\", \"two\", \"three\"}; // 数组的元素是string对象 string *p = &nums[0]; // p指向nums的第一个元素 // 用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 string *p2 = nums; // 等价于 p2 = &nums[0]; int ia2[10] = {}; int* p = &ia2[3]; *p = 1; p++; *p = 2; for(auto s : ia2) { cout << s << \" \"; } // 打印 0 0 0 1 2 0 0 0 0 0 ​ 在一些情况下，对数组的操作，实际上是对指针的操作。如果对数组使用auto变量的初始值时，推断得到的类型是指针而非数组。 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素，等价于 auto ia2(&ia[0]) ia2 = 42; // 错误。ia2是个指针 ​ 但是如果用decltype关键字时，decltype(ia)返回的类型是由10个整数构成的数组： decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; // 错误，ia3不能用整型指针给数组赋值 ia3[4] = i; // 正确 int *e = &arr[10]; // arr数组只有10个元素，arr[10]是arr数组的最后一个元素指向的下一个位置 for(int *b = arr; b != e; ++b) { cout << *b << endl; // 输出arr的元素 } 标准库函数begin和end ​ C++11标准引入两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。这两个函数定义在头文件 iterator 中。 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7 , 8, 9}; int *beg = begin(ia); // 指向ia首元素的指针 int *last = end(ia); // 指向arr尾元素的下一位置的指针 int *pbeg = begin(arr), *pend = end(arr); // 寻找第一个负值元素，如果已经检查完全部元素则结束 while(pbeg != pend && *pbeg > 0) pbeg++; 指针运算 ​ 可以把指针看做是一种迭代器，可以解引用、递增、比较、与整数相加、两个指针相减。 constexpr size_t sz = 5; int arr[sz] = {1, 2, 3, 4, 5}; int *ip = arr; int *ip2 = ip + 4; // ip2指向arr的尾元素arr[4] // 正确，arr转换成指向它的首元素的指针；p指向arr尾元素的下一位置 int *p = arr + sz; // 不要使用解引用 int *p2 = arr + 10; // 指向了未知内存 ​ 如果指针指向的位置超过了数组的尾元素，则会指向未知内存，访问未知内存可能引发无法意料的后果。编译器编译过程中无法发现类似的问题。 ​ 两指针相减是他们之间的距离。两指针相减的结果类型是名为ptrdiff_t的标准库类型，定义在cstddef头文件中的机器相关的类型。是一种有符号类型。 auto n = end(arr) - begin(arr); // n的值是5 ​ 如果两个指针指向不相关的数组，他们之间的运算是毫无意义的。 解引用和指针运算的交互 ​ 指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。 int ia[] = {0,2,4,6,8}; int last = *(ia + 4); // 等价于last = ia[4]; 下标和指针 int ia[] = {0,2,4,6,8}; int i = ia[2]; int *p = ia; i = *(p+2); // 等价于i=ia[2] 只要指针指向的是数组中的元素，都可以执行下标运算。 int *p = &ia[2]; // p指向索引为2的元素 int j = p[1]; // p[1] 等价于*(p+1),就是ia[3]表示的那个元素 int k = p[-2]; // p[-2]是ia[0]表示的那个元素 虽然标准库类型string和vector也能执行下标运算，但是数组和它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 练习 练习3.34 ：假定p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？ p1 += p2 - p1; p1指向数组元素不变。如果p1和p2分别指向不同的数组，那么是非法的。 练习3.35 ：编写一段程序，利用指针将数组中的元素置为0。 int arr[sz] = { 1, 2, 3, 4, 5 }; auto pbegin = begin(arr); auto pend = end(arr); while (pbegin != pend) { (*pbegin) = 0; pbegin++; } 练习3.36 ：编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。 // 比较两个数组是否相等 int a1[] = {1,2,3,4,5}; int b1[] = {1,2,3,4,5}; bool ret = true; // 长度不等，数组直接不相等 if(sizeof(a1) != sizeof(b1)) { ret = false; } else{ for(int index = 0; index < sizeof(a1); index ++) { if(a1[index] != b1[index]) { ret = false; } } } if(ret) { cout << \"数组相等\" << endl; } else { cout << \"数组不相等\" << endl; } vector<int> vect1 = {1,2,3,4,5}; vector<int> vect2 = {1,2,3,4,5}; if(vect1 == vect2) { cout << \"两个vector对象相等\" << endl; } else { cout << \"两个vector对象不等\" << endl; } 3.5.4 C 风格字符串 字符串字面值是一种通用结构的实例，是C++继承C而来的C风格字符串。字符串存放在字符数组中以空字符（'\\0'）结束。 C 标准库 String 函数 cstring头文件提供了一组用于操作C风格字符串的函数。 函数名 释义 strlen(p) 返回p的长度，空字符不计算在内。 strcmp(p1, p2) 比较p1和p2的相等性。如果 p1 和 p2 相等，返回0；如果 p1 > p2，返回一个正值；如果 p1 < p2，返回一个负值。 strcat(p1, p2) 将 p2 附加到 p1 之后，返回 p1。要注意p1的容量是否足够容纳下追加之后的字符串，如果不够，会报弹窗。 strcpy(p1, p2) 将 p2 拷贝给 p1，返回 p1。要注意p1的容量是否足够容纳下p2的字符串，如果不够，会报弹窗。 char s1[80] = \"this is a world station6\"; char s3[] = \"this is a world station3\"; char s2[] = \"Don't go into the night with gentle.\"; auto x = strcat_s(s1, s3); cout << strlen(s1) << endl; // 输出 48 // strcat函数现在的编译器会报不安全，使用strcat_s函数，功能一样 // 同理strcpy也由strcpy_s代替。 对上述的函数，传入的数组必须要用空字符作为结束符。 char ca[] = {'C', '+', '+'}; // 不以空字符结束 cout << strlen(ca) << endl; // 错误，ca没有以空字符结束 运行上述代码，因为strlen是以遇到'\\0'作为结束标记，所以就一直沿着ca地址不断递增，知道遇到'\\0'才结束，因此每次运行的结果不一定一样。 练习 练习3.37 ：下面的程序是何定义，程序的输出结果是什么？ const char ca[] = {'h', 'e', 'l', 'l', 'o'}; const char *cp = ca; while(*cp){ cout << *cp << endl; ++cp; } C风格字符串以空字符结束。必须指向以空字符作为结束。 将数组ca的每个元素逐个打印出来；因为没有以'\\0'结束，就一直沿着ca地址循环输出未知字符。 练习3.38 ：为何将两个指针相加没意义？ 一个地址加上另一个地址，对寻址内容来说毫无意义。 练习3.39 ：编写一段程序，比较两个string对象。再编写一段程序，比较两个C风格字符串的内容。 string s1 = \"this is a string\"; string s2 = \"this is a string.\"; if (s1 == s2) { cout << \"s1 = s2\" << endl; } else if(s1 < s2) { cout << \"s1 < s2\" << endl; } else { cout << \"s1 > s2\" << endl; } 比较两个C风格字符串时： ①如果长度相等，则逐个比较大小，一旦某个相同位置下出现大于或者小于，停止比较，否则就是相等。 ②如果长度不等，则在前L个位置比较（假设长度较短的数组长为L），如果出现大于或者小于的情况，停止比较。否则就是更长的那个数组大于更短的数组。 char s1[] = \"this is a string\"; char s2[] = \"this is a string\"; int len1 = strlen(s1); int len2 = strlen(s2); int iseq = 0; // 0：相等；1：大于；-1：小于 if (len1 == len2) { for (int i = 0; i < len1; i++) { if (s1[i] > s2[i]) { iseq = 1; break; } else if (s1[i] < s2[i]) { iseq = -1; break; } else { continue; } } } else if(len1 < len2) { bool ishit = false; // 是否在逐个字符比较中确定大于或小于 for (int i = 0; i < len1; i++) { if (s1[i] > s2[i]) { ishit = true; iseq = 1; break; } else if (s1[i] < s2[i]) { ishit = true; iseq = -1; break; } else { continue; } } if (!ishit) // s1 小于 s2 { iseq = -1; } } else { bool ishit = false; // 是否在逐个字符比较中确定大于或小于 for (int i = 0; i < len2; i++) { if (s1[i] > s2[i]) { ishit = true; iseq = 1; break; } else if (s1[i] < s2[i]) { ishit = true; iseq = -1; break; } else { continue; } } if (!ishit) // s1 大于 s2 { iseq = 1; } } switch (iseq) { case 0: cout << \"s1 = s2\" << endl; break; case 1: cout << \"s1 > s2\" << endl; break; case -1: cout << \"s1 < s2\" << endl; break; } 练习3.40 ：编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组中。 char c1[100] = \"hello world!\"; char c2[100] = \"welcome to China!\"; char c3[100]; strcat_s(c1, c2); // 将c2 追加到 c1后面 strcpy_s(c3, c1); // 将c1 拷贝给 c3 cout << c3 << endl; 3.5.5 与旧代码的接口 ​ 旧代码的来源是，有些老项目，没出现标准库vector、string之前就写好了。现在可能要重新维护功能，引入标准库之后如何去操作？ 混用 string 对象和 C 风格字符串 ​ 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代。 允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是数组）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 string 转 const char char *str = s; // 错误 const char *str = s.c_str(); c_str 函数的返回值是一个C风格的字符串。函数返回的结果是个指针，该指针指向一个以空字符结束的字符数组。这个数组所存的数据恰好与那个string对象的一样。无法通过str去改变字符数组的内容，但是如果改变了s的内容，那么str指向的内容也会变化。 char c1[100] = \"hello world!\"; string s1 = \"welcome to China!\"; char c2[100] = \"hi\"; const char *s2 = s1.c_str(); cout << s2 << endl; s1 = \"never give up\"; cout << s2 << endl; // 输出：welcome to China! // never give up 如果执行完c_str()函数后程序想一直都能使用其返回的内容，最后将该 数组内容拷贝一份。 使用数组初始化 vector 对象 不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用 vector 对象初始化数组。但是允许使用数组来初始化 vector 对象。 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr), end(int_arr)); 练习 练习3.41 ：编写一个程序，用整型数组初始化一个 vector 对象。 char c1[] = \"hello world!\"; vector<char> cvect(begin(c1), end(c1)); for (auto c : cvect) { cout << c << endl; } 练习3.42 ：编写一段程序，将含有整数元素的 vector 对象拷贝给一个数组。 vector<int> cvect = { 1, 3, 4, 5, 6,7,8 }; int arr[7]; for(int i = 0; i < 7; i++) { arr[i] = cvect[i]; } for (auto i : arr) { cout << i << endl; }"
  },
  "Languages/Chapter3/3.6.html": {
    "href": "Languages/Chapter3/3.6.html",
    "title": "3.6 多维数组",
    "keywords": "3.6 多维数组 ​ 可以理解多维数组为数组的数组，就是一个数组的每个元素就是一个数组。 int a[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组 // 大小为10的数组，它的每个元素都是大小为20道德数组 // 这些数组的元素是含有30个整数的数组 int arr[10][20][30] = {0}; 多维数组的初始化 int ia[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} } // 等价于 int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; // ia[0][0] = 0; ia[0][1] = 1; ia[0][2] = 2; ia[0][3] = 3; // ia[1][0] = 4; ia[1][1] = 5; ia[1][2] = 6; ia[1][3] = 7; // ia[2][0] = 8; ia[2][1] = 9; ia[2][2] = 10; ia[2][3] = 11; // 显示初始化每行的首元素。 int ia[3][4] = {{0},{4},{8}}; // 等价于 // ia[0][0] = 0; ia[0][1] = 0; ia[0][2] = 0; ia[0][3] = 0; // ia[1][0] = 4; ia[1][1] = 0; ia[1][2] = 0; ia[1][3] = 0; // ia[2][0] = 8; ia[2][1] = 0; ia[2][2] = 0; ia[2][3] = 0; // 显示化初始化第一行，其他元素执行值初始化 int ix[3][4] = {0,3,6,9} // 等价于 // ia[0][0] = 0; ia[0][1] = 3; ia[0][2] = 6; ia[0][3] = 9; // ia[1][0] = 0; ia[1][1] = 0; ia[1][2] = 0; ia[1][3] = 0; // ia[2][0] = 0; ia[2][1] = 0; ia[2][2] = 0; ia[2][3] = 0; 多维数组的下标引用 可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。 int a[3][4]; int arr[10][20][30] = {0}; a[2][3] = arr[0][0][0]; int (&row)[4] = ia[1]; // 把row绑定到ia的第二个元素数组上，即row指向a[1]地址 使用范围 for 语句处理多维数组 size_t cnt = 0; for(auto &row : ia) { for(auto &col:row) { col = cnt++; } } 使用范围 for 语句处理多维数组，除了最内层的循坏外，其他所以循坏的控制变量都应该是引用类型。 指针和多维数组 ​ 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 int ia[3][4]; int (*p)[4] = ia; // p 指向含有4个元素的数组 p = &ia[2]; // p 指向ia的尾元素 int *p[4]; // 整型数组 int (*p)[4]; // 指向含有4个整数的数组 可以使用auto或者decltype去声明变量，避免在数组前面加上一个指针类型。 for(auto p = ia; p != ia + 3; ++p) { for(auto q = *p; q != *p + 4; ++q) { cout << *q << ' '; } cout << endl; } 使用begin和end: for(auto p = begin(ia); p != end(ia); ++p) { for(auto q = begin(*p); q != end(*p); ++q) { cout << *q << ' '; } cout << endl; } 类型别名简化多维数组的指针 using int_array = int[4]; // 新标准下的类型别名声明，参考2.5.1节 typedef intg int_array[4]; // 等价的typedef 声明。参见2.5.1节 for(int_array *p = ia; p != ia + 3; ++p) { for(int *q = *p; q != *p + 4; ++q) { cout << *q << ' '; } cout << endl; }"
  },
  "Languages/Chapter4/4.1.html": {
    "href": "Languages/Chapter4/4.1.html",
    "title": "4.1 基础",
    "keywords": "4.1 基础 ​ 表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。 4.1.1 基本概念 ​ C++定义了一元运算符和二元运算符。作用于一个运算对象的运算符是一元运算符，如取地址 & 何解引用 * ；作用于两个运算对象的运算符是二元运算符，如相等 == 和乘法 * ； ?: 是三元运算符。 组合运算符和运算对象 ​ 一条语句含有多个运算符，需要了解运算符的优先级、结合律以及运算对象的求值顺序。比如： 5 + 10 * 20 / 2 这个表达式并不是从左到右计算的，而是先计算 10 * 20 ，得200，原表达式等价于 5 + 200 / 2 ，再计算 200 / 2 ，得 100，等价于 5 + 100 ，结果为 105。 运算对象转换 ​ 通常来说，二元运算符左右两边的对象要求是同类型的，但是运算对象常常由一种类型转换成另外一种类型。比如加法+左右两边可以是int和double相加。 重载运算符 ​ C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。这种自定义的过程事实上是为已存在的运算符赋予了另外的含义，故称重载运算符。 ​ 使用重载运算符时，运算对象的类型和返回值，是由运算符定义的；但是运算对象的个数、运算符的优先级和结合律是无法改变的。 左值和右值 ​ 表达式要么左值要么右值。左值可以位于赋值语句的左侧，右值不可以。 ​ 当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份。 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。 内置解引用运算符、下标运算符、迭代器解引用运算符、string 和 vector的下标运算符的求值结果都是左值。 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。 4.1.2 优先级和结合律 ​ 在复合表达式中，优先级和结合律决定了运算对象组合的方式。但是表达式中的括号无视优先级和结合律。"
  },
  "Languages/Chapter5/5.1.html": {
    "href": "Languages/Chapter5/5.1.html",
    "title": "5.1 简单语句",
    "keywords": "5.1 简单语句 ​ C++ 语言中大多数语句都以分号结束，一个表达式，末尾加上分号就变成了表达式语句。表达式语句的作用是执行表达式并丢弃掉执行结果，所以需要一个变量来存储执行结果。 ival + 5; // 什么也不做 cout << ival; // 打印ival值 ret = ival + 5; 将ival + 5的结果保存到ret中。 空语句 只有一个分号，表示什么也不执行。 多余的分号有可能导致程序编译不通过或者循环体漏判。 while(iter != svec.end()); // 循环体语句执行的是一个空语句，而并非++iter;语句 ++iter; 复合语句 ​ 复合语句指用花括号括起来的语句和声明的序列，复合语句也被称作块。一个块就是一个域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。 for (int i = 0; i < 10; i++) { int temp = 0; temp = i * i + 9; cout << temp << \" \"; } temp = 100; //错误，temp是在块中定义的，出了块，temp就失效了，需要重新定义。"
  },
  "Languages/Chapter5/5.2.html": {
    "href": "Languages/Chapter5/5.2.html",
    "title": "5.2 语句作用域",
    "keywords": "5.2 语句作用域 ​ 可以在 if、switch、while 和 for 语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了。 while(int i = get_num()) // 每次迭代时创建并初始化变量i cout << i << endl; i = 0; // 错误，在循环外部无法访问i ​ 如果外部代码也要访问变量，则变量必须定义在语句的外部。 auto beg = v.begin(); while(beg != v.end() && *beg >= 0) ++beg; if(beg == v.end()) // 此时我们知道v中的所有元素都大于等于0"
  },
  "Languages/Chapter5/5.3.html": {
    "href": "Languages/Chapter5/5.3.html",
    "title": "5.3 条件语句",
    "keywords": "5.3 条件语句 C++ 语言提供了两种按条件执行的语句。一种是 if 语句，它根据条件决定控制流；另外一种是 switch 语句，它计算一整个表达式的值，然后根据这个值从几条执行路径中选择一条。 5.3.1 if 语句 ​ 判断一个指定的条件是否为真。根据判断结果决定是否执行另外一条语句。 condition 是能够转换为 bool 类型的表达式。如果 condition 为真，则执行 statement。 if (condition) statement; 带 else 的 if 语句。 if (condition) statement; else statement2; // condition 为真，则执行statement；否则执行 statement2 else 搭配 if 遵循就近原则。但是花括号无视else 的就近原则。 if (condition) if(condition2) statement1; else statement2; // else 和 condition2的if搭配。 if (condition) { if(condition2) statement1; } else // 和condition的if搭配 { statement2; } 5.3.2 switch 语句 ​ switch 语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。要注意case 后面加break。 ​ case 标签必须是整型常量表达式。 unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0; char ch; while(cin >> ch) { switch(ch){ case ‘a’: ++aCnt; break; case 'e': ++eCnt; break; case 'i': ++iCnt; break; case 'o': ++oCnt; break; case 'u': ++uCnt; break; default: ; } } char ch = getVal(); int iVal = 42; switch(ch) { case 3.14: // 错误，case标签不是一个整数 case ival: // 错误，case标签不是一个常量 } switch 内部的控制流 ​ 某个 case 标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式中断了这一过程，否则直到switch的结尾处才会停下来。中断过程用 break语句。 int i = 0; switch (i) { case 0: cout << 0 << endl; case 1: cout << 1 << endl; case 2: cout << 2 << endl; case 3: cout << 3 << endl; default: cout << -1 << endl; } // 输出 0 // 1 // 2 // 3 // -1 int i = 0; switch (i) { case 0: cout << 0 << endl; break; case 1: cout << 1 << endl; break; case 2: cout << 2 << endl; break; case 3: cout << 3 << endl; break; default: cout << -1 << endl; break; } // 输出 0"
  },
  "Languages/Chapter5/5.4.html": {
    "href": "Languages/Chapter5/5.4.html",
    "title": "5.4 迭代语句",
    "keywords": "5.4 迭代语句 ​ 迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while 和 for 语句在执行循环体之前检查条件， do while 语句先执行循环体，然后再检查条件。 5.4.1 while 语句 只要条件为真，while 语句就重复执行循环体，它的语法形式是： while (condition) statement; 定义在while条件部分或循环体内的变量每次都经历从创建到销毁的过程。 5.4.2 传统 for 语句 for(init-statement; condition; expression) statement; for 语句头中定义的对象只在 for 循环体内可见。 5.4.3 范围 for 语句 for (declaration : expression) statement; expression 表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者 vector 或 string等类型的对象。因为这些类型能够返回迭代器的begin和end成员。 declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。 5.4.4 do while 语句 ​ do while 语句是先执行循环体后检查条件。不管条件如何，先执行一次循环体。 int i = 5; do{ cout << i << \" \"; }while(i-- > 0); // 输出：5 4 3 2 1 0"
  },
  "Languages/Chapter5/5.5.html": {
    "href": "Languages/Chapter5/5.5.html",
    "title": "5.5 跳转语句",
    "keywords": "5.5 跳转语句 ​ 跳转语句中断当前的执行过程。C++语言提供了4中跳转语句：break、continue、goto 和 return。 5.5.1 break 语句 ​ break 语句负责终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。 5.5.2 continue 语句 ​ continue 语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for、while 和 do while 循环的内部，或者嵌套在此类循环里的语句或块的内部。和 break 不同，continue 只是中断当前循环的一个迭代。 5.5.3 goto 语句 语法形式： goto label; begin: int sz = get_size(); if(sz <= 0) { goto begin; } 大多数公司写的程序是禁止使用goto语句的，因为代码难以维护和理解。"
  },
  "Languages/Chapter5/5.6.html": {
    "href": "Languages/Chapter5/5.6.html",
    "title": "5.6 try 语句块和异常处理",
    "keywords": "5.6 try 语句块和异常处理 ​ 异常是指存在于运行时的返常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理返常行为可能是设计所有系统最难的一部分。 ​ 异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++中，异常处理包括： throw 表达式，异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。 try 语句块。异常处理部分使用try语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个catch子句结束。 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。 5.6.1 throw 表达式 ​ 程序异常检测部分使用 throw 表达式引发一个异常。throw 表达式包含关键字 throw 和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw 表达式后面通常紧跟一个分号，从而构成一条表达式语句。 Sales_item item1, item2; cin >> item1 >> item2; // 首先检查 item1 和 item2 是否表示同一种书籍 if(item1.isbn() == item2.isbn()) { cout << item1 + item2 << endl; return 0; } else{ cerr << \"data must refer to same ISBN\" << endl; return -1; } 应该把对象相加的代码和用户交互（输入数据）的代码分离出来。 // 首先检查 item1 和 item2 是否表示同一种书籍 if(item1.isbn() ！= item2.isbn()) { throw runtime_error(\"data must refer to same ISBN\"); } cout << item1 + item2 <<endl; 5.6.2 try 语句块 通用语法： try{ program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } 5.6.3 标准异常 C++ 标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中： exception 头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息。 stdexcept 头文件定义了几种常用的异常类。 new 头文件中定义了 bad_alloc 异常类型。 type_info 头文件定义了 bad_cast 异常类型。 释义 exception 常见的问题。 runtime_error 只有在运行时才能检测出的问题。 range_error 运行时错误，生成的结果超出了意义的值域范围。 overflow_error 运行时错误，计算上溢。 underflow_error 运行时错误，计算下溢。 logic_error 程序逻辑错误。 domain_error 逻辑错误，参数对应结果值不存在。 invalid_argument 逻辑错误，无效参数。 length_error 逻辑错误，试图创建一个超出该类型最大长度的对象。 out_of_range 逻辑错误，使用一个超出有效范围的值。 只能以默认初始化的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为这些对象提供初始值。 异常类型只定义一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。"
  },
  "Languages/Chapter6/6.1.html": {
    "href": "Languages/Chapter6/6.1.html",
    "title": "6.1 函数基础",
    "keywords": "6.1 函数基础 ​ 函数定义包括：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。形参以逗号隔开，形参列表位于一对括号内。函数执行操作在语句块中，也称为函数体。 写一个阶乘函数 // 1 * 2 * 3 * 4 *5 int fact(int val) { int ret = 1; // 保存结果。 while (val > 1) ret *= val--; return ret; } int main() { int j = fact(5); cout << \"5! is \" << j << endl; return 0; } 形参和实参 ​ 实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。编译器能以任意可行的顺序对实参求值。不一定从左到右或从右到左逐个赋值。 ​ 实参的类型必须与对应的形参类型匹配，这一点与之前的规则一致。函数有几个形参，必须提供相同数量的实参。 函数的返回类型 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 6.1.1 局部对象 名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。 形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域可见，局部变量还会隐藏在外层作用域中同名的其他所有声明中的变量。 在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。 自动对象 ​ 对于普通局部变量对应的对象，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为 自动对象 。当块的执行结束后，块中创建的自动对象的值就变成了未定义的了。 string* getString() { string s = \"this is a string\"; return &s; } int main() { auto p = getString(); cout << *s << endl; return 0; } // 输出空字符串，因为程序控制出了函数体getString之后，s对象已经销毁了 ​ 形参也是一种自动对象。函数开始时为形参申请空间，函数结束，形参对象被销毁。 局部静态变量 ​ 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显示的初始化，它将执行值初始化，内置类型的局部静态变量初始化为0。 size_t count_calls() { static size_t ctr = 0; // 调用结束后，这个值仍然有效 return ++ctr; } int main() { for(size_t i = 0; i != 10; ++i) { cout << count_calls() << \" \"; } return 0; } // 输出：1 2 3 4 5 6 7 8 9 10 6.1.2 函数声明 ​ 函数名字必须在使用之前声明。函数只能定义一次，但是可以声明很多次。可以只声明不定义。函数声明和函数定义的区别就是函数声明无须函数体，用一个分号代替即可。函数声明可以省略形参的名字，但是形参的类型还是要保留的。函数的三要素：返回类型，函数名，形参类型，说明了函数所需的全部信息。函数声明也称作 函数原型 。 size_t count_calls(int, int); int main() { for (size_t i = 0; i != 10; ++i) { cout << count_calls(4, 5) << \" \"; } return 0; } size_t count_calls(int x, int y) { static size_t ctr = 0; // 调用结束后，这个值仍然有效 return ++ctr + x + y; } 在头文件中进行函数声明 ​ 可以将函数声明放在头文件中，就能确保同一函数的所有声明保持一致。如果想改变函数的接口，只需改变一条声明即可。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 6.1.3 分离式编译 分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。 编译和链接多个源文件 假设 fact 函数定义位于一个名为 fact.cc 的文件中，它的声明位于名为 Chapter6.h 的头文件中。显然与其他所有用到 fact 函数一样， fact.cc 应该包含 Chapter6.h 头文件。另外，我们在名为 factMain.cc 的文件中创建 main 函数， main 函数将调用 fact 函数。要生成可执行文件，必须告诉编译器我们用到的代码在哪里。分离式编译的一个好处是，如果修改其中的一个源文件，那么只需要重新编译那个改动了的文件。如果一个项目很大的话，这一机制可以节省编译时间。 ​"
  },
  "Languages/Chapter6/6.2.html": {
    "href": "Languages/Chapter6/6.2.html",
    "title": "6.2 参数传递",
    "keywords": "6.2 参数传递 每次调用函数时都会重新创建它的形参，并用传入的实参是对形参进行初始化。 如果形参是引用类型，它将绑定到对应的实参上面；否则，将实参的值 拷贝 后赋给形参，这意味着要创建新的对象。 当形参是引用类型时，它对应的实参被 引用传递 或者函数被 传引用调用 。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。 ​ 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。这样的实参被 值传递 或者函数被 传值调用 。 6.2.1 传值参数 当初始化一个非引用类型的变量时，初始值被拷贝给变量。在函数内部的改动不会影响函数外部传进来的变量的值。 指针形参 ​ 当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。 void reset(int* ip) { *ip = 0; ip =0; } int main() { int i = 42; reset(&i); cout << \"i = \" << i << endl; // 输出 i = 0 } 练习 练习6.10 ：编写一个函数，使用指针形参交换两个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。 void swap(int* x, int* y); int main(){ int i1 = 10; int i2 = 19; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; swap(&i1, &i2); cout << \" after swap\" << endl; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; return 0; } void swap(int* x, int* y) { int* temp = y; y = x; x = temp; } // 输出： // i1 = 10 // i2 = 19 // after swap // i1 = 10 // i2 = 19 在main函数外，i1指向了值为10的对象object1，i2指向了值为19的对象object2。到了swap函数内部，x原本指向object1，y原本指向object2。执行函数swap后，x指向了object2，y指向object1。控制权回到main函数时，i1还指向object1，i2还指向object2。 void swap(int* x, int* y) { auto temp = *x; *x = *y; *y = temp; } int main() { int i1 = 10; int i2 = 19; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; swap(&i1, &i2); cout << \" after swap\" << endl; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; return 0; } 6.2.2 传引用参数 引用形参允许函数改变一个或多个实参的值。 下面代码中i仅仅只是j的别名。 void reset(int &i) { i = 0; // 实参的值被改变为0 } int main() { int j =42; reset(j); // j的值被改变成为0了 return 0; } 使用引用避免拷贝 ​ 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 ​ 例如，比较两个字符串的长度大小，字符串很长，拷贝创建对象花销大，应该使用引用形参来避免这种情况。 bool isShorter(const string &s1, const string s2) { return s1.size() < s2.size(); } 如果函数无须改变引用形参的值，最好将其声明为常量引用。 使用引用形参返回额外信息 ​ 一个函数只能返回一个值，有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。 // 返回 s 中 c第一次出现的位置索引 // 引用形参 occurs 负责统计 c 出现的总次数 string::size_type find_char(const string &s, char c, string::size_type &occurs) { auto ret = s.size(); occurs = 0; // 设置表示出现次数的形参的值 for(decltype(ret) i = 0; i != s.size(); ++i) { if(s[i] == c) { if(ret == s.size()) ret = i; // 记录c第一次出现的位置 occurs++; // 将出现的次数加1 } } return ret; // 返回出现的次数 } int main() { string s= \"hello world\"; string::size_type occurs = 0; string::size_type firstoccur = 0; firstoccur = find_char(s, 'o', occurs); return 0; } 6.2.3 const 形参和实参 const int ci = 42; // 不能改变ci，const是顶层 int i = ci; // 正确：当拷贝ci时，忽略了它的顶层 const int* const p = &i; // const是顶层的，不能给p赋值 *p = 0; // 正确，通过p改变对象的内容是允许的，现在i变成了0 当实参初始化型参时会忽略掉顶层 const。当形参有顶层 const 时，传给它常量对象或者非常量对象都是可以的。 void fcn(const int i){/*不能对i进行写操作*/} void fcn(int i){/* ... */} // 错误，重读定义了fcn(int) 指针或引用形参与 const ​ 可以使用非常量初始化一个底层 const 对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。 int i = 42; const int *cp = &i; // 正确，但是不能通过 cp 改变 i const int &r = i; // 正确，但是不能通过 r 改变 i const int &r2 = 42; // 正确 int *p = cp; // 错误，p的类型和cp的类型不匹配 int &r3 = r; // 错误，r3的类型和r的类型不匹配 int &r4 = 42; // 错误，不能用字面值初始化一个非常量引用 int i = 0; const int ci = i; string::size_type ctr = 0; reset(&i); // 调用形参类型是int*的reset函数 reset(&ci); // 错误，不能用指向const int对象的指针初始化int* reset(i); // 调用形参类型是int&的reset函数 reset(ci); // 错误，不能把普通引用绑定到const对象ci上 reset(42); // 错误，不能把普通引用绑定到字面值上 reset(ctr); // 错误，类型不匹配，ctr是无符号类型 尽量使用常量引用 如果 find_char 的接口像下面这样定义，在调用时容易出现各种不兼容的情况。 string::size_type find_char(string &s, char c, string::size_type &occurs); 调用： find_char(\"Hello world\", 'o', ctr); 在编译时发生错误。因为 “Hello world” 是字面值常量，而string &s是非常量。 如果被另一个函数包装起来，也不易察觉。 bool is_sentence(const string &s) { // 如果在 s 的末尾有且只有一个句号，则 s 是一个句子 string::size_type ctr = 0; return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1; // 编译错误，s是const string &类型 } 练习 练习6.16 ：下面的这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善。 bool is_empty(string& s){ return s.empty(); } 功能上来说，该函数仅仅是判断形参s是否为空串，没有对s进行写操作而定义形参为可读可写，调用传入的实参只能是string对象，对const string对象而言，不能调用这个函数。 修改： bool is_empty(const string& s){ return s.empty(); } 练习6.17 ：编写一个函数，判断 string 对象中是否含有大写字母。编写另一个函数，把 string 对象全都改写成小写形式。在这两个函数中你使用的形参类型相同吗？为什么？ // 判断 string 对象中是否含有大写字母 bool IsContainUpper(const string& s) { for (auto c : s) { if (isupper(c)) return true; } return false; } // 将参数s全部小写字母改成大写字母 void ToUpper(string& s) { for (auto& c : s) { c = toupper(c); } } 不同，因为 IsContainUpper 函数没有改参数的内容，所以最好定义长引用常量形参， ToUpper 函数改动了形参，所以不能定义为常量。 练习6.18 ：为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。 (a) 名为 compare 的函数，返回布尔值，两个参数都是matrix类的引用。 (b) 名为 change_val 的函数，返回 vector<int> 的迭代器，有两个参数：一个是 int，另一个是 vector<int> 的迭代器。 答：(a)是一个比较两个 matrix 类是否相同，如果相同返回 true；不同，返回 false。 (b) 改变形参迭代器指向的地址的内容为 int 形参类型的值。 练习6.19 ：假定有如下声明，判断哪个调用合法、哪个调用不合法。对于不合法的函数调用，说明原因。 double calc(double); int count(const string&, char); int sum(vector<int>::iterator, vector<int>::iterator, int); vector<int> vec(10); (a) calc(23.4, 55.1); (b) count(\"abcda\", 'a'); (c) calc(66); (d) sum(vec.begin(), vec.end(), 3.8); (a)不合法，参数个数不对。 (b) 合法。 (c)合法。 (d)合法。 练习6.20 ：引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么情况？ 当函数内部不会对形参进行写操作时，应该用常量引用。如果形参应该是常量引用，而我们将其设为了普通引用，可能会编译不通过，因为形参类型不同。 6.2.4 数组形参 ​ 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，不许拷贝数组以及使用数组时会将其转换成指针。因为无法拷贝数组，所以无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 ​ 尽管不能以值传递的方式传递数组，但是可以把形参写成类似数组的形式： void print(const int*); void print(const int[]); void print(const int[10]); // 这里规定了数组大小为10，但是实际传的还是数组首地址，传入的数组容量大于10也是可以的 尽管表现形式不同，但上面的三个函数是等价的。每个函数的唯一形参是 const int* 类型的。当编译器处理对 print 函数的调用时，只检查传入的参数是否是 const int* 类型。 int i = 0, j[2] = {0, 1}; print(&i); // 正确：&i 的类型是int* print(j); // 正确：j转换成 int* 并指向 j[10] 如果传给 print 函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。但是内部使用数组时，要人为确保不会越界。 因为传入函数的数组只有首地址，函数不能通过首地址知道知道数组的大小尺寸，调用者应该提供一些额外的信息。 使用标记指定数组长度 ​ 管理数组实参的一个方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。因为字符串最后一个字符后面跟着一个空字符。 void print(const char *cp) { if(cp) // 若cp不是一个空指针 { while(*cp) // 只要指针所指的字符不是空字符 cout << *cp++; // 输出当前字符并将指针向前移动一个位置 } } 使用标准库规范 管理数组实参的第二个方法是传递指向数组首元素和尾元素的指针。 void print(const int* beg, const int* end) { while(beg != end) cout << *beg++ << endl; } 显示传递一个表示数组大小的形参 第三种方法是专门定义一个表示数组大小的形参。 void print(const int ia[], size_t size) { for(size_t i = 0; i != size; ++i) { cout << ia[i] << endl; } } int j[] = {0, 1}; print(j,end(j) - begin(j)); 数组形参和 const 函数内部如果不改动数组元素时，尽可能使用 const。 数组引用形参 ​ C++ 语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。 void print(int (&arr)[10]) // (&arr) 两边的括号必不可少 { for (auto elem : arr) { cout << elem << endl; } } ​ 因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，只能将函数作用于大小为10的数组。 int i = 0, j[2] = {0, 1}; int k[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; print(&i); // 错误：实参不是含有10个整数的数组 print(j); // 错误，实参不是含有10个整数的数组 print(k); // 正确，实参是含有10个整数的数组 传递多维数组 // matrix 指向数组的元素，该数组的元素是由 10 个整数构成的数组 void print(int (*matrix)[10], int rowSize) { } void print(int arr[][4]) { for (int row = 0; row < 3; row++) { for (int list = 0; list < 4; list++) cout << arr[row][list] << \" \"; cout << endl; } } int main() { int arr[][4] = { {0,1,2,3},{4,5,6,7},{8,9,10,11} }; print(arr); return 0; } 和所有的数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组的第二维的大小都是数组类型的一部分，不能省略。 int *matrix[10]; // 10个指针构成的数组 int (*matrix)[10]; // 指向含有10个整数的数组的指针 也可以使用数组的语法定义函数，此时编译器会忽略掉第一个维度大小，所以最好不要把它包括在形参列表内。 void print(int matrix[][10], int rowSize); 练习 练习 6.21 ：编写一个函数，令其接受两个参数：一个是int型的数，另一个是int指针。函数比较int的值和指针所指的值，返回较大的那个。在该函数中指针的类型应该是什么？ int compare(const int left,const int* right) { return left > *right ? left : *right; } const int* 类型。 练习 6.22 ：编写一个函数，令其交换两个 int 指针。 void swap(int* &left,int* &right) { int* temp = right; right = left; left = temp; } int main() { int left = 10; int right = 11; int* pleft = &left; int* pright = &right; cout << \"before swap\" << endl; cout << \"*pleft = \" << *pleft << endl; cout << \"*pright = \" << *pright << endl; swap(pleft, pright); cout << \"after swap\" << endl; cout << \"*pleft = \" << *pleft << endl; cout << \"*pright = \" << *pright << endl; return 0; } // before swap // *pleft = 10 // *pright = 11 // after swap // *pleft = 11 // *pright = 10 练习 6.23 ：参考本书介绍的几个 print 函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的 i 和 j： int i = 0, j[2] = {0, 1}; 略。 练习 6.24 ：描述下面这个函数的行为。如果代码存在问题，请指出并改正。 void print(const int ia[10]) { for(size_t i = 0; i != 10; ++i) { cout << ia[i] << endl; } } 逐个输出打印数组中的数。 问题，如果传入的数组长度小于10，就出现多余的数。 6.2.5 main: 处理命令行选项 有时需要给main传递实参，一种常见的情况是：有些exe，用命令行启动，但是又需要传递一些额外信息，就需要给main传参数。 int main(int argc, char *argv[]) {} 调用： 1.1.exe prog -d -o ofile data0 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令提供的实参。最后一个指针之后的元素值保证为0。 argv[0] = \"prog\"; argv[1] = \"-d\"; argv[2] = \"-o\"; argv[3] = \"ofile\"; argv[4] = \"data0\"; argv[5] = 0; 6.2.6 含有可变形参的函数 ​ 为了编写能处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为 initializer_list 的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板，在知识点参考16.4节。 ​ C++还有一种特殊的形参类型，省略符，可以用它传递可变数量的实参。省略符一般只用于与C函数交互。 initializer_list 形参 ​ 如果函数的参数数量未知但是全部实参的类型都相同，initializer_list 支持这种做法。它存在于头文件 initializer_list 中。 initializer_list 提供的一些相关的操作： 方法 释义 initializer_list lst; 默认初始化：T类型元素的空列表。 initializer_list lst{a,b,c...}; lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。 lst2(lst) 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst 同 lst2(lst)。 lst.size() 列表中的元素数量。 lst.begin() 返回指向 lst 中首元素的指针。 lst.end() 返回指向 lst 中尾元素的下一位置的指针。 initializer_list 是一种模板类型，定义 intializer_list 对象时，必须说明列表中所含元素的类型。 initializer_list<string> ls; initializer_list<int> li; initializer_list 对象中的元素永远是常量值。 void error_msg(initializer_list<string> il) { for(auto beg = il.begin(); beg != il.end(); ++beg) { cout << *beg << \" \"; } cout << endl; } int main() { /* ... */ // expected 和 actual 是 string 对象 if (expected != actual) { error_msg({\"functionX\", expected, actual}); } else { error_msg({\"functionX\", \"okay\"}); } } ​ 如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内。"
  },
  "Languages/Chapter6/6.3.html": {
    "href": "Languages/Chapter6/6.3.html",
    "title": "6.3 返回类型和 return 语句",
    "keywords": "6.3 返回类型和 return 语句 ​ return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。 return 语句有两种形式。 ① return; ② return expression 6.3.1 无返回值函数 没有返回值的 return 语句只能用在返回类型是 void 的函数中。返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。 6.3.2 有返回值函数 值是如何被返回的 ​ 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 // 如果 ctr 的值大于1，返回 word 的复数形式 string make_plural(size_t ctr, const string& word, const string& ending) { return (ctr > 1) ? word + ending : word; } 该函数的返回类型是 string，意味着返回值将被拷贝到调用点。因此，该函数将返回word的副本或者一个未命名的临时对象，该对象的内容是 word 和 ending 的和。 ​ 同其他引用类型一样，如果函数返回引用，则该引用仅是它所引用对象的一个别名。假定某函数跳出两个 string 形参中较短的那个并返回其引用。 const string& shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 其中形参和返回类型都是 const string 的引用，不管是调用函数还是返回结果都不会真正拷贝 string 对象。 不要返回局部对象的引用或指针 ​ 函数完成后，它所占用的存储空间也随之被释放掉。函数局部变量的引用将指向不再有效的内存区域。 // 严重错误，这个函数试图返回局部对象的引用 const string& manip() { string ret = \"this is a string\"; if(!ret.empty()) return ret; // 错误，返回局部对象的引用！ else return \"Empty\"; // 错误，\"Empty\" 是一个局部临时量 } 返回类类型的函数和调用运算符 auto sz = shorterString(s1, s2).size(); 函数 shorterString 返回的类型是 string，可以直接调用函数并当成一个 string 对象，对其调用 size 函数。 引用返回左值 char& get_val(string& str, string::size_type ix) { return str[ix]; } int main() { string s(\"a value\"); cout << s << endl; // 输出 a value get_val(s, 0) = 'A'; // 将 s[0]的值改为A cout << s << endl; // 输出 A value } 列表初始化返回值 C++11 新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。 vector<string> process() { // ... // expected 和 actual 是 string 对象 if(expected.empty()) return {}; else if(expected == actual) return {\"functionX\", \"okay\"}; // 返回列表初始化的 vector 对象 else return {\"functionX\", expected, actual}; } ​ 如果函数返回的内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。 主函数 main 的返回值 ​ 如果主函数没有 return 语句，则默认隐式返回0。cstdlib 头文件定义了两个预处理变量，可以用这两个变量分别表示成功与失败。 int main() { if(some_failure) { return EXIT_FAILURE; } else{ return EXIT_SUCCESS; } } 递归 ​ 函数调用它自身。main函数不能调用它自身。 int factorial(int val) { if(val > 1) return Factorial(val - 1) * val; else return 1; } 练习 练习 6.32 ：下面函数合法吗？合法说明其功能，不合法，请改正。 int& get(int* array, int index) { return array[index]; } int main(int argc, char *argv[]) { int ia[10]; for (int i = 0; i != 10; ++i) { get(ia, i) = i; } for (auto i : ia) { cout << i << \" \"; } cout << endl; return 0; } 合法。get函数是返回 形参数组array的下标，返回结果可以作为赋值运算符的左值。 练习 6.33 ：编写一个递归函数，输出 vector 对象的内容。 void print(vector<int> &vect, int index) { if (index >= 0) { print(vect, index - 1); cout << vect[index] << endl; } } 练习 6.34 ：如果 factorial 函数的停止条件如下所示，将发生什么情况？ int factorial(int val) { if(val != 0) { return factorial(val - 1) * val; } return 1; } 输入正数就是求整数的阶乘，输入负数，则会陷入无限递归。 练习 6.35 ：在调用 factorial 函数时，为什么我们传入的值是 val -1 而非 val--? val 只是当前函数的局部变量，val--是先将val当前值传入，在进行自减1，显然不可取。要是换做--val是可以的。 6.3.3 返回数组指针 ​ 因为数组不能被拷贝，所以函数不能返回数组，但是可以返回数组的指针或引用。 typedef int arrT[10]; // arrT是一个类型别名，它表示的类型是含有10个整数的数组 using arrT = int[10]; // arrT的等价声明 arrT* func(int i); // func 返回一个指向含有10个整数的数组的指针 声明一个返回数组指针的函数 ​ 要想在声明 func 时不使用类型别名，必须牢记被定义的名字后面数组的维度： int arr[10]; // arr 是一个含有10个整数的数组 int *p1[10]; // p1 是一个含有10个指针的数组 int (*p2)[10]; // p2 是一个指针，它指向含有10个整数的数组 Type (*function(parameter_list))[dimension] Type表示元素的类型，dimension 表示数组的大小。(*function(parameter_list))两端的括号必须存在，如果没有括号，函数的返回类型将是指针的数组。 列子： int (*func(int i))[10]; func(int i) 表示调用func函数时需要一个int类型的实参。 (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作。 (*func(int i))[10] 表示解引用 func 的调用将得到一个大小是10的数组。 int (*func(int i))[10] 表示数组中的元素是 int 类型。 使用尾置返回类型 ​ 在 C++11 新标准中还有一种可以简化上诉 func 声明的方法，就是使用尾置返回类型。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 auto。 // func 接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组 auto func(int i) -> int(*)[10]; 使用 decltype ​ 如果知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。 int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; // 返回一个指针，该指针指向含有5个整数的数组 decltype(odd)* arrPtr(int i) { return (i % 2) ? &odd : &even; // 返回一个指向数组的指针。 } ​ arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。 decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示arrPtr 返回指针还必须在函数声明时加一个 * 符号。 练习 练习 6.36 ：编写一个函数的声明，使其返回数组的引用并且该数组包含10个string对象。不要使用位置返回类型、decltyoe 或者类型别名。 string (&func())[10]; string arr[10] = { \"q\",\"w\",\"e\",\"r\",\"t\",\"y\",\"u\",\"i\",\"o\",\"2\" }; int main(int argc, char *argv[]) { for (auto s : func()) { cout << s << endl; } return 0; } string(&func())[10] { return arr; // TODO: 在此处插入 return 语句 } 练习 6.37 ：为上一题的函数 再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。 类型别名： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; using arrT = int[10]; arrT* func() { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for(int i =0; i < 10; i++) cout << (*a)[i] << endl; return 0; } 尾置返回类型： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; auto func() -> int(*)[10] { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for (int i = 0; i < 10; i++) cout << (*a)[i] << endl; return 0; } decltype 关键字： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; decltype(arr)* func() { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for (int i = 0; i < 10; i++) cout << (*a)[i] << endl; return 0; } 练习 6.38 ：修改 arrPtr 函数，使其返回数组的引用。 int odd[] = { 1, 3, 5, 7, 9 }; int even[] = { 0, 2, 4, 6, 8 }; // 返回一个指针，该指针指向含有5个整数的数组 decltype(odd)& arrPtr(int i) { return (i % 2) ? odd : even; // 返回一个指向数组的指针。 } int main(int argc, char* argv[]) { cout << arrPtr(2)[4] << endl; return 0; }"
  },
  "Languages/Chapter6/6.4.html": {
    "href": "Languages/Chapter6/6.4.html",
    "title": "6.4 函数重载",
    "keywords": "6.4 函数重载 ​ 同一作用域内的几个函数名字相同但是形参列表不同，称之为重载函数。 void print(const char *cp); void print(const int *beg, const int *end); void print(const int ia[], size_t size); 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字，记名字的负担。当函数调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。 main 函数不能重载。 定义重载函数 ​ 有一种典型的数据块应用，需要创建几个不同的函数分别根据名字、电话、账户号码等信息查找记录。 Record lookup(const Acount&); Record lookup(const Phone&); Record lookup(const Name&); Acount acct; Phone phone; Record r1 = lookup(acct); // 调用接受Acount 的版本 Record r2 = lookup(phone); // 调用接受phone的版本 对于重载函数来说，它们应该在形参数量或者形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。 判断两个形参的类型是否相异 Record lookup(const Account& acct); Record lookup(const Account&); // 省略了形参的名字 typedef Phone Telno; Record lookup(const Phone&); Record lookup(const Telno&); 在第一对声明中，第一个函数给它的形参起了名字，第二个函数没有。形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容。 ​ 第二对声明看起来类型不同，但事实上Telno不是一种新类型，它只是 Phone 的别名而已。类型别名为已存在的类型提供另外一个名字，它并不是创建新类型。所以第二对中两个形参的区别仅在于一个使用类型原来的名字，另外一个使用它的别名，从本质上来说它们没什么不同。 重载和 const 形参 顶层 const 不影响传入函数的对象。也就是说一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来。 Record lookup(Phone); Record lookup(const Phone); // 重复声明了Record lookup(Phone) Record lookup(phone*); Record lookup(Phone* const); // 重复声明了Record lookup(phone*); 如果形参是某种类型的指针和引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。 Record lookup(Account&); // 函数作用于Account的引用 Record lookup(const Account&); // 新函数，作用于常量引用 Record lookup(Account*); // 新函数，作用于指向Account的指针 Record lookup(const Account*); // 新函数，作用于指向常量的指针 编译器可以通过实参是否是常量来推断应该调用哪个函数。因为 const 不能转换成其他类型，所以我们只能把 const 对象（或指向 const 的指针）传递给 const 形参。相反，因为非常量可以转换成 const，所以上面的 4个函数都能作用于非常量对象的指针。当我们传递一个非常量对象或指针非常量对象的指针时，编译器会优先选用非常量版本的函数。 const_cast 和重载 const string &shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 函数的参数和返回类型都是 const string 的引用。可以对两个非常量的 string 实参调用这个函数，但返回的结果仍然是 const string 的引用。因此我们需要一种新的 shorterString 函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用 const_cast 可以做到这点。 string& shorterString(string &s1, string& s2) { auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2)); return const_cast<string&>(r); } 这样做有什么好处？ // 如果没有第二个函数shorterString，即使是非常量参数传入之后，返回的也是一个常量的对象引用，不能改变其返回对象的内容。 // 下面的编码就编译不通过 // 有了第二个函数，下面编码顺利通过，对shorterString调用传入的是常量参数，就自动找到第一个shorterString函数，非常量就找到第二个函数。 int main(int argc, char* argv[]) { string s1 = \"this is a string1\"; string s2 = \"this is another string2\"; string& s = shorterString(s1, s2); s = \"hello\"; cout << s1 << endl; return 0; } // 输出： hello 调用重载的函数 函数匹配 是一个过程，在该过程中函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。编译器首先 将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。 大多数情况下很好区分某一次调用的是哪一个具体函数，但是当重载函数的参数数量和参数类型可以相互转换时，这时候就不容易区分了。因此调用重载函数有三种可能结果： 编译器找到一个与实参 最佳匹配 的函数，并生成 调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的报错。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用。 6.4.1 重载与作用域 一般来说，将函数声明至于局部作用域内不是一个明智的选择。 如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。 string read(); void print(const string&); void print(double); // 重载了print void fooBar(int ival) { bool read = false; // 隐藏了read函数，不好的习惯 string s = read(); // 错误，read是一个布尔值 void print(int); // 新作用域，隐藏了之前的print print(\"Value: \"); // 错误，print(const string&)被隐藏掉了 print(ival); // 正确，当前print(int)可见 print(3.14); // 正确，调用了print(int);print(double)被隐藏了 } 当调用 print 函数时，编译器首先寻找对该函数名的声明，找到的是接受 int 值的那个局部声明。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。剩下的工作就是检查函数调用是否有效了。"
  },
  "Languages/Chapter6/6.5.html": {
    "href": "Languages/Chapter6/6.5.html",
    "title": "6.5 特殊用途语言特性",
    "keywords": "6.5 特殊用途语言特性 6.5.1 默认实参 我们编写函数声明时，某些参数在调用时大多时候都是传入同一个值，但是也有特殊时候传入不同值，这个时候默认参数就起到一个作用。默认参数使得函数在调用时，可以接受默认参数值或者用户指定的值。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。一个某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用默认实参调用函数 如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。 默认实参声明 对于函数的声明来说，一般将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参之恩能够被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 string screen(int len, int wid, char x= ' ') string screen(int len, int wid, char x= '*') // 错误，重复声明 string screen(int len = 24, int wid = 95, char x) // 正确 默认实参初始值 局部变量不能作为默认实参。只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。 // wd、def 和 ht 的声明必须出现在函数之外 sz wd = 80; char def = ' '; sz ht(); string screen(sz = ht(), sz = wd, char def); string window = screen(); // 调用screen(ht(), 80, ' ') 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： void f2() { def = \"*\"; // 改变默认实参的值 sz wd = 100; // 隐藏了外层定义的wd，但是不影响screen调用的默认wd还是80 window = screen(); // 调用 screen(ht(), 80, '*') } 6.5.2 内联函数和 constexpr 函数 shorterString 函数的功能是比较两个 string 形参的长度并返回长度较小的 string 的引用。把这种规模较小得得得操作定义成函数有很多好处： 易于阅读和理解函数执行的功能。 使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行。 如果需要修改计算过程，只需要在函数定义的地方修改，而不用在每个使用这样的功能地方做修改。 函数可以被其他应用重复利用，省去重新编写代码的代价。 但是调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含一系列的工作。调用前要先保存寄存器，并在返回时恢复；此外可能要进行参数拷贝赋值等。 内联函数可避免函数调用的开销 将函数指定成内联函数，通常就是将它在每个调用点上“内联地”展开。 // 内联版本：寻找两个 string 对象中较短的那个 shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 在某处使用了内联函数。 cout << shorterString(s1, s2) << endl; 实际上编译器在编译过程中将代码等价于如下： cout << (s1.size() <= s2.size() ? s1 : s2) << endl; 内联说明只是向编译器发出的一个请求，编译器可以选择忽略请求。也就是说，是否在调用点直接代码展开，取决于编译器。 内联机制用于优化规模小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。 constexpr 函数 ​ constexpr 函数 是指能用于常量表达式的函数。定义 constexpr 函数的方法与其他函数类型，不过要遵循约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体重必须有且只有一句 return 语句。 constexpr int new_sz() {return 42;} constexpr int foo = new_sz(); // 正确：foo是一个常量表达式 把 new_sz 定义成无参数的 constexpr 函数。因为编译器能在程序编译时验证 new_sz 函数返回的是常量表达式，所有可以用 new_sz 函数初始化 constexpr 类型的变量 foo。 执行该初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开， constexpr 函数被隐式地指定为内联函数。 ​ constepxr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。 ​ 允许 constexpr 函数的返回值并非一个常量。 // 如果arg是常量表示式，则scale(arg)也是常量表达式 constexpr size_t scale(size_t cnt) {return new_sz() * cnt;} 当 scale 的实参是常量表达式时，它的返回值也是常量表达式；反之则不然。 int arr[scale(2)]; // 正确，scale(2)是常量表达式 int i = 2; // i 不是常量表达式 int a2[scale(i)]; // 错误，scale(2)不是常量表达式 size_t x = scale(2); // 正确。 如果用一个非常量表达式调用 scale 函数；比如 int 类型的对象 i，则返回值是个非常量表达式。当把scale函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符号要求。如果恰好不是常量表达式，编译器将发出错误信息。 constexpr 函数不一定返回常量表达式。 把内联函数和 constexpr 函数放在头文件内 和其他函数不一样，内联函数和 constexpr 函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。 6.5.3 调试帮助 ​ 为了有选择地执行调试代码，程序可以包含一些用于调试代码，这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert 和 NDEBUG。 assert 预处理宏 assert 是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。 assert(expr); 首先对 expr 求值，如果表达式为假，assert 输出信息并终止程序的执行。如果表达式为真，assert 什么也不做。 ​ assert 宏定义在 cassert 头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理器名字而无须提供 using 声明。使用时不需要加域说明，即std::assert，也不用为 assert 提供 using 声明。 ​ 和预处理变量一样，宏名字在程序内必须唯一。含有 cassert 头文件的程序不能再定义名为 assert 的变量、函数或者其他实体。assert 宏常用于检查 “不能发生” 的条件。 assert(word.size() > threshold); NDEBUG 预处理变量 ​ assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 将执行运行时检查。 ​ 定义 NDEBUG 能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。assert 应该仅用于验证那些确实不可能发生的事情。可以把 assert 当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。 ​ 除了用于 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef 和 #ednif 之间的代码；如果定义了 NDEBUG，这些代码将被忽略掉。 现在的vs2019编译器：Release 版本是 NDEBUG 无效，assert 无效。debug 版本就是有效的。 void print(const int ia[], size_t size) { #ifndef NDEBUG // __func__是编译器定义的一个局部静态变量，用于存放函数的名字 cerr << __func__ << \": array size is \" << size << endl; #endif // ... } C++ 预处理器还定义了4个对于程序调试很有用的名字 变量名字 释义 __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 if(word.size() < threshold) cerr << \"Error\" << __FILE__ << \" : in function \" << __func__ << \" at line \" << __LINE__ << endl << \" Compiled on \" << __DATE__ << \" at \" << __TIME__ << endl << \" Word read was \\\"\" << word << \"\\\": Length too short\" << endl;"
  },
  "Languages/Chapter6/6.6.html": {
    "href": "Languages/Chapter6/6.6.html",
    "title": "6.6 函数匹配",
    "keywords": "6.6 函数匹配 void f(); void f(int); void f(int, int); void f(double, double = 3.14); f(5.6); // 调用 void f(double, double); 当我们调用函数时，需要确定调用的是哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，就不容易确定到底是调用哪个重载函数了。 确定候选函数和可行函数 ​ 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为 候选函数 。候选函数具备两个特征：一是被调用的函数同名，而是其声明在调用点可见。 ​ 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 可行函数 。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 ​ 在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。 寻找最佳匹配 ​ 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。 6.6.1 实参类型转换 ​ 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型。 想实参添加顶层 const 或从实参中删除顶层 const。 通过 const 转换实现的匹配。 通过类型提升实现的匹配。 通过算术类型转换或指针转换实现的匹配。 通过类类型转换实现的匹配。 需要类型提升和算术类型转换的匹配 ​ 分析函数调用前，应该知道小整型一般都会提升到 int 类型或更大的整数类型。假设有两个函数，一个接受 int、另一个接受 short，则只有当调用提供的是 short 类型的值时，才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int类型；此时 short 版本反而会导致类型转换。 void ff(int); void ff(short); ff('a'); // char 提升成int；调用ff(int) ​ 所有算术类型转换的级别都一样。列如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高。 void mainp(long); void mainp(float); mainp(3.14); // 错误，二义性使用 函数匹配和 const 实参 ​ 如果重载函数的区别在于它们的引用类型的形参是否引用了 const，或者指针类型的形参是否指向 const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。 Record lookup(Account&); Record lookup(const Account&); const Account a; Account b; lookup(a); // 调用 lookup(const Account&) lookup(b); // 调用 lookup(Account&);"
  },
  "Languages/Chapter6/6.7.html": {
    "href": "Languages/Chapter6/6.7.html",
    "title": "6.7 函数指针",
    "keywords": "6.7 函数指针 ​ 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 // 比较两个 string 对象的长度 bool lengthCompare(const string&, const tring&); 该函数的类型是 bool(const string&, const string&)。要声明一个指向该函数的指针，只需要用指针替换函数名即可。 // pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型 bool (*pf)(const string&, const string&); // 未初始化 *pf的两端括号必不可少。不然就变成了声明一个返回 bool* 类型的函数 pf。 使用函数指针 pf = lengthCompare; // pf 指向名为 lengthCompare的函数 pf = &lengthCompare; // 等价语句，取地址符是可选的 可以直接使用指向函数的指针调用函数，无需提前解引用指针。 bool b1 = pf(\"hello\", \"goodbye\"); // 调用 lengthCompare 函数 bool b2 = (*pf)(\"hello\", \"goodbye\"); // 一个等价的调用 bool b3 = lengthCompare(\"hello\", \"goodbye\"); // 另一个等价的调用 在指向不同函数类型的指针间不存在转换规则。可以为函数指针赋 nullptr 或值为0的整型常量表达式，表示该指针没有指向任何一个函数： string::size_type sumLength(const string&, const string&); bool cstringCompare(const char*, const char*); pf = 0; // 正确，pf不指向任何函数 pf = sumLength; // 错误，返回类型不匹配 pf = cstringCompare; // 错误，形参类型不匹配 pf = lengthCompare; // 正确，函数和指针的类型精确匹配 重载函数的指针 ​ 当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针 void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned int) 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配 void (*pf2)(int) = ff; // 错误，没有任何一个 ff 与该形参列表匹配 double (*pf3)(int*) = ff; // 错误，ff 和 pf3的返回类型不匹配 函数指针形参 ​ 虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用： void useBigger(const string& s1, const string& s2, bool pf(const string&, const string&)); // 等价声明 void useBigger(const string& s1, const string& s2, bool (*pf)(const string&, const string&)); 可以直接把函数作为实参使用，此时它会自动转换成指针： // 自动将函数lengthCompare 转换成指向该函数的指针 useBigger(s1, s2, lengthCompare); 可以使用 decltype 关键字使用函数指针的代码： // Func 和 Func2 是函数类型 typedef bool Func(const string&, const string&); typedef decltype(lengthCompare) Func2; // FuncP 和 FuncP2是指向函数的指针 typedef bool (*FuncP)(const string&, const string&); typedef decltype(lengthCompare) *FuncP2; // 等价的类型 decltype 返回函数类型，此时不会将函数类型自动转换成指针类型。因为 decltype 的结果是函数类型，所以只有在结果前面加上*才能得到指针。 // useBigger 的等价声明，其中使用了类型别名 void useBigger(const string&, const string&, Func); void useBigger(const string&, const string&, funcP2); 这两个声明语句声明的是同一个函数，第一条语句中，编译器自动地将 Func 表示的函数类型转换成指针。 返回指向函数的指针 虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。 // 使用类型别名 using F = int(int*, int); // F是函数类型，不是指针 using PF = int(*)(int*, int); // PF 是指针类型 其中我们使用类型别名将 F 定义成函数类型，将 PF 定义成指向函数类型的指针。必须时刻注意，和函数类型的形参不一样，返回类型不会自动地转换成指针。必须显示地将返回类型指定为指针： PF f1(int); // 正确：PF 是指向函数的指针，f1 返回指向函数的指针 F f1(int); // 错误，F是函数类型，f1 不能返回一个函数 F *f1(int); // 正确，显示地指定返回类型是指向函数的指针 也能用下面的形式直接声明 f1： int (*f1(int))(int*, int); 按照由内向外的顺序阅读这条代码：f1有形参列表，f1是个函数；f1前面有 *，f1返回一个指针；指针的类型本身也包含形参列表，指针指向函数，该函数的返回类型是 int。 也可以使用尾置返回类型的方式声明一个返回函数指针的函数。 auto f1(int) -> int(*)(int*, int); 将 auto 和 decltype 用于函数指针类型 ​ 如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程。 string::size_type sumLength(const string&, const string&); string::size_type largerLength(const string&, const string&); // 根据形参的取值，getFunc 函数返回指向sumLength 或者 largerLength的指针 decltype(sumLength)* getFunc(const string&);"
  },
  "Languages/Chapter7/7.1.html": {
    "href": "Languages/Chapter7/7.1.html",
    "title": "7.1 定义抽象数据类型",
    "keywords": "7.1 定义抽象数据类型 ​ 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 ​ 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。 ​ 类要想实现数据抽象和封装，需要定义一个抽象数据类型。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。 7.1.1 设计 Sales_data 类 Sales_data 的接口应该包含以下操作： 一个 isbn 成员函数，用于返回对象的 isbn 编号。 一个 combine 成员函数，用于将一个 Sales_data 对象加到另一个对象上。 一个名为 add 的函数，执行两个 Sales_data 对象的加法。 一个 read 函数，将数据从 istream 读入到 Sales_data 对象中。 一个 print 函数，将 Sales_data 对象的值输出到 ostream。 struct Sales_data{ std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } // 非成员接口 Sales_data add(const Sales_data&, const Sales_data&); std::ostream &print(std::ostream&, const Sales_data&); std::istream &read(std::istream&, Sales_data&); const 成员函数 ​ isbn 函数的另一个关键之处是紧随参数列表之后的 const 关键字，这里，const 的作用是修改隐式 this 指针的类型。修饰之后，意味着不能在该函数内部修改成员变量的内容，该函数内部也不能调用非 const 成员函数。成员函数声明为 const 函数，有助于维护代码的健壮性。const 成员函数，也称为 常量成员函数 。 常量对象、常量对象的引用或者指针只能调用常量成员函数。 类的作用域和成员函数 类本身是一个作用域，所以类内部的成员函数可以访问到成员变量。isbn 定义在 bookno 前面，也能够在访问到 bookno 的原因是编译器首先编译成员的声明，然后才编译成员函数体。 在类的外部定义成员函数 在类的外部定义成员函数时，要求定义的返回类型、参数列表和声明的一致。如果是常量成员函数，定义时也要加上const关键字。而且在类外定义要加上类的名字，这是因为在类外部，可能一个文件里存在多个类，不同的类可能有名字相同的函数。 // 例如 template<class t> inline size_t LinkList<t>::GetLength() { int len = 0; auto current = phead; // 获取头指针 while ( current && ptail != current) { len++; current = current->next; } return len; } 定义一个返回 this 对象的函数 ​ 函数 combine 的设计初衷类似于复合赋值运算符 += ，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数： Sales_data& Sales_data::combine(const Sales_data& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象 } 7.1.3 定义类相关的非成员函数 ​ 这些非成员函数，大多数是用于辅助类，比如对其进行数据输入，打印数据等。把和类相关的非成员函数放到同一个头文件中，这样如果其他文件需要用到这个类，只需引用一个头文件即可。 定义 read 和 print 函数 // 负责读入数据 istream& read(istream& is, Sales_data& item) { double price = 0; is >> item.bookNo >> item.units_sold >> price; item.revenue = price * item.units_sold; return is; } // 负责输出数据 ostream& print(ostream& os, const Sales_data& item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << item.avg_price(); return os; } read 和 print 接受一个 IO 类型的引用参数，这类 IO 类型不能被拷贝，所以用引用；读取和写入会改变流的内容，因此不用 const修饰流参数。 定义 add 函数 // 返回一个两个对象相加后的副本 Sales_data add(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; sum.combine(rhs); return sum; } 7.1.4 构造函数 ​ 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做 构造函数 。构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 ​ 构造函数的名字和类名相同，但是没有返回类型。构造函数也可以重载。构造函数不能被声明成 const。创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正变成常量，所以可以在构造函数中对其写入值。 默认构造函数 ​ 如果没有显式声明一个构造函数的话，那么编译器就会隐式的加上一个默认构造函数，默认构造函数没有实参，并以以下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 某些类不能依赖于构造函数 ​ 一旦定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。 ​ 定义在块中的内置类型或复合类型的对象被默认初始化，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。不然当创建类的对象时可能得到未定义的值。 ​ 如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。 定义 Sales_data 的构造函数 一个 const string&，表示 ISBN 编号；一个 unsigned，表示售出的图书数量；以及一个 double，表示图书的出售价格。 一个 const string&，表示 ISBN 编号；编译器将赋予其他成员默认值； 一个空参数列表。 struct Sales_data{ Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } 构造函数初始值列表 像下面这个构造函数，在参数列表后面加上冒号，紧接着是类成员跟小括号加上参数，这等同于把s赋值给 bookNo，n 赋值给units_sold，p*n 赋值给 revenue。 Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} 有趣的是如果在构造函数内部再给bookno赋值，和参数不同，最终bookno的值到底是和s一样呢，还是和构造函数体中赋值的一样呢？ Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n) { bookNo = \"100101\"; } // 调用Sales_data(\"111111\", 5, 10); // 打印bookNo，得到的结果是100101 // 这样看起来，是先执行构造函数初始值列表赋值，再执行函数体 在类的外部定义构造函数 Sales_data(std::istream& is) { read(is, *this); } 7.1.5 拷贝、赋值和析构 略。"
  },
  "Languages/Chapter7/7.2.html": {
    "href": "Languages/Chapter7/7.2.html",
    "title": "7.2 访问控制与封装",
    "keywords": "7.2 访问控制与封装 在之前的定义中，Sales_data 类内部并没有封装起来，任何外部的 Sales_data 对象（实例化）都可以直接访问内部的数据成员。可以使用 访问说明符 加强类的封装性： 定义在 public 说明符之后的成员在整个程序内可被访问，public 成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问， private 部分封装了类的实现细节。 再定义 Sales_data 类： class Sales_data{ public: Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } class 和 struct 关键字 使用 class 关键字而非 struct 开始类的定义的区别是 struct 的默认访问权限是public，而类的默认访问权限是private。最好是都显示写出关键字来，一个是不耗费太多功夫，二是大家阅读访问。 7.2.1 友元 ​ 如果将 Sales_data 类的数据成员定义成 private，那么 read、print、add等非函数成员也就无法访问类的数据成员。可以用友元来支持类外部的其他类或者函数来访问类内的私有成员。需要增加 friend 关键字。 class Sales_data{ // 友元声明 friend Sales_data add(const Sales_data&, const Sales_data&); friend std::istream& read(std::istream&, Sales_data&); friend std::ostream& print(std::ostream&, const Sales_data&); public: Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } // 返回一个两个对象相加后的副本 Sales_data add(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; sum.combine(rhs); return sum; } // 负责读入数据 istream& read(istream& is, Sales_data& item) { double price = 0; is >> item.bookNo >> item.units_sold >> price; item.revenue = price * item.units_sold; return is; } // 负责输出数据 ostream& print(ostream& os, const Sales_data& item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << item.avg_price(); return os; } 友元声明只能出现在类的内部。 封装的好处 确保用户代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 一般友元函数放在和类声明的同一个文件，方便管理。"
  },
  "Languages/Chapter7/7.3.html": {
    "href": "Languages/Chapter7/7.3.html",
    "title": "7.3 类的其他特性",
    "keywords": "7.3 类的其他特性 Screen 和 Window_mgr 是一对相互关联的类。 7.3.1 类成员再探 定义一个类型成员 class Screen{ public: typedef std::string::size_type pos; // 类型别名 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; }; 这里在类的内部用了类型别名，意图在于不想让调用这个类的程序员知道类内部使用了 string::size_type 这种类型。 定义类型的成员必须先定义后使用，像下面这样是不可以的： class Screen { // 先使用后定义 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; public: typedef std::string::size_type pos; // 类型别名 }; Screen 类的成员函数 因为 光标位置，宽，高定义成私有成员，用户访问不到，所以需要一个构造函数负责写入数据： class Screen{ public: typedef std::string::size_type pos; // 类型别名 Screen() = default; // cursor 被其他类内初始值值初始化为0 Screen(pos ht, pos wd, char c):height(ht), width(wd), contents(ht * wd, c){} char get() const{ return contents[cursor]; } inline char get(pos ht, pos wd) const; // 显示内联 Screen &move(pos r, pos c); // 能在之后被设为内联 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; }; 这里用到了类内的类型别名，之前说过类本身是一个作用域，那怎么使用类内的别名？ 类外部这样使用：Screen::pos 类内部直接使用：pos 令成员作为内联函数 在类外部用inline关键字修饰函数： inline Screen& Screen::move(pos r, pos c) { pos row = r * width; // 计算行的位置 cursor = row + c; // 在行内将光标移动到指定的列 return *this; // 以左值的形式返回对象 } char Screen::get(pos r, pos c) const { pos row = r * width; // 计算行的位置 return contents[row + c]; // 返回给定列的字符 } 可变数据成员 mutable 某些特殊情况下，希望修改类的某个数据成员，就算在 const 成员函数内，也能修改。一个 可变数据成员 永远不会是 const，即使它是 const 对象的成员。 class Screen{ public: void some_number() const; private: mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改。 } void Screen::some_number() const { ++access_ctr; } 类数据成员的初始值 窗口管理类 class Window_mgr{ private: // C++11新特性 // 这个window_mgr 追踪的Screen // 默认情况下，一个window_mgr 包含一个标准尺寸的空白screen std::vector<Screen> screens{Screen(24, 80, ' ')}; } 7.3.2 返回 *this 的成员函数 class Screen{ public: Screen& set(char); Screen& set(pos, pos, char); // 这里其他函数省略不写 }; inline Screen& Screen::set(char c) { contents[cursor] = c; // 设置当前光标所在位置 return *this; // 将this 对象作为左值返回 } inline Screen& Screen::set(pos r, pos col, char ch) { contents[r*width + col]; return *this; } 通过返回*this，返回引用的函数时左值的，set函数返回的是对象本身而非对象的副本。 myScreen.move(4,0).set('#'); // 等价于 auto a = myScreen.move; // 这里的a指向myScreen a.set('#'); 如果move返回的是 Screen 而不是 Screen&，那么情况大不相同。 myScreen.move(4,0).set('#'); // 等价于 auto temp = myScreen.move(4, 0); // 对返回值进行拷贝 temp.set('#'); // temp并非指向myScreen，而是一个副本 从 const 成员函数返回 *this ​ 如果要添加一个打印函数 display，显然这个函数只读入数据，不会写入数据，所以给理应给 display 函数加上 const 限定符。这个 display 函数返回 *this。则返回的将是一个 const Screen&类型。 inline Screen& Screen::display() const // 错误 { return *this; // TODO: 在此处插入 return 语句 } 如果想上面这样定义，编译器会提示，限定符 const 被丢弃。意思是，你都是一个 const 函数了，返回的 *this，默认是 const 的。 所以应该这样定义： inline const Screen& Screen::display(ostream& os) const { // todo: 输出数据 return *this; } 那就不能够再通过display去左值调用set函数了。 Screen myScreen; myScreen.display(cout).set('*'); // 错误，const左值不能调用set 基于 const 的重载 ​ 通过区分成员函数是否是 const 的，我们可以对其进行重载。 class Screen{ public: Screen& display(std::ostream& os) { do_display(os); return *this; } const Screen& display(std::ostream& os) const { do_display(os); return *this; } private: void do_display(std::ostream& os) const { os << contents; } } 这样，当对象调用display时，就会匹配最佳函数： Screen myScreen(5, 3); const Screen blank(5, 3); myScreen.set('#').display(cout); // 调用非常量函数 blank.display(cout); // 调用常量函数 7.3.3 类类型 struct First{ int memi; int getMem(); }; struct Second{ int memi; int getMem(); }; First obj1; Second sec = obj1; // 错误，obj1 和 sec 的类型不同 即使两个类的成员列表完全一致，但是它们两个是不同的类型。 可以把类名作为类型的名字使用，从而直接指向类类型。也可以把类名跟在关键字 class 或 struct 后面： Sales_data item1; class Sales_data item1; // 等价 Sales_data item1; 7.3.4 友元再探 友元类 Window_mgr 类功能上是管理 Screen 类的，可能某些函数需要访问 Screen 类的私有成员。比如 Window_mgr 有一个 clear 函数。作用是清除 Screen 对象的数据。这时候就需要用到 友元类 。 class screen{ friend class Window_mgr; // Window_mgr 可以访问 Screen 的私有成员 } class Window_mgr{ public: using ScreenIndex = std::vector<Screen>::size_type; void clear(ScreenIndex); private: std::vector<Screen> Screens{Screen(24, 80, ' ')}; } void Window_mgr::Clear(ScreenIndex index) { Screen& s = Screens[index]; s.contents = string(s.height * s.width, ' '); } 友元关系不存在传递性，每个类负责控制自己的友元类或者友元函数。 令成员函数作为友元 除了令整个 Window_mgr 作为友元外，Screen 还能只为 Clear 函数提供访问权限。当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类： class Screen{ // Window_mgr::Clear 必须在Screen类之前被声明； friend void Window_mgr::Clear(ScreenIndex); // ... } 要做到成员函数为友元，代码设计上需要： 首先定义 Window_mgr 类，其中声明 Clear 函数，但是不能定义它。在 Clear 使用Screen 的成员之前必须先声明Screen。 接下来定义 Screen，包括对 Clear 的友元声明。 最后定义 Clear，此时它才可以使用 Screen 的成员。 #pragma once #include<string> #include<vector> class Screen; class Window_mgr1 { public: using ScreenIndex = std::vector<Screen>::size_type; void Clear(ScreenIndex index); public: std::vector<Screen> Screens; }; class Screen { friend void Window_mgr1::Clear(ScreenIndex); public: typedef std::string::size_type pos; // 类型别名 Screen() = default; // cursor 被其他类内初始值值初始化为0 Screen(pos ht, pos wd, char c) :height(ht), width(wd), contents(ht* wd, c) {} char get() const { return contents[cursor]; } inline char get(pos ht, pos wd) const; // 显示内联 Screen& move(pos r, pos c); // 能在之后被设为内联 const Screen& display()const; private: std::string::size_type cursor = 0; // 光标位置 std::string::size_type height = 0; // 高 std::string::size_type width = 0; // 宽 std::string contents; }; inline Screen& Screen::move(pos r, pos c) { pos row = r * width; // 计算行的位置 cursor = row + c; // 在行内将光标移动到指定的列 return *this; // 以左值的形式返回对象 } inline const Screen& Screen::display() const { std::cout << contents << std::endl; return *this; // TODO: 在此处插入 return 语句 } char Screen::get(pos r, pos c) const { pos row = r * width; // 计算行的位置 return contents[row + c]; // 返回给定列的字符 } void Window_mgr1::Clear(ScreenIndex index) { Screen& s = Screens[index]; s.contents = std::string(s.height * s.width, ' '); } 尽管可以这样做，但是会发现，原来 Screens 容器默认有一个数据，现在做不到了，这是因为在Window_mgr之前只是声明了Screen，并没有具体实现Screen带三个参数的构造函数。所以只能忍痛去掉。 函数重载和友元 ​ 尽管重载函数的名字相同，但是它们任然是不同的函数，如果一个类想把一组重载函数声明为它的友元，它需要对这组函数中的每一个分别声明。 友元声明和作用域 ​ 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而友元本身不一定真的声明在当前的作用域中。 ​ 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。 struct x{ friend void f(){/* 友元函数可以定义在类的内部*/} X(){f();} // 错误，f还没有声明 void g(); void h(); } void X::g(){return f();} // 错误，f还没被声明 void f(); void X:h(){return f();} //正确，f已经声明了"
  },
  "Languages/Chapter7/7.4.html": {
    "href": "Languages/Chapter7/7.4.html",
    "title": "7.4 类的作用域",
    "keywords": "7.4 类的作用域 ​ 每个类都会定义类本身的作用域。在类外部，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符访问。对类类型成员则使用作用域运算符访问。 Screen::pos ht = 24, wd = 80; // pos类型是类类型，定义在Screen内部 Screen scr(ht, wd, ' '); Screen *p = &scr; char c = scr.get(); c = p->get(); // 使用成员指针访问运算符 这节知识点，大多数情况下不需要了解，有时间再补充。"
  },
  "Languages/Chapter7/7.5.html": {
    "href": "Languages/Chapter7/7.5.html",
    "title": "7.5 构造函数再探",
    "keywords": "7.5 构造函数再探 7.5.1 构造函数初始值列表 如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。 Sales_data::Sales_data(const string& s, unsigned cnt, double price) { bookNo = s; units_sold = cnt; revenue = cnt * price; } 构造函数的初始值有时必不可少 有的程序员在定义类时，忽略对数据成员初始化的重视程度。如果成员是 const 或者是 引用的，必须要初始化。 class ConstRef{ public: ConstRef(int ii); private: int i; const int ci; int &ri; } 成员 ci 和 ri 必须初始化。如果我们 没有为它们提供构造函数初始值的话将引发错误： // 错误，ci 和 ri 必须被初始化 ConstRef::ConstRef(int ii) { i = ii; ci = ii; // 错误 ri = i; // 错误 } 编译不通过，ConstRef(int ii) 是重载了默认构造函数，而const int 和 int& 的类成员必须用初始值列表来初始化。 // 正确 class ConstRef { public: ConstRef(int ii):i(ii),ci(ii),ri(i){} private: int i; const int ci; int& ri; }; 而且初始化和赋值是两回事，赋值是先初始化在赋值。初始化值比赋值高效。 成员初始化的顺序 class X{ int i; int j; public: X(int val):j(val), i(j){} } 初始值列表的初始化顺序和成员定义的顺序有关，与初始值列表的变量排放顺序无关。比如上面这段代码，就是先初始化i，在初始化j的。显然上面这个代码有问题。 7.5.2 委托构造函数 C++11 新标准支持构造函数初始值的功能，即 委托构造函数 。 class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} // 剩余的构造函数委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s): Sales_data(s, 0, 0){} Sales_data(std::istream& is):Sales_data(){read(is, *this);} } 功能上来说等价于： class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} Sales_data() { Sales_data(\"\", 0, 0); } Sales_data(std::string s){ Sales_data(s, 0, 0); } Sales_data(std::istream& is){ Sales_data(); read(is, *this); } } 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后接着才执行委托者的函数体。 7.5.4 隐式的类类型转换 7.1节中我们为 Sales_data 类定义了一个 combine 函数： Sales_data& Sales_data::combine(const Sales_data& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象 } 如果我们像下面这样调用： string null_book = \"9-999-999999-9\"; item.combine(null_book); // 这样可以通过编译，item1的boolNo就是被 null_book初始化了 Sales_data item1 = null_book; 代码看起来似乎是错误的，因为成员函数 combine接受的是一个 Sales_data 对象的引用，但是实际上缺能够编译通过。这是因为 null_book 作为参数传入后，Sales_data 有一个构造函数带一个 string 类型参数，此时会创建一个 Sales_data 类型的临时变量，作为参数然后传入 combine。 显然也可以用一个输入流作为 “参数” 调用combine： item.combine(std::cin); 特定场景下不希望 Sales_data 类的使用者这样调用 combine，该怎么做？ 抑制构造函数定义的隐式转换 在声明构造函数时加上关键字 explicit : class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} // 剩余的构造函数委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} explicit Sales_data(std::string s): Sales_data(s, 0, 0){} explicit Sales_data(std::istream& is):Sales_data(){read(is, *this);} } 关键字 explicit 只对带一个参数的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，也就不需要为那些多个或0个参数的构造函数指定 explicit。只能在类内声明构造函数时使用关键字，在类外定义时不能重复是用 explicit。 // 错误 explicit Sales_data::Sales_data(istream& is) { read(is, *this); } explicit 只能用于直接初始化，不能用于值初始化： Sales_data item(null_book); // 正确 Sales_data item = null_book; // 错误 为转换显式地使用构造函数 // explicit Sales_data(std::string) item.combine(Sales_data(null_book)); // 正确 item.combine(const_cast<Sales_data>(cin)); // 正确，const_cast 可以解 explicit 7.5.5 聚合类 不推荐使用这个用法。 要求所有的成员是public的，没有定义任何构造函数，没有类内初始值，没有基类，没有 virtual 函数。 struct Data{ int ival; string s; } // 初始化时就可以这样，大括号的参数赋值按成员的顺序来赋值，否则可能出错。 // 大括号的元素个数少于成员变量，剩下的成员变量就变成值初始化。 Data d = {0, \"Anna\"}; 7.5.6 字面值常量类 略。"
  },
  "Languages/Chapter7/7.6.html": {
    "href": "Languages/Chapter7/7.6.html",
    "title": "7.6 类的静态成员",
    "keywords": "7.6 类的静态成员 类的静态成员是指成员只和类相关，不与对象相关，所有该类型的对象共享静态成员。只要改变静态成员，其他对象访问的静态成员都会受到影响。 class Account{ public: void calculate(){ amount += amount * interestRate;} static double rate(){return interestRate;} static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate(); }; 类的静态成员存在于任何对象之外，对象中不包含任何于静态数据成员有关的数据。 静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。静态成员函数不能声明为 const 的，而且我们也不能在 static 函数体内使用 this 指针。 如何使用？ double r = Account::rate(); // 作用域访问运算符访问静态成员 也可以通过类的对象、引用或者指针访问静态成员： Account ac1; Account* ac2; r = ac1.rate(); r = ac2->rate(); 如果在类的外部定义静态成员函数，不能重复 static 关键字。 静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的。也就是说，静态数据成员不是由类的构造函数初始化的。不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员。一个静态数据成员只能定义一次。 double Account::interestRate = initRate(); 静态成员类内初始化 类的静态成员不应该在类内初始化，但是可以为静态成员提供 const 整数类型的类内初始值，要求静态成员必须是字面值常量类型 constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有合适于常量表达式的地方。 class Account{ public: static double rate(){ return interestRate; } static void rate(double); static constexpr int period = 30; // period 是常量 double daily_tbl[period]; } 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 与普通成员的一些不同 class Bar{ public: // ... private: static Bar mem1; Bar*mem2; Bar mem3; // 错误 } 此外，非静态数据成员不能作为默认实参，但是静态数据成员却可以。 class Screen{ public : Screen& clear(char = bkground); private: static const char bkground; }"
  },
  "Languages/Chapter8/8.1.html": {
    "href": "Languages/Chapter8/8.1.html",
    "title": "8.1 IO 类",
    "keywords": "8.1 IO 类 三个关于 IO 类型的头文件： 头文件 类型 iostream istream，wistream 从流读取数据 ostream，wostream 向流写入数据 iostream，wiostream 读写流 fstream ifstream，wifstream 从文件读取数据 ofstream，wofstream 向文件写入数据 fstream，wfstream 读写文件 sstream istringstream，wistringstream 从 string 读取数据 ostringstream，wostringstream 向 string 写入数据 stringstream，wstringstream 读写 string 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵 wchar_t 类型的数据。宽字符版本的类型和函数的名字以一个 w 开始。 支持宽字符 支持普通字符 wcin cin wcout cout wcerr cerr IO对象不可拷贝或赋值 流对象不可拷贝也不能用 const 修饰。一般流都用引用。 8.1.2 流的条件状态 状态或函数 释义 std::ios::iostate iostate是一种机器相关的类型，提供了表达条件状态的完整功能。 std::ios::badbit 指出流已崩溃 std::ios::failbit 指出 IO 操作失败了 std::ios::eofbit 指出流到达了文件结束 std::ios::goodbit 指出流未处于错误状态。此值保证为零 s.eof() 若流 s 的 eofbit 置位，返回 true。 s.fail() 若流 s 的 failbit 或badbit 置位，返回 true s.bad() 若流 s 的 badbit 置位，返回 true s.good() 若流 s 处于有效状态，返回 true s.clear() 若流 s 中所有条件状态复位，将流的状态设置为有效。返回 void 根据给定的 flags 标志位，将流 s 中对应条件状态复位。 flags 的类型为 iostate。返回 void s.clear(flags) 若流 s 中所有条件状态复位，将流的状态设置为有效。返回 void 根据给定的 flags 标志位，将流 s 中对应条件状态复位。 flags 的类型为 iostate。返回 void s.setstate(flags) 根据给定的 flags 标志位，将流 s 中对应条件状态位置位。flags 的类型为 iostate。返回 void s.rdstate() 返回流s 的当前状态，返回值类型为 iostate void test(istream& os, int& i) { os >> i; auto state = os.rdstate(); switch (state) { case std::ios::badbit: cout << \"流崩溃了\" << endl; break; case std::ios::failbit: cout << \"IO 操作失败了\" << endl; break; case std::ios::eofbit: cout << \"流到达文件结尾了\" << endl; break; case std::ios::goodbit: cout << \"流处于正确状态\" << endl; break; default: cout << \"流处于未知状态\" << endl; break; } } int main(int argc, char* argv[]) { int i; test(cin, i); cout << i << endl; return 0; } // 输入：15 // 输出： // 流处于正确状态 // 15 // 输入：Boo // 输出： // IO 操作失败 // 0 如果去看 badbit这几个类型定义的话，长这样： static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0); static constexpr _Iostate eofbit = static_cast<_Iostate>(0x1); static constexpr _Iostate failbit = static_cast<_Iostate>(0x2); static constexpr _Iostate badbit = static_cast<_Iostate>(0x4); 用16进制表示的 0, 1, 2, 4。也就是： 十六进制表示 二进制表示 goodbit 0x0 0000 eofbit 0x1 0001 failbit 0x2 0010 badbit 0x4 1000 这样的好处是给出一个状态，除了goodbit之外，通过相与可以判断一个状态是否包含上面的任一一个。 8.1.3 管理输出缓冲 系统为了提高对设备或文件的操作效率，做了缓冲区，即当执行到某一条输出流代码时，并不一定立即在黑窗体上显示出来。数据真正写到输出设备或文件的场景有： 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。 缓冲区满时，需要刷新缓冲区。 操作符 unitbuf 强制刷新，清空缓冲区；cerr默认设置了unitbuf。 一个输出流可能被关联到另一个流。读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，cin 和 cerr 都关联到 cout。所以读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。 刷新缓冲区 cout << \"hi\" << endl; // 输出 hi 和一个换行，然后刷新缓冲区 cout << \"hi\" << flush; // 输出 hi，然后刷新缓冲区 cout << \"hi\" << ends; // 输出 hi和一个空字符，然后刷新缓冲区 cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都立即刷新，无缓冲 cout <<nonunitbuf; // 回到正常的缓冲方式 程序崩溃时，可能有些测试数据并没有被刷新出来，所以定位bug时记得刷新一些输出缓冲区。"
  },
  "Languages/Chapter8/8.2.html": {
    "href": "Languages/Chapter8/8.2.html",
    "title": "8.2 文件输入输出",
    "keywords": "8.2 文件输入输出 fstream 除了继承自 iostream 的操作外，还有自己的一套： 操作 释义 fstream fstrm 创建一个未绑定的文件流。fstream 是头文件 fstream 中定义的一个类型 fstream fstrm(s); 创建一个 fstream，并打开名为 s 的文件。s 可以是 string 类型，或者是一个指向 C 风格字符串的指针。这些构造函数都是 explicit 的，默认的文件模式 mode 依赖于 fstream 的类型 fstream fstrm(s,mode); 与前一个构造函数类似，但按指定mode打开文件 fstrm.open(s) 打开名为 s 的文件，并将文件与 fstrm绑定。s可以是一个string类型或一个 指向C风格字符串的指针。默认的文件mode依赖于fstream的类型。返回void fstrm.close() 关闭与 fstrm 绑定的文件。返回void fstrm.is_open() 返回一个bool值，指出与 fstrm 关联的文件是否成功打开且尚未关闭。 8.2.1 使用文件流对象 int main(int argc, char* argv[]) { string ifileName = \"D:/OneDrive/桌面/demo/sales_data.txt\"; string ofileName = \"D:/OneDrive/桌面/demo/sales_data_result.txt\"; ifstream ifile(ifileName); ofstream ofile(ofileName); Sales_data total; if (read(ifile, total)) // 读取第一条销售记录 { Sales_data trans; // 保存下一条销售记录的变量 while (read(ifile, trans)) { if (total.isbn() == trans.isbn()) { total.combine(trans); } else { print(ofile, total) << endl; total = trans; // 处理下一本书 } } print(ofile, total) << endl; } else cerr << \"No Data?!\" << endl; return 0; } 因为 fstream 继承 iostream，所以之前写的 read 和 print 函数也是可以用的。 我在输入文件sales_data.txt中写入内容： 978-7-229 9 36.6 978-7-229 130 36.6 978-7-229 100 36.6 273-7-209 100 21.4 971-8-229 9 89.5 971-8-229 11 89.5 运行程序后得到： 978-7-229 239 8747.436.6 273-7-209 100 214021.4 971-8-229 20 179089.5 手工算了下，没错。运行过程中，如果程序打开了输出文件sales_data_result.txt，但是程序没有执行到 print 时异常结束（调试，直接终止程序），sales_data_result.txt文件内容会被清空，要注意这个情况。 成员函数open和close 成员函数 open 打开指定文件。 close 关闭当前流相关联的文件。 open文件后，一般先判断流是否正确打开了文件。 ifstream input; input.open(path1); if(out) // 判断是否正确打开 { // ... } // 如果open失败了，断开流与path1文件的关联 out.close(); out.open(path2); //再打开另一个文件 8.2.2 文件模式 模式 in 以读方式打开 out 以写方式打开 app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO 只可以对 ofstream 或 fstream 对象设定 out 模式。 只可以对 ifstream 或 fstream 对象设定 in 模式。 只有当 out 也被设定时才可以设定 trunc 模式。 只要 trunc 没被设定，就可以设定 app 模式。在 app 模式下，即使没有显式指定 out 模式，文件也总是以输出方式被打开。 默认情况下，即使我们没有指定 trunc，以 out 模式打开的文件也会被截断。为了保留以 out 模式打开的文件的内容，我们必须同时指定 app 模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。 ate 和 binary 模式可用于任何类型的文件流对象，且可以于其他任何文件模式组合使用。"
  },
  "OperatingSystem/Chapter1/1.1.html": {
    "href": "OperatingSystem/Chapter1/1.1.html",
    "title": "1.1 操作系统的基本概念",
    "keywords": "1.1 操作系统的基本概念 1.1.1 操作系统的概念 ​ 计算机系统大致可分为4个部分：硬件、操作系统、应用程序和用户。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。 ​ 硬件如中央处理器、内存、输入/输出设备等，提供基本的计算资源。应用程序如字处理器程序、电子制表软件、编译器、网络浏览器等，规定按何种方式使用这些资源来解决用户的计算问题，操作系统控制和协调各用户的应用程序对硬件的分配与使用。 ​ 综上所述，操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 ​ 操作系统的基本特征包括并发、共享、虚拟和异步。 并发 ​ 并发指两个或多个事件在同一时间间隔内发生的。对计算机来说，并发就是有多个程序在某一段时间里发生了。 ​ 在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，所以看起来是多个程序在“同时运行”。而在每个时刻，单处理机环境下实际仅有一道程序执行，微观上这些程序是交替执行的。操作系统的并发性是通过分时得以实现的。 并行 ​ 并行性指系统具有同时进行运算和操作的特性，同一时刻能完成两种或两种以上的工作。这个特性离不开硬件的支持。 共享 ​ 这里讲的共享就是资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享又分 互斥共享 和 同时访问 。 互斥共享 如打印机，磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不至于混淆，规定在一段时间内只允许一个进程访问该资源。 进程A需要某个资源时，先向系统申请资源，如果这时资源已经被占用，并且进程A对该资源的占用优先级没有高过当前占用的进程，那么就得排队等待该资源。如果资源没被占用，那么进程A就对系统要求锁住该资源，让给A使用，此时进程B向系统申请该资源，并且优先级没有进程A高，那么系统拒接该进程B的申请。像这样的资源称为临界资源或独占资源。 同时访问方式 系统中的一些资源，允许在一段时间内由多个进程“同时”访问。这里说的同时，指宏观上同时，进程之间可能以交替地对该资源进行访问即“分时共享”。像磁盘；一些共享文件，多个进程可读共同一个文件。可以想象，电脑只有一个播音器，但是如果同时开着几个音频软件，在人耳处听到的是，这几个音频软件同时被播放器播放声音了。 虚拟 ​ 虚拟是指把一个物理上的实体变为若干逻辑上的对应物。 test zhongzhenlong 哈希表"
  }
}