{
  "Algorithm/Chapter1/1.1.html": {
    "href": "Algorithm/Chapter1/1.1.html",
    "title": "1.1 简介",
    "keywords": "1.1 简介 1.1.1 基本概念 1. 基本概念 ​ 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。 2. 数据元素 ​ 数据元素是数据的基本单位。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。如下，一条学生的信息就是一个数据元素，一个数据元素是有一个个数据项构成。 3. 数据对象 ​ 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是{±1，±2，...} 4. 数据类型 ​ 数据类型是一个值得集合和定义在此集合上的一组操作的总称。 原子类型。其值不可再分的数据类型。 结构类型。其值可以再分解为若干成分的数据类型。 抽象数据类型。抽象数据组织及其与之相关的操作。 5. 数据结构 ​ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。 ​ 数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。 1.1.2 三要素 数据的逻辑结构 ​ 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。 数据的存储结构 ​ 存储结构是指数据结构在计算机中的表示，即物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。 顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。优点是可以随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。典型代表：数组。 链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。典型代表：链表。 索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是(关键字,地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。此外，增加和删除数据时也要修改索引表，故会消耗大。 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。其有点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销。 数据的运算 ​ 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。"
  },
  "Algorithm/Chapter1/1.2.html": {
    "href": "Algorithm/Chapter1/1.2.html",
    "title": "1.2 算法和算法评价",
    "keywords": "1.2 算法和算法评价 1.2.2 算法效率的度量 描述算法主要通过两个度量：时间复杂度和空间复杂度。 时间复杂度 一个语句在算法中被重复执行的次数 ，也称一个语句的频度。算法的时间复杂度不仅依赖于问题的规模，也和待输入的数据相关。比如在一个仅仅10个数字集合中找出最大的数和在一个含10亿个数字集合中找出最大的数，这是规模对算法时间复杂度的影响；再比如，拥有相同个数的两个集合，它们是数组，但是数组A是个排好序的数组，数组B是个无序的数组，找出最大的数，算法的时间复杂度也不一样。 名称 解释 最坏时间复杂度 指在最坏的情况下，算法的时间复杂度。 平均时间复杂度 所有可能输入实例在等概率出现的情况下，算法的期望运行时间。 最好时间复杂度 指在最好的情况下，算法的时间复杂度。 一般总是考虑最坏时间复杂度，以确保算法的运行时间不会过长。 空间复杂度 ​ 该算法运行过程中所耗费的存储空间。它是问题规模n的函数。一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储空间。若输入数据所占用空间取决于问题本身，和算法无关，则只需分析输入和程序之外的额外空间。 ​ 算法原地工作是指算法所需的辅助空间为常量。"
  },
  "Algorithm/Chapter1/1.3.html": {
    "href": "Algorithm/Chapter1/1.3.html",
    "title": "练习",
    "keywords": "练习 1.以下算法时间复杂度为： void fun(const int n) { int i = 1; while (i <= n) { i = i*2; } } 这里主要是算出 “i = i*2;” 语句的执行次数和n规模之间的关系。 通过计算等比数列求和公式知： 其中x是运行次数。x即为所求的算法复杂度。所以算法复杂度为： 2.求以下算法时间复杂度： x = 2; while(x < n/2) { x=2*x; } 循环语句 x=2*x; 执行次数i和n规模的关系为: 所以算法复杂度为： 3.求整数n的阶乘的算法如下，计算时间复杂度： int fact(int n) { if(n <= 1){ return 1; } return n*fact(n-1); } 这是个递归方法计算n的阶乘。显然一共调用fact函数n次，故其算法时间复杂度为O(n); 4.下列程序段的时间复杂度是？ count = 0; for(k = 1; k <= n;k *= 2) for(j = 1; j <= n; j++) count++; 第一层for循环执行了 次，第二层for循环每次执行n次，故算法时间复杂度为："
  },
  "Algorithm/Chapter2/2.1.html": {
    "href": "Algorithm/Chapter2/2.1.html",
    "title": "2.1 线性表的定义和基本操作",
    "keywords": "2.1 线性表的定义和基本操作 2.1.1 定义 ​ 线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当 n=0 时线性表是个空表。可以理解为一串元素构成的数据结构，因为看起来像一条线一样，所以叫线性表。除表头元素外，每个元素有且仅有一个直接前驱。除表尾元素外，每个元素有且仅有一个直接后继。 线性表的一些特性： 表中元素个数有限。 表中元素具有逻辑上的顺序性，表中元素有其先后次序。 表中元素都是数据元素，每个元素都是单个元素。 表中元素的数据类型都相同，每个元素占用相同大小空间。 2.1.2 线性表的基本操作 方法名 解释 InitList(&L) 初始化列表，构造一个空线性表。 Length(L) 返回表当前拥有的元素个数。 LocateElem(L, e) 按值查找，在表L中查找给定关键字e的元素。 GetElem(L, i) 按位查找，返回L中第i个位置的元素的值，如果不存在，返回失败。 ListInsert(&L, i, e) 插入操作，在表L中第i个位置插入元素e。 ListDelete(&L,i,&e) 删除操作，删除表L中第i个位置的元素，并通过参数e返回已经删除的元素的值。 PrintList(L) 输出操作，按前后顺序输出线性表L的所有元素值。 Empty(L) 判空操作，如果L为空表，返回true，否则返回false。 DestroyList(&L) 销毁操作，销毁线性表，并释放线性表L所占用内存空间。 这里只是给出基本的接口名，具体怎么实现要还要看条件和需求。"
  },
  "Algorithm/Chapter2/2.2.html": {
    "href": "Algorithm/Chapter2/2.2.html",
    "title": "2.2 线性表的顺序表示",
    "keywords": "2.2 线性表的顺序表示 2.2.1 顺序表的定义 线性表的顺序存储叫顺序表。它是一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。特点是表中元素的逻辑顺序与其物理顺序相同。 ​ 每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表中的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。在c++语言中表现为数组。 用c++描述一个顺序表： #include <iostream> // #include \"Sales_item.h\" using namespace std; template<class t> class SqList{ private: t* arr; // 动态分配，当插入溢出时，方便扩容 unsigned int Maxsize; // 最大个数 unsigned int length; // 当前个数 public: SqList(unsigned int size = 1024); ~SqList(); // ... 这里待加入增删改查 }; template<class t> SqList<t>::SqList(unsigned int size) { Maxsize = size; // 顺序表的最小容纳个数为10个 if (Maxsize < 10) { Maxsize = 10; } arr = new t[size]; length = 0; } template<class t> SqList<t>::~SqList() { delete arr; arr = nullptr; } 此处实现采用动态分配数组，是为了应对当插入新的数据时若数组已满，则可以通过动态的扩容，使得插入成功。 顺序表的特点主要是可以随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素，这是因为电脑的硬件设计支持这么做。顺序表的存储密度高，每个结点只存储数据元素。顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素，消耗大。 2.2.2 顺序表基本操作的实现 插入操作 ​ 在顺序表L的第i个位置插入新元素e。如i不合法，则返回false，插入失败。否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，表长+1，返回true。 /// <summary> /// 插入数据 /// </summary> /// <typeparam name=\"t\">类型</typeparam> /// <param name=\"index\">插入位置</param> /// <param name=\"e\">新插入的元素</param> /// <returns>插入成功结果</returns> template<class t> bool SqList<t>::ListInsert(unsigned int index, t e) { if (index < 1 || index > length + 1) // 插入位置超出链表所在位置 { return false; } if (length >= Maxsize) // 当前数组满了，扩容 { Maxsize = Maxsize * 2; // 扩容为原来的两倍 t* temp = arr; arr = new t[Maxsize]; for (unsigned int i = 0; i < length; i++) // 将原数组数据拷贝到新的数组中 { arr[i] = temp[i]; } delete temp; // 删除原数组空间 temp = nullptr; } for (unsigned int j = length; j >= index; j--) { arr[j] = arr[j - 1]; // 数据后移 } arr[index - 1] = e; // 插入新元素 length++; // 表长加一 return true; } 删除操作 删除顺序表L中第i个位置的元素，用引用变量e返回。如i不合法，则返回false，删除失败。否则，将第i+1个元素及其后的所有元素依次往前移动一个位置，表长-1，返回true。 template<class t> bool SqList<t>::ListDelete(unsigned int index, t& e) { if (index<1 && index >length) // 判断index有效性 { return false; } e = arr[index - 1]; // 读取第index个数据元素 for (unsigned int i = index; i < length; i++) // 第index后的数据元素往前移动 { arr[i - 1] = arr[i]; } length--; // 表长减一 return true; } 按值查找 /// <summary> /// 按值查找值等于e的元素的位置 /// </summary> /// <param name=\"e\">待查找值</param> /// <returns>值为e的元素在顺序表中的位置；返回0表示返回失败</returns> template<class t> unsigned int SqList<t>::LocateElem(t e) { for (unsigned int i = 0; i < length; i++) { if (arr[i] == e) { return i + 1; } } return 0; // 返回0表示查找失败 } 按位查找 /// <summary> /// 按位取值 /// </summary> /// <param name=\"index\">第几个元素，输入0和输入超过表长的数将会抛出异常。</param> /// <returns>返回表中第index位数据元素的副本</returns> template<class t> t SqList<t>::GetElem(unsigned int index) { if (index < 1 || index > length + 1) { std::cout << \"out of range in SqList\" << std::endl; throw exception ex; } t e = arr[index - 1]; return e; } 获取表长 template<class t> unsigned int SqList<t>::GetLength() { return length; } 判空 template<class t> bool SqList<t>::Empty() { return length == 0; } 2.2.3 练习题目 题目一 ：倒置数组 设将n(n>1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(0，1，…，p，p+1，n-1)变换为(p，p+1，…，n-1，0，1，…，p-1)。给出算法的基本设计思想。说明算法时间复杂度和空间复杂度。 设计思路： 1）创建一个大小为p的一维数组temp，将从下标从0到p-1的数据元素保存到赋值数组temp中。 2）将R中下标为p到n-1的数据元素左移p个位置。 3）将辅助数组temp中的数据依次拷贝到R中下标为n-p到n-1位置中。 代码以int数组为示例。 /// <summary> /// 在位置pos处倒置 /// </summary> /// <param name=\"arr\">数组地址</param> /// <param name=\"len\">数组长度</param> /// <param name=\"pos\">倒置的位置p</param> void Reverse(int arr[], int len, int pos) { if (pos <= 0 || pos >= len) // 保证 0<p<n return; int* temp = new int[pos]; // 辅助数组 // 将下标0到pos-1的数组元素备份 for (int i = 0; i < pos; i++) { temp[i] = arr[i]; } // 下标 pos 到数组尾部数据左移pos个单位 for (int j = 0; j < len - pos; j++) { arr[j] = arr[pos + j]; } // 将辅助数组的数据拷贝回去 for (int k = 0; k < pos; k++) { arr[len - pos + k] = temp[k]; } delete [] temp; // 释放辅助数组 temp = nullptr; } // 主函数调用 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; Reverse(arr, 10, 6); 时间复杂度为O(n)；空间复杂度为O(p)。 另外一种解法是： 1）先倒置R中下标0到p-1的元素，倒置后序列为：（p-1，…，1,0，p，…，n-1）。 2）倒置R中下标p到n-1的元素，倒置后序列为：（p-1，…，1,0，n-1，…，p）。 3）倒置R中下标0到n-1的元素，倒置后序列为：（p，…，n-1，0，1，…，p-1）。 /// <summary> /// 倒置数组 /// </summary> /// <param name=\"arr\">数组地址</param> /// <param name=\"from\">倒置起始下标</param> /// <param name=\"to\">倒置末尾下标</param> void Reverse2(int arr[], int from, int to) { int count = (to - from + 1) / 2; // 循环次数 for (int i = 0; i < count; i++) { int temp = arr[from + i]; arr[from + i] = arr[to - i]; arr[to - i] = temp; } } // 主函数调用 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; Reverse2(arr, 0, 6-1); Reverse2(arr, 6, 9); Reverse2(arr, 0, 9); 时间复杂度为O(n)；空间复杂度为O(1)。 题目二：中位数 一个长度为L（L≥1）的生序序列S，处在第⌈L/2⌉个位置的数称为S的中位数。列如，若序列S1=(11,13,15,17,19)，则S1中的中位数是15，两个序列的中位数是含它们所有元素的生序序列的中位数。列如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间算法两方面都尽可能高效的算法，找出A和B的中位数。要求：给出算法设计的基本思路。说明算法时间复杂度和空间复杂度。 设计思路： 分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下： ① 若a=b，则a或b即为所求中位数，程序结束。 ②若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等。 ③若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等。 在保留的两个升序序列中，重复过程①②③，直到两个序列中均只有一个元素为止，较小者即为所求的中位数。 int M_Search(int a[], int b[], int len) { int aBegin = 0, aEnd = len - 1, bBegin = 0, bEnd = len - 1; int aMin = (aBegin + aEnd) / 2, bMin = (bBegin + bEnd) / 2; // aMin是a数组的中位数下标，bMin是b数组的中位数下标 while ((aBegin != aEnd || bBegin != bEnd)) { if (a[aMin] < b[bMin]) { if ((aBegin + aEnd) % 2 == 0) { // 元素个数为寄数个 aBegin = aMin; // 舍弃序列A中间点以前部分，保留中间点 bEnd = bMin; // 舍弃序列B中间点后面部分，保留中间点 } else { // 元素个数为偶数个 aBegin = aMin + 1; // 舍弃序列A中间点以前部分及中间点 bEnd = bMin; // 舍弃序列B中间点后面部分且保留中间点 } } else if(a[aMin] > b[bMin]) { if ((bBegin + bEnd) % 2 == 0) // 元素个数为奇数个 { aEnd = aMin; // 舍弃序列A中间点后面部分，保留中间点 bBegin = bMin; // 舍弃序列B中间点以前部分，保留中间点 } else{ aEnd = aMin; // 舍弃序列A中间点后面部分，保留中间点 bBegin = bMin + 1; // 舍弃序列B中间点以前部分，保留中间点 } } else // 中位数相等 { return a[aMin]; } aMin = (aBegin + aEnd) / 2, bMin = (bBegin + bEnd) / 2; // 计算新序列的中位数下标 } return a[aMin] < b[bMin] ? a[aMin] : b[bMin]; // 当保留的序列只剩一个时，返回最小的那个数。 }"
  },
  "Algorithm/Chapter2/2.3.html": {
    "href": "Algorithm/Chapter2/2.3.html",
    "title": "2.3 线性表的链式表示",
    "keywords": "2.3 线性表的链式表示 ​ 顺序表可以随时存取表中的任一一个元素，它的存储位置可以用一个简单直观的公式表示，但是出入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元。不要求逻辑上相邻的元素物理上位置也相邻。因此插入和删除操作不需要移动元素，只需要修改指针。但是查询只能沿着链一个一个查找，查询性能就降低了。 2.3.1 单链表的定义 线性表的链式存储又称单链表。 单链表结点代码结构 template<class t> class LNode { public: t data; // 数据域 LNode<t> *next; // 指针域 public: LNode(t e):data(e), next(nullptr){} }; ​ 单链表可以解决顺序表需要大量连续存储单元的缺点（数组并不需要为其下标开辟存储空间），但是单链表附加指针域，也存在浪费存储空间的缺点。单链表的元素离散分布在存储空间中，是非随机存取的存储结构。不能直接定位某个特定的结点，只能从表头沿着链域一个一个的遍历。 ​ 带头结点：通常用头指针来标识一个链表，如单链表L，头指针为NULL时表示一个空表。为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点，结点的data不存数据。 链表结构 template<class t> class LinkList { private: LNode<t>* phead; // 头指针 LNode<t>* ptail; // 尾指针 public: LinkList(); // 初始化 void Insert(t e); bool Insert(int i, t e); LNode<t>* GetElem(int i); // 按序号查找结点 LNode<t>* LocateElem(t e); // 按值查找结点 bool Delete(int i); // 按序号删除结点 size_t GetLength(); // 求表长 }; template<class t> inline LinkList<t>::LinkList() { // 创建头结点，结点不存内容。 phead = new LNode<t>(); ptail = phead; // 尾指针指向头结点 } 2.3.2 单链表上基本操作的实现 插入操作 /// <summary> /// 尾部插入新的结点 /// </summary> /// <param name=\"e\">数据</param> template<class t> void LinkList<t>::Insert(t e) { // ptail 永远不为空，因为有头结点 ptail = ptail->next; ptail = new LNode<t>(); ptail->data = e; ptail->next = nullptr; } 查找操作 按序号查找结点值 ​ 在单链表中从第一个结点出发，顺着指针 next 域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。 template<class t> inline LNode<t>* LinkList<t>::GetElem(int i) { if (i < 1) // i的值不能小于1 return nullptr; int j = 1; LNode<t>* temp = phead->next; // 获取将头指针的next // 沿着链找到对应位置的结点 while (temp && j < i) { temp = temp->next; j++; } return temp; } 按值查找表结点 ​ 从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该节点的指针；若整个单链表中没有这样的结点，则返回NULL。 template<class t> inline LNode<t>* LinkList<t>::LocateElem(t e) { LNode<t>* temp = phead->next; while (temp && temp != e) { temp = temp->next; } return temp; } 插入新结点 ​ 插入结点操作将值为x的新结点插入到链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第 i-1 个结点，再在其后插入新结点。 /// <summary> /// 按位置插入法。 /// </summary> /// <param name=\"i\">插入的位置</param> /// <param name=\"e\">插入的结点数据</param> /// <returns>true，插入成功；false，插入失败</returns> template<class t> inline bool LinkList<t>::Insert(int i, t e) { if (i < 1) return false; LNode<t>* p = GetElem(i - 1); if (p) return false; LNode<t>* temp = new LNode<t>(); temp->data = e; temp->next = p->next; // 原链表中第i个位置的元素，可能为空，由新元素的next指向 p->next = temp; if (temp->next == nullptr) // temp的next是空指针，则temp是个尾部结点 ptail = temp; } 删除操作 ​ 删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第 i-1 个结点，即被删结点的前驱结点，再将其删除。 template<class t> inline bool LinkList<t>::Delete(int i) { LNode<t>* p = GetElem(i - 1); // 找到第i-1个位置结点 if (p || p->next) // 第i-1个位置的结点为空或者第i个位置结点为空，删除失败 { return false; } LNode<t>* pnext = p->next; p->next = pnext->next; // 将第i-1个结点的next域指向第i个结点的next域 delete pnext; if (p->next == nullptr) // 删除的i结点时ptail，则需要修改ptail的指向 ptail = p; return true; } 求表长 ​ 求表长，不算头结点。 template<class t> inline size_t LinkList<t>::GetLength() { int len = 0; auto current = phead; // 获取头指针 while ( current && ptail != current) { len++; current = current->next; } return len; } 2.3.3 双链表 ​ 单链表结点中，只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头再遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 ​ 双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点。 双链表结点代码结构 template<class t> class LNode { private : t data; // 数据域 LNode<t>* next; // 后继结点的指针域 LNode<t>* pre; // 前继结点的指针域 }; ​ 双链表在单链表道德结点中增加了一个指向其前驱的 prior 指针，因此双链表中的按值查找和按位查找的操作与单链表相同。不同的是在插入和删除操作上，需要额外对前继结点指针域进行操作。 双链表的插入操作 尾部插入 // 在链表尾部插入新结点 template <class t> void LinkList<t>::Insert(t e) { LNode<t>* temp = new LNode<t>(e); temp->pre = ptail; // 将新结点的前继指针指向原链表中的tail指向的结点 ptail->next = temp; // 将链表原结点的尾结点的next指针指向新插入的结点 ptail = temp; // 尾指针移到最后一个结点 } 按序号插入 /// <summary> /// 按位置插入法。 /// </summary> /// <param name=\"i\">插入的位置</param> /// <param name=\"e\">插入的结点数据</param> /// <returns>true，插入成功；false，插入失败</returns> bool LinkList<t>::Insert(int i, t e) { if(i < 1) // 序号不能小于1 return false; // 找到第 i-1个位置的结点 LNode<t>* pi = GetElem(i - 1); if(pi) // 如果第i-1个结点不存在，插入失败， return false; LNode<t>* t = pi->next; // 插入前第i个结点 LNode<t>* temp = new LNode<t>(e); // 申请新结点 pi->next = temp; // 将新结点插入链表 temp->pre = pi; if(ptail == pi) // 如果第i-1个结点时链表尾结点，则移动尾结点 { ptail = temp; } else // 第i-1个结点不是尾结点 { t->pre = temp; temp->next = t; } return true; } 删除结点 // 按位删除结点 template <class t> void Delete(int i) { LNode<t>* pi = GetElem(i - 1); // 获取第i-1个结点 if(!pi || !(pi-next)) // 第i-1个结点不存在或者第i个结点不存在，程序结束 return; if(pi->next) LNode<t>* t = pi->next->next; // t 指向第 i+1个结点 delete pi->next; // 释放第i个结点的空间 if(t == nullptr) // 删除后第i+1个结点不存在，那第i-1个结点就成为了尾结点，需要将尾指针移动到对应的位置 { ptail = pi; } else { pi->next = t; t->pre = pi; } }"
  },
  "Algorithm/Chapter4/4.1.html": {
    "href": "Algorithm/Chapter4/4.1.html",
    "title": "4.1 串的定义和实现",
    "keywords": "4.1 串的定义和实现 ​ 字符串简称串，计算机上非数值处理的对象基本都是字符串数据。比如百度搜索，google搜索；一些商品网站，如淘宝，京东，都会有搜索框提供给用户进行商品的搜索，好不夸张的说，一些网站门户和 APP，均提供了搜索功能，甚至连一些黄色网站也提供了搜索功能。当然也有一些不走主流趋势的公司门户网站没有站内搜索，比如猿辅导。 4.1.1 串的定义 ​ 串是由零个或多个字符组成的有限序列。记为： S='a1a2...an'(n>=0) 串中任意多个连续的字符组成的子序列称为该串的 子串 ，包含字串的串称为 主串 。某个字符在串中的序号称为该字符在串中的位置。字串在主串中的位置以子串的第一个字符在主串中的位置来表示。当两串的长度相等且对应每个位置的字符相等时，称这两个串相等。 A=\"this is a string\"; B=\"is\"; C=\"string\"; B 在 A 中的位置为 6；C 在 A 中的位置为 11。 4.1.2 串的存储结构 定长存储 #define MAXLEN 255 typedef struct{ char ch[MAXLEN]; int length; // 串的实际长度 } SString; 用一组地址连续的存储单元存储串值的字符序列。串有一个最大的长度。 堆存储 typedef struct{ char *ch; // 按串长分配存储区，ch是存储区的首地址 int length; // 串的实际长度 }SString; 这种存储结构比起定长存储又一点好处，就是不限制长度，当ch指向的数组不够长时，可以申请更长的数组。 块链存储 借用链表，将字符存到节点中，每个结点有指向下一节点的指针。 typedef struct{ char ch[5]; node* next; // 指向下一个块的指针 }node; typedef struct{ node* head; // 首地址 } 4.13 串的基本操作 操作名 释义 StrAssign(&T, chars) 赋值操作。把串 T 赋值给 chars。 StrCopy(&T, S) 复制操作。由串 S 复制得到串 T。 StrEmpty(S) 判空操作。S 串为空串，返回 true，否则返回 false。 StrCompare(S, T) 比较操作。若 S > T，返回值 1；若 S = T，返回 0；若 S < T，返回 0。 StrLength(S) 求串长。返回串 S 的元素个数。 SubString(&Sub, S, pos, len) 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。 Concat(&T, S1, S2) 串连接。用 T 返回由 S1 和 S2 联接而成的新串。 Index(S, T) 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0。 ClearString(&S) 清空操作。将 S 串清空。 DestroyString(&S) 销毁串。将串 S 销毁。 上述的接口仅是王道书给出的，我们应该向开源或者语言通用的接口靠近，比如 C++里的 string 类型的 substr，第一个字符的下标是从 0开始算起的。"
  },
  "Algorithm/Chapter4/4.2.html": {
    "href": "Algorithm/Chapter4/4.2.html",
    "title": "4.2 串的模式匹配",
    "keywords": "4.2 串的模式匹配 4.2.1 简单的模式匹配算法 ​ 子串的定位操作通常称为串的模式匹配，它求的是子串在主串中的首次出现的位置。本章节的字符串起始位置从 0 开始算起。 /// <summary> /// 返回-1，表示匹配失败。返回大于等于0，则表示匹配成功，返回值是子串在主串中的位置 /// </summary> /// <param name=\"source\">主串</param> /// <param name=\"pattern\">模式串</param> int Index(SString source, SString pattern) { int sIndex = 0; // 主串下标索引 int pIndex = 0; // 子串下标索引 while(i < source.length && j < pattern.length) { if(source.ch[i] == pattern.ch[j]) { ++sIndex; ++pIndex; } else { sIndex = sIndex - pIndex + 1; // sIndex 回退到上一次开始比较的下一个字符 pIndex = 0; // pIndex 回退到子串第一个字符 } } if(pIndex == pattern.length) return sIndex - pIndex; else return -1; } // 在debug编译模式下，没有弹出警告窗口，说明测试通过了 void IndexTestCast() { SString s; SString pattern; strcpy_s(pattern.ch, \"is a\"); s.length = 16; strcpy_s(s.ch, \"this is a string\"); pattern.length = 4; int index = Index(s, pattern); assert(index == 5); } 该模式的最坏时间复杂度为O(nm)，其中 n 为主串的长度，m 为模式串的长度。 4.2.2 KMP算法 ​ 可以说 4.2.1节的内容是一种暴力匹配算法。暴力匹配的基本思想是滑动窗口（计算机网络知识），即每次循环匹配不成功，就在上一次匹配的基础上，向右移动一位继续重新匹配。 ​ KMP 算法可以从模式自身已经匹配相等的前缀序列中有某个后缀正好是模式的前缀，则直接将模式向后滑动到与这些相等字符对齐的位置进行匹配，而不是只移动一位。 比如主串是 \"abaabaabcabaabc\"，模式串是 “abaabc”。 如果是 暴力匹配算法 ，匹配执行过程是这样的： 第一趟： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第二趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第三趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第四趟：移动1位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 在第四趟的时候匹配成功！ KMP 算法 匹配的执行过程： 第一趟： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 第二趟：移动3位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c 匹配成功！ 可以看出，在这个例子中，kmp 只跑了两趟就匹配成功了。那怎么确定每次应该移动多少位呢？ 模式串解析 名词 解释 前缀 不看最后一个字符，字符串的所有以头部字符开始的子串。 后缀 不看第一个字符，字符串的所有以尾部字符结束的子串。 部分匹配值 字符串的前缀集合和后缀集合中的相等子串解中，取最长相等子串的长度。 比如上面的 abaabc 模式串中，以第一个字符开头的子串一共有6个： 第一个字符开头的子串 前缀 后缀 匹配值 \"a\" ∅ ∅ 0 “ab” {a} {b} 0 \"aba\" {a, ab} {a, ba} 1 \"abaa\" {a, ab, aba} {a, aa, baa} 1 \"abaab\" {a, ab, aba, abaa} {b, ab, aab, baab} 2 \"abaabc\" {a, ab, aba, abaa, abaab} {c, bc, abc, aabc, baabc} 0 所以模式串的 部分匹配值表 为： index 0 1 2 3 4 5 6 Pattern a b a a b c Next 0 0 1 1 2 0 得出上面的表格后，即得到每次移动多少位： 移动位数 = 已匹配字符数 - 最后一个匹配字符对应的部分匹配值 在整个匹配过程中，主串没有回退，而且模式串也不一定每一次都回到首个字符开始匹配，如果有部分匹配值 t 大于 0 的情况，直接从子串的第 t+1个位置开始比较，因为滑动后，模式串前面 t 位已经匹配了。所以 KMP 算法在时间算法复杂度上为 O(n+m)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c a b a a b c fail 从这个例子来看，在位置6出现匹配失败。那么下一轮比较到来时，模式串的指针应该为 pIndex = 2，指向从左数起的第一个 b 字符的下一个字符。而对主串来说，从最后一个匹配成功的下一个字符开始比较，即 sIndex = 5。（pIndex和sIndex均是从1开始的下标） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a b a a b a a b c a b a a b c sIndex=6 a b a a b c pIndex=3 移动位数的代码： move = pIndex - 1 - Next[pIndex - 1] 观察部分匹配值表，每当匹配失败，就去找匹配失败元素的前一个元素的部分匹配值。可以将数组往右移动一位。右移后，每个元素对应的 Next[pIndex] 即是自己的匹配值，而对于第一个元素，用-1，是因为第一个元素匹配失败，需要右移一位。没有右移前，最后一位元素的部分匹配值是给下一位使用的，但是没有下一位，所以可以丢掉。 index 0 1 2 3 4 5 6 Pattern a b a a b c Next -1 0 0 1 1 2 移动位数代码就变成了： move = pIndex - 1 - Next[pIndex]; 相应的子串的指针回退代码为： pIndex = Next[pIndex] + 1; 可以将数组整体加1，move 和 pIndex 的求值变成： pIndex = Next[pIndex]; move = pIndex - Next[pIndex]; 此时数组： index 0 1 2 3 4 5 6 Pattern a b a a b c Next 0 1 1 2 2 3 求数组NEXT 用上述的方法手工去算next数组，确实很方便，但是用代码实现比较难。下面看一个例子求next数组： pIndex 1 2 3 4 5 6 7 8 9 pattern a b a a b c a b a next 0 1 1 2 2 3 已求得6个字符的next值，求next[7]值： ①因为next[6] = 3，pattern[6] = \"c\" ≠ pattern[3]，需比较pattern[6]和pattern[1]。 ②pattern[6]≠pattern[1]，而next[1] = 0，所以next[7] = 1。 求next[8]： ①因为pattern[7]=pattern[1]，那么next[8] = next[7] + 1= 2。 求next[9]: ①因为pattern[8] = pattern[2]，那么next[9] = next[8] + 1 = 3。 void get_next(SString T, int next[]) { int i = 1, j =0; next[1] = 0; while(i < T.length) { if(j == 0 || T.ch[i] == T.ch[j]){ i++;j++; next[i] = j; // 若 pattern[i]=pattern[j]，则next[j+1] = next[j] + 1 } else { j = next[j]; // 令j=next[j],继续循环 } } } KMP 算法实现 int Index_KMP(SString source, SString pattern, int next[]) { int sIndex = 1, pIndex = 1; while(sIndex <= source.length && pIndex <= pattern.length) { if(pIndex == 0 || source.ch[sIndex] == pattern.ch[pIndex]) { ++sIndex; ++pIndex; } else{ pIndex = next[pIndex]; // 和暴力匹配不同，模式串并不是每次都是从第一个字符开始对比的 } } if(pIndex > pattern.length) return sIndex - pattern.length; else return 0; // 失败 }"
  },
  "Algorithm/Chapter5/5.1.html": {
    "href": "Algorithm/Chapter5/5.1.html",
    "title": "5.1 什么是树？",
    "keywords": "5.1 什么是树？ ​ 树是 n 个结点的有限集，n非负。当 n = 0 时，称为空树。任意非空树有以下特点： 有且仅有一个特定的称为根的结点。 n > 1 时，其余结点可分为 m(m > 0)个互不相交的有限集T1，T2，......，Tm。其中每个集合本身又是一颗树，称为根的子树。 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。 树中所有结点可以有零个或多个后继。 如上图所示： A 为 E、F、G、H、I、J 的 祖先 。E、F、G、H、I、J 是 A 的 子孙 。 A 是 B、C、D 的 双亲 ，B、C、D 是 A 的 孩子 。 B、C、D是 兄弟 ，H、I也是兄弟。 树中一个结点的孩子个数称为该结点的 度 。树中结点的最大度数称为 树的度 。A的度为3，C的度为0，D的度为2。 度大于0的结点称为 分支结点 。度为0的结点称为 叶子结点 。 结点的层次从树根开始定义，根结点第1层，它的子结点第2层，以此类推。上图的树为4层。双亲在同一层的结点称为 堂兄弟 。E、F、G、H、I 是堂兄弟。 结点的深度：从根结点往下数，每下一层就+1。 结点的高度：从当前结点网上数，没上去一层+1。 数的高度就是有几层。图中为4。 有序树：树结点的各子树从左到右有次序，不能互换， 路径：树的路径指祖先到孙子（双亲到孩子）的路径，堂兄弟或者远亲的路径不算。 路径长度：就是路径所含的边数。 森林：n 颗互不相交的树。"
  },
  "Algorithm/Chapter5/5.2.html": {
    "href": "Algorithm/Chapter5/5.2.html",
    "title": "5.2 二叉树",
    "keywords": "5.2 二叉树 每个结点至多只有两颗子树，有左右子树之分。如果某个结点的左右子树互换，那么就不是原来的树。 度为2的树，至少有3个结点，二叉树可以为空树。 二叉树就算某个结点只有一个孩子，也要区分左右孩子。 满二叉树 ：一颗高度为 h，且含有（2的h次方-1）个结点的二叉树称为满二叉树。树中每层还有最多结点。满二叉树的叶子结点都集中在最下面一层，除叶子结点外，每个结点的度为2。 自上而下，自左向右，以1起始开始编号，对于编号为 i 的结点，若有双亲，双亲的编号为 i/2； 若有左孩子，左孩子编号为 2i。若有右孩子，右孩子编号为 2i+1。 完全二叉树 ：高度为h、有 n个结点的二叉树，当且仅当其每个结点都与沟渎为h的满二叉树中编号为1-n的结点一一对应，称为完全二叉树。 完全二叉树的特征： 若 i ≤ n/2，则结点 i 为分支结点，否则为叶子结点。 叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点，都依次排列在该层最左边的位置上。 若有度为1的结点，则只可能出现一个，且该结点只有左孩子没有右孩子。 按层序编号后，一旦出现某结点为叶子结点或只有左孩子，则编号大于该结点的结点均是叶子结点。 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点只有左孩子，没有右孩子，其余分子结点左右孩子都有。 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一个二叉排序树。 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。 非空二叉树的叶子结点数等于度为2的结点树加1，即n0=n2+1。 结点数量为n，则边的数量为n-1。 非空二叉树的第k层上至多有2的（k-1）次方个结点。（k≥1） 高度为h的二叉树至多有2的h次方减1个结点。（h≥1） 顺序存储结构 顺序存储就是用一组连续地址来存储结点，在C++中就是数组。 如上述两个图，红色的结点就是空结点，在数组中表示如下： 那么怎么判断数组中各个结点之间的关系？ 根据前文的双亲结点和左右孩子结点之间的关系，通过下标来管理。 链式存储 顺序存储多出了很多的空结点，对空间利用率低。二叉树一般采用链式存储，用链表结点表示二叉树中各个结点之间的关系。 同样的一棵树，链式存储如下： 代码结构： template<class t> class TreeNode { t Data; // 数据域 TreeNode<t> *lChild, *rChild; // 左右孩子 } 含有n个结点的二叉链表中，含有n+1的空指针域。"
  },
  "Algorithm/Chapter5/5.3.html": {
    "href": "Algorithm/Chapter5/5.3.html",
    "title": "5.3 二叉树的遍历",
    "keywords": "5.3 二叉树的遍历 ​ 二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，且仅被访问一次。说白了，就是树是一种分叉结构，怎么想办法转换成线性结构。 概念：根结点N，左孩子L，右孩子R。 常见的遍历方法有 先序遍历NLR ， 中序遍历LNR ， 后序遍历LRN 。 如果是先序遍历的话，就是先访问根结点，再访问左孩子结点，再访问右孩子结点：ABDEC。 如果是中序遍历的话，就是先访问左孩子结点，再访问根结点，再访问右孩子结点：DBEAC。 如果是先序遍历的话，就是先访问左孩子结点，再访问右孩子结点，再访问根结点：DEBCA。 先序遍历 递归实现 void PreOrder(TreeNode<t> root) { if(root!=NULL) { visit(root); // 直接访问当前结点 PreOrder(root->lChile); // 递归左子树 PreOrder(root->rChild); // 递归右子树 } } 非递归实现 template <class t> void PreOrder2(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; // 辅助栈 TreeNode<t>* current = root; while (current != NULL || !st.empty()) // 当前遍历指针不为空或者栈不为空，则执行遍历 { if (current != NULL) { visit(current); st.push(current->rChild); // 右孩子入栈 current = current->lChild; // 指向当前结点的左孩子 } else { current = st.top(); // 出栈 st.pop(); } } } 这里借助一个std域的栈类辅助。 中序遍历 递归实现 void InOrder(TreeNode T) { if(T!=NULL) { InOrder(T->lChile); // 递归左子树 visit(T); // 直接访问当前结点 InOrder(T->rChild); // 递归右子树 } } 非递归实现 template<class t> void InOrder2(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; TreeNode<t>* current = root; while (current != nullptr || !st.empty()) { if (current != nullptr) // 一直往左字符下沉 { st.push(current); // 下沉过程中把遇到的结点入栈 current = current->lChild; } else { current = st.top(); // 出栈 st.pop(); visit(current); // 访问结点 current = current->rChild; // 指向右子树 } } } 后序遍历 递归实现 void PostOrder(TreeNode T) { if(T!=NULL) { PostOrder(T->lChile); // 递归左子树 PostOrder(T->rChild); // 递归右子树 visit(T); // 直接访问当前结点 } } 递归实现的本质，其实是利用了语言本身断点栈的特点，而非递归是要我们自己额外申请一个栈，用于保存当前循环有哪些待访问的结点。 非递归实现 template<class t> void PostOrder(TreeNode<t>* root) { std::stack<TreeNode<t>*> st; TreeNode<t>* current = root; TreeNode<t>* r = nullptr; // 标记右子树是否被访问过 while (current != nullptr || !st.empty()) { if (current != nullptr) // 下沉至左边 { st.push(current); current = current->lChild; } else { current = st.top(); // 查看栈顶元素 if (current->rChild && current->rChild != r) // 右子树存在且未访问过 { current = current->rChild; } else { st.pop(); visit(current); r = current; // 记录最近访问过的点 current = nullptr; // 结点访问完后，重置指针 } } } } 层次遍历 利用队列来赋值遍历树的每个结点。 ①从第一层开始，结点入队，执行完毕。 ②队不为空，出队，并将出队的结点按左孩子先入队，再右孩子入队。 循环①②，直到队空。 // 层次遍历 template<class t> void LevelOrder(TreeNode<t>* root) { if (root == nullptr) return; queue<TreeNode<t>*> que; TreeNode<t>* current; // 当前结点 que.push(root); while (!que.empty()) // 队不为空，执行循环 { // 队头元素出队 current = que.front(); que.pop(); visit(current); if (current->lChild) // 左孩子不为空，左孩子入队 que.push(current->lChild); if (current->rChild) // 右孩子不为空，右孩子入队 que.push(current->rChild); } }"
  },
  "Algorithm/Chapter5/5.5.html": {
    "href": "Algorithm/Chapter5/5.5.html",
    "title": "5.5 树和二叉树的应用",
    "keywords": "5.5 树和二叉树的应用 5.5.1 二叉排序树（BST） 定义 二叉排序树，也叫二叉查找时，二叉搜索树，可以是一颗空树。具有以下特征： 若左子树非空，则左子树上所有结点的值均小于根结点的值。 若右子树非空，则右子树上的所有结点的值均大于根结点的值。 左右子树也分别是一颗二叉排序树。 对其进行中序遍历，变得到一个有序的序列。 对上图进行中序遍历就是： 1 2 3 4 5 6 二叉排序树的查找 比如查找 3，根据上面定义的规则，从树根开始查找，先和根结点进行比较，发现数据 3 比 4 小，则移动指针下沉到根结点的左孩子，然后和数据为 2的结点进行比较，发现，3 比 2 大，所以结点数据为 2 的结点下沉到其右孩子，和 3 比较，发现相等，这样就找到了。 代码实现： // 二叉搜索树的搜索方式 template<class t> TreeNode<t>* search_key(TreeNode<t>* root, t key) { TreeNode<t>* current = root; while (current && current->Data != key) { if (current->Data > key) current = current->rChild; else current = current->lChild; } return current; } 二叉排序树的插入 template<class t> TreeNode<t>* search_father(TreeNode<t>* root, t key) { TreeNode<t>* father = nullptr; TreeNode<t>* current = root; while (current && current->Data != key) { if (current->Data < key) { father = current; current = current->rChild; } else { father = current; current = current->lChild; } } return father; } template<class t> int GetChildrenNum(TreeNode<t>* root) { if (root->lChild && root->rChild) // 左右孩子都存在 return 2; if (root->lChild == nullptr && root->rChild == nullptr) // 叶子结点 return 0; return 1; } // 中序遍历中查找当前结点的后继结点 template<class t> TreeNode<t>* FindInOrderNext(TreeNode<t>* current) { // 中序遍历的结点的后继肯定在右子树 TreeNode<t>* exist = current->rChild; if (exist == nullptr) // 没有后继 return nullptr; TreeNode<t>* next = nullptr; // 指向后继结点 while (exist) { if (exist) // 一路向左 { next = exist; exist = exist->lChild; } else { return next; } } return next; } // 二叉树的删除 template<class t> void Delete(TreeNode<t>* root, t key) { TreeNode<t>* father = nullptr; TreeNode<t>* current = search_key(root, key); // 找到 key 结点 if (!current) // 为空，直接返回 return; father = search_father(root, key); while (current != nullptr) { int count = GetChildrenNum(current); // 叶子结点直接删除 if (count == 0) { if (father) { if (father->lChild == current) { father->lChild = nullptr; } else { father->rChild = nullptr; } } delete current; current = nullptr; return; } else if (count == 1) // 只有一个孩子 { auto child = current->lChild ? current->lChild : current->rChild; // 获取删除结点的孩子 father = search_father(root, current->Data); if (father->lChild == current) father->lChild = child; else father->rChild = child; delete current; current = nullptr; return; } else // 两个孩子都存在 { TreeNode<t>* next = FindInOrderNext(current); // 找到父亲节点 father = search_father(root, next->Data); if(next) current->Data = next->Data; current = next; // 将后继结点继续做判断 } } } 貌似有问题，比如不能删除根结点，正确的做法是应该利用线索化二叉树来做。 5.5.2 平衡二叉树 定义 ​ 为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，称为平衡二叉树。（BBT） 平衡因子：左子树和右子树的高度差。 平衡二叉树的插入 二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此操作而导致了不平衡。若导致不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保证二叉排序树特性的前提下，调整各结点的位置。 LL 平衡旋转 情况：在结点A的左孩子的左子树上插入了新结点，单重A的平衡因子由1变成了2。 方法：将A的左孩子B由右上旋转代替A称为根结点，将A结点向右下旋转称为B的右子树的根结点，而B的原右子树则作为A结点的左子树。 RR 平衡旋转 情况：由于在结点A的右孩子的右子树上插入了新结点，A的平衡因子由-1变为-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。 解决：将A的右孩子B向左上旋转代替A称为根结点，将结点A向左下旋转成B的左子树的根结点，而B的原左子树则作为A结点的右子树。 LR 平衡旋转 情况：由于在A的左孩子的右子树上插入新结点，A的平衡因子由1变为2，导致以A为根结点的子树失去平衡。 解决：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，再把该C结点向右上旋转提升到A结点的位置。 RL 平衡旋转 情况：由于在A的右孩子的左子树上插入新结点，A的平衡因子由-1变为-2，导致以A为根的子树失去平衡。 解决：先将A的右孩子B的左子树的根结点C向右上旋转提升到B结点位置，然后把C结点向左上旋提升到A的位置。 5.5.3 哈夫曼树和哈夫曼编码 定义 从树根到任意结点的路径长度（经过的边数）与该结点权值的乘积称为该结点的带权路径长度。 树中所有结点的带权路径长度之和称为该树的带权路径长度。 其他略。（待补充）"
  },
  "Algorithm/Chapter7/7.1.html": {
    "href": "Algorithm/Chapter7/7.1.html",
    "title": "7.1 概念",
    "keywords": "7.1 概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种： 查找成功，即在数据集合中找到满足条件的数据元素； 查找失败。 查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作有4种。 查询某个特定的数据元素是否在查找表中。 检索满足条件的某个特定的数据元素的各种属性。 在查找表中插入一个数据元素。 从查找表中删除某个数据元素。 静态查找表：若一个查找表的操作只涉及查询和检索，而无须动态地修改查找表。适合静态查找表的查找方法有顺序查找，折半查找、散列查找等。适合动态查找的查找方法有二叉排序树的查找、散列查找等。 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。 平均查找长度：在查找过程中，一次查找的长度是指需要比较关键字的次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。"
  },
  "Algorithm/Chapter7/7.2.html": {
    "href": "Algorithm/Chapter7/7.2.html",
    "title": "7.2 顺序查找和折半查找",
    "keywords": "7.2 顺序查找和折半查找 7.2.1 顺序查找 顺序查找，也可以叫做线性查找，适用于链表和顺序表。对于顺序表，通过数组下标逐个递增去查找；对于链表，通过指针 next 去查找。 一般线性表的顺序查找 template<class t> class Table{ t* data; // 指向数组的首地址 int length; // 长度 }; int Search_Seq(Table tb, t key) { tb.elem[0] = key; // 哨兵 for(int i = tb.length; tb.elem[i]!=key; --i) // 逆序来找 ; return i; } 如果表中的元素有序，比如表中元素是int类型，按从小到大排序，那么查找时不用从表的一端查到另一端，只需查找到比他大（或者小）的一个元素后，即算查找失败。 比如一个表大从小排到大： int a[] = {1,2,3, 5,6, 8,9,10}; 现在要查找 key = 7 的元素 那么查找时，在 6和8之间并没有7这个元素，从头往后查，查到8时即可停止查找。 7.2.2 折半查找 折半查找，又称为二叉查找。仅适用于有序的顺序表。 基本思想：首先将给定值 key 与表中中间位置的元素比较，若相等，则查找成功，返回该元素的位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。然后缩小范围继续相同的查找，不断迭代，直到找到位置，或确定表中没有 key。 template<class t> int Binary_Search(SeqList l, t key) { int low = 0, high = l.length - 1, mid; while(low <= high) { mid = (low + high) / 2; if(l.elem[mid] == key) return mid; else if(l.elem[mid] > key) high = mid - 1; // 从前半部分查找 else low = mid + 1; // 从后半部分查找 } return -1; // 查找失败 } 7.2.3 分块查找 分块查找，也称索引顺序查找。 基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排序。 查找过程： ①在索引表中确定待查记录所在块，可以顺序查找或折半查找找索引表 ②在块内顺序查找。 例如：关键字集合：{88,24,72,61,21,6,32,11,8,31,22,83,78,54}，按照关键字值24, 54, 78, 88分为4个块和索引表。"
  },
  "Algorithm/Chapter7/7.3.html": {
    "href": "Algorithm/Chapter7/7.3.html",
    "title": "7.3 B 树和 B+ 树",
    "keywords": "7.3 B 树和 B+ 树 7.3.1 B 树及其基本操作 B 树，又称多路平衡查找树，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用 m 表示。一个 m 阶 B 树或为空树，或满足以下条件： ① 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字。 ② 若根结点不是终端结点，则至少有两课子树。 ③ 除根结点外的所有非叶结点至少有⌈m/2⌉ 棵子树，即至少含有⌈m/2⌉-1个关键字。 ④ 所有的叶结点都出现在同一层次上，并且不带信息。 B 树是所有结点的平衡因子均等于0的多路平衡查找树。 示例： 从图中可以看出一些性质： 结点的孩子个数等于结点中关键字个数+1。 如果根结点没有关键字就没有子树，此时B树为空；如果根结点有关键字，则其子树必然大于等于两颗子树。 除根结点外的所有非终端结点至少有 ⌈m/2⌉ = ⌈5/2⌉=3 棵子树，至多有 5 棵子树。 结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左边结点的关键字划分成了三个区间：(-∞, 5)，(5 11)，(11, +∞)，该结点 3 个指针所指子树的关键字均落在这 3 个区间内。 所有叶节点均在第 4 层，代表查找失败的位置。 树的高度（磁盘存取次数） 这里我们说树的高度不包括最后的不带任何信息的叶结点所处的那一层。 若 n ≥ 1，则对任意一棵包含 n 个关键字、高度为 h、阶数为 m 的 B 树： ① 因为 B 树中每个结点最多有 m 棵子树，m-1 个关键字，所以在一棵高度为 h 的 m 阶 B 树中关键字个数应满足 n ≤ (m-1)(1+m+m²+…+ m^h)= m^h -1，即 h ≥ log₍m₎(n+1) ② 若让每个结点中的关键字个数达到最少，则容纳同样多关键字的 B 树的高度达到最大。第一层至少有 1 个结点，第二层至少有 2 个结点；除根结点外的每个非终端结点至少有 ⌈m/2⌉ 棵子树，则第三层至少有2⌈m/2⌉个结点，第 h+1 层至少有2(⌈m/2⌉)^(h-1)个结点，这里的第h+1层不包含任何信息的结点。对于关键字个数为 n 的 B 树，叶结点即查找不成功的结点为 n+1，由此有 n+1 ≥ 2(⌈m/2⌉)^(h-1)，即 h ≤log₍⌈m/2⌉₎((n+1)/2) + 1。 综上，h的范围为： log₍m₎(n+1) ≤ h ≤log₍⌈m/2⌉₎((n+1)/2) + 1 B 树的查找 与二叉查找树相似，不过二叉是两路分支，B 树是多路分支。 如何查找？ ① 在B 树中找结点。 ② 在结点内找关键字。 由于 B 树常存在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。 在 B 树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找。 比如查找15： B 树的插入 ① 定位。利用 B 树查找法，找出插入该关键字的最底层中的某个非叶结点。 ② 插入。在 B 树中，每个非失败结点的关键字个数都在区间 [⌈m/2⌉-1, m-1]内。插入后的结点关键字个数小于 m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于 m -1 时，必须对结点进行分裂。 分裂：取一个新结点，在插入 key 后的原结点，从中间位置(⌈m/2⌉) 将其中的关键字分成两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放在新结点中，中间位置（⌈m/2⌉）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续按照这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。 B 树的删除 B 树要求结点中的关键字个数≥⌈m/2⌉-1，所有在删除结点时可能需要合并。 当被删关键字 k 不在终端结点（最底层非叶结点）中时，可以用 k的前驱或者后继k'代替k，然后在相应的结点中删除 k'，关键字 k'必定落在某个终端结点中，则转换成了被删除关键字在终端结点中的情况。 当被删除关键字在终端结点（最底层非叶结点）中时，考虑以下三种情况。 ① 直接删除关键字。若被删除关键字所在结点的关键字个数 ≥ ⌈m/2⌉，表明删除该关键字后依然满足 B 树，则直接删除该关键字。 ② 兄弟够借。若被删除关键字所在结点删除前的关键字个数 = ⌈m/2⌉-1，且与此结点相邻的右（或左）兄弟结点的关键字≥ ⌈m/2⌉，则需要调整该结点、右（或左）兄弟结点及其双亲结点，以达到新的平衡。 ③ 兄弟不够借。若被删除关键字所在结点删除前的关键字个数为 ⌈m/2⌉ -1，且此时与该结点相邻的左、右兄弟结点的关键字个数均为 ⌈m/2⌉ -1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在合并过程中，双亲结点中的关键字个数会减1.若双亲结点是根结点且关键字个数减少至0，则直接删除根结点，合并后的新结点称为根；若双亲结点不是根结点，且关键字个数减少到⌈m/2⌉ -2，则又要与它自己的兄弟结点进行调整合并操作，不断迭代上述操作，直到满足B树要求为止。"
  },
  "Algorithm/Popular/1.1.html": {
    "href": "Algorithm/Popular/1.1.html",
    "title": "反转链表",
    "keywords": "反转链表 来源：牛客网 NC78 反转链表 翻转，可以利用栈的知识去解决，先把链表从表头到表尾的顺序按序入栈。然后再出栈，按照先出栈的结点顺序串起来的链表便是目标要求的新链表。但是如果用栈，空间复杂度就是O(n)，所以用指针来解决。 以四个结点为例： 第一轮循环： 第一轮循环结束后： 第二轮循环结束后： 第三轮循环结束后： 跳出 while 循环后，将新链表的末尾结点的next域指向nullptr。 struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: ListNode* ReverseList(ListNode* pHead) { if (pHead == nullptr) return pHead; ListNode* pNewHead = pHead; // 新链的链头 ListNode* nextNode = pHead->next; // 下一下待翻转结点 ListNode* curList; // 当前待翻转链表链头 while (nextNode != nullptr) { curList = nextNode->next; nextNode->next = pNewHead; pNewHead = nextNode; nextNode = curList; } pHead->next = nullptr; // 令新链表的尾部元素的next域指向空指针 return pNewHead; } void Print(ListNode* pHead) { while (pHead != nullptr) { cout << pHead->val << \" \"; pHead = pHead->next; } } }; int main(int argc, char *argv[]) { Solution s; ListNode* pHead = new ListNode(1); ListNode* p = pHead; for (int i = 2; i < 10; i++) { p->next = new ListNode(i); p = p->next; } cout << \"before ReverseList: \" << endl; s.Print(pHead); pHead = s.ReverseList(pHead); cout << \"\\nafter ReverseList: \" << endl; s.Print(pHead); return 0; } 输出： before ReverseList: 1 2 3 4 5 6 7 8 9 after ReverseList: 9 8 7 6 5 4 3 2 1"
  },
  "CCP/intro.html": {
    "href": "CCP/intro.html",
    "title": "",
    "keywords": "这里是计算机组成原理的内容。"
  },
  "ComputerNetwork/intro.html": {
    "href": "ComputerNetwork/intro.html",
    "title": "",
    "keywords": "这里是计算机网络的内容。"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE.",
    "keywords": "This is the HOMEPAGE . 网页主要用于学习408综合基础知识。由于本人主要跟着王道团队线上线下学习，因此大多资料也出自王道团队的教学内容。 主要科目有： 科目名称 参看书籍 操作系统 王道 计算机网络 王道 数据结构与算法 王道 计算机组成原理 王道"
  },
  "Languages/Chapter1/1.2_IOstream.html": {
    "href": "Languages/Chapter1/1.2_IOstream.html",
    "title": "流的解释",
    "keywords": "流的解释 在1.1节中代码开头<iostream>是c++语言的一个标准库，提供IO机制。 ​ IO库包含两个基础类型： 名称 含义 istream 输入流 ostream 输出流 流的含义：一个流就是一个字符序列，随着时间的推移，字符是顺序生成或消耗的。 标准输入输出对象 标准库定义了4个IO对象。 名称 含义 cin 标准输入 cout 标准输出 cerr 输出警告信息 clog 输出日志打印信息 [^书上是这么说，但是在窗口使用cout\\cerr\\clog，看起来没什么区别。]: 上述四个关键字是在std命名空间下的，使用要加命名空间在前面，如std::cout。 如何使用输入输出流： #include <iostream> int main() { std::cout << \"input two numbers: \" << std::endl; int v1, v2; std::cin >> v1 >> v2; std::cout << \"v1 add v2 equals \" << v1 + v2 << std::endl; return 0; } 运行结果： input two numbers: 5 6 v1 add v2 equals 11 向流写入数据 先熟悉两个运算符： 运算符 含义 << 输出运算符 >> 输入运算符 std::cout << \"input two numbers: \" << std::endl; << 运算符接受两个运算对象，左侧运算对象必须是ostream对象，右侧运算对象是要打印的值。 << 运算符的结果是返回左侧的运算对象，因此可以连续使用两次 << 。 endl关键字是结束当前行，与设备关联的缓冲区中的内容全部刷到设备中。确保关联的缓冲中所有内容输出出来。 从流读取数据 std::cin>>v1>>v2; 和<<运算符类似。"
  },
  "Languages/Chapter1/1.3_Comments_Intro.html": {
    "href": "Languages/Chapter1/1.3_Comments_Intro.html",
    "title": "注释简介",
    "keywords": "注释简介 ​ 通常注释用于解释代码的功能或者代码即将要做的功能，编译时编译器会忽略注释。 错误的注释比没有注释更加糟糕！ 因此更新代码时，确保注释也得到对应的更新。 c++语言的注释： 注释方法 解释 // 注释内容 单行注释 /* 注释内容 */ 界定符注释 界定符注释可以放置任何允许放置制表符、空格符、换行符。还可以跨行。 #include <iostream> /* * 完成一个整数加法功能 * */ int main() { std::cout << \"input two numbers: \" << std::endl; // 提示信息 int v1, v2; std::cin >> v1 >> v2; std::cout << \"v1 add v2 equals \" << v1 + v2 << std::endl; return 0; } 界定符注释不能嵌套 /* * 注释对/**/ * */ 这个注释就是个错误的示范。"
  },
  "Languages/Chapter1/1.4_Control_Stream.html": {
    "href": "Languages/Chapter1/1.4_Control_Stream.html",
    "title": "控制流",
    "keywords": "控制流 语句一般是顺序执行的。 1 while语句 ​ while语句反复执行一段代码，知道给的条件为假为止。 示例：使用while语句求和1到10 #include <iostream> using namespace std; int main() { int i = 0 ,sum = 0; while (i <= 10) { sum += i; i++; } cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 while(condition) ​ statement; 其执行过程是交替执行condition和statement,直至condition为假为止。 2 do ... while语句 示例：使用doWhile语句求和1到10 #include <iostream> using namespace std; int main() { int i = 0 ,sum = 0; do { sum += i; i++; } while (i <= 10); cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 do{ ​ statement; }while(condition) 其执行过程是交替执行statement和condition，直至condition条件为假为止。和while区别是先执行statement语句。 3 for 语句 示例：使用for语句求和1到10 #include <iostream> using namespace std; int main() { int sum = 0; for (int i = 0; i <= 10; i++) { sum += i; } cout << \"result is \" << sum << endl; return 0; } 输出结果：result is 55 for(statment1; condition; statment2) { ​ statement3; } 其执行过程是statement1,交替执行condition，statement3,statement2。 4 if语句 if语句是支持条件执行，是众多语言中最简单的语句之一。 if(condition1) { statement1; } else if(condition2) { statement2; } ... else if(conditionx) { statementx; } else{ statementlast; } 从上往下执行，最先遇到condition为true的是statement执行，其余不执行。 5 读取数量不定的输入数据 有一组数据，预先不知道其数据是多少。要计算这组数据的求和，只能一个一个读取。 int main() { int sum = 0, value = 0; while (cin >> value) { sum += value; // 把每个数据和加到sum } cout << \"result is \" << sum << endl; return 0; } 输入数据：10 43 92 result is 145 当使用istream流对象作为condition的时候，while判断条件时是检测流的状态。即如果流有效，没有遇到错误那么就是true。当流遇到文件结束符，或遇到一个无效输入时（输入的不是一个int类型的数），那么istream对象就会变为无效。 从键盘输入文件结束符 不同操作系统不同操作，在windows下是ctrl+z，然后按回车。"
  },
  "Languages/Chapter1/1.5_Class_Intro.html": {
    "href": "Languages/Chapter1/1.5_Class_Intro.html",
    "title": "类简介",
    "keywords": "类简介 类是对具有相同属性的事物的抽象，是一种数据结构。一个类定义了一个类型，以及与其相关的一组操作(方法)。类机制是C++最重要的特性之一。C++设计最初的一个初衷就是能定义使用上像内置类型一样自然的类类型。 类一般定义在头文件中。 定义一个Sales_Item类 从https://www.informit.com/store/c-plus-plus-primer-9780321714114网站摘抄，本人在此去掉代码前面的作者署名的大量注释。 /* * This file contains code from \"C++ Primer, Fifth Edition\", by Stanley B. * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the * copyright and warranty notices given in that book: * * \"Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.\" */ #ifndef SALESITEM_H // we're here only if SALESITEM_H has not yet been defined #define SALESITEM_H // Definition of Sales_item class and related functions goes here #include <iostream> #include <string> class Sales_item { // these declarations are explained section 7.2.1, p. 270 // and in chapter 14, pages 557, 558, 561 friend std::istream& operator>>(std::istream&, Sales_item&); friend std::ostream& operator<<(std::ostream&, const Sales_item&); friend bool operator<(const Sales_item&, const Sales_item&); friend bool operator==(const Sales_item&, const Sales_item&); public: // constructors are explained in section 7.1.4, pages 262 - 265 // default constructor needed to initialize members of built-in type #if defined(IN_CLASS_INITS) && defined(DEFAULT_FCNS) Sales_item() = default; #else Sales_item(): units_sold(0), revenue(0.0) { } #endif Sales_item(const std::string &book): bookNo(book), units_sold(0), revenue(0.0) { } Sales_item(std::istream &is) { is >> *this; } public: // operations on Sales_item objects // member binary operator: left-hand operand bound to implicit this pointer Sales_item& operator+=(const Sales_item&); // operations on Sales_item objects std::string isbn() const { return bookNo; } double avg_price() const; // private members as before private: std::string bookNo; // implicitly initialized to the empty string #ifdef IN_CLASS_INITS unsigned units_sold = 0; // explicitly initialized double revenue = 0.0; #else unsigned units_sold; // 一条销售记录的售卖书本数量 double revenue; // 一条销售记录的收入 #endif }; // used in chapter 10 inline bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) { return lhs.isbn() == rhs.isbn(); } // nonmember binary operator: must declare a parameter for each operand Sales_item operator+(const Sales_item&, const Sales_item&); inline bool operator==(const Sales_item &lhs, const Sales_item &rhs) { // must be made a friend of Sales_item return lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue && lhs.isbn() == rhs.isbn(); } inline bool operator!=(const Sales_item &lhs, const Sales_item &rhs) { return !(lhs == rhs); // != defined in terms of operator== } // assumes that both objects refer to the same ISBN Sales_item& Sales_item::operator+=(const Sales_item& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; } // assumes that both objects refer to the same ISBN Sales_item operator+(const Sales_item& lhs, const Sales_item& rhs) { Sales_item ret(lhs); // copy (|lhs|) into a local object that we'll return ret += rhs; // add in the contents of (|rhs|) return ret; // return (|ret|) by value } // 对>>运算符进行重写，输入书本条目时，需要输入isbn号、多少本书、单本书籍价格 std::istream& operator>>(std::istream& in, Sales_item& s) { double price; in >> s.bookNo >> s.units_sold >> price; // check that the inputs succeeded if (in) s.revenue = s.units_sold * price; else s = Sales_item(); // input failed: reset object to default state return in; } // 对 <<运算符进行重写，输出销售记录的isbn号，销售数量，销售数量，销售收入，每本书的平均价格 std::ostream& operator<<(std::ostream& out, const Sales_item& s) { out << s.isbn() << \" \" << s.units_sold << \" \" << s.revenue << \" \" << s.avg_price(); return out; } // 计算书的平均价格 double Sales_item::avg_price() const { if (units_sold) return revenue/units_sold; else return 0; } #endif 研读完上述代码后，输入一条销售记录的正确操作不仅仅是输入书籍isbn号码，而是要输入当前销售记录的isbn号，卖了几本，该书籍的售卖的单价。 如果一条销售记录输入的数据无效，只要三者有其一无效，当前写入的记录条目的数据全部默认为0。 Sale_Item类的应用 #include <iostream> #include \"Sales_item.h\" using namespace std; int main() { Sales_item total; // 保存下一条交易记录 // 读入第一条交易记录，并确保有数据处理 if (cin >> total) { Sales_item trans; // 保存和的变量 // 读入并处理剩余交易记录 while (cin >> trans) { // 如果任然在处理相同的书 if (total.isbn() == trans.isbn()) { total += trans; // 更新总销售额 } else { // 打印前一本书的结果 cout << total << endl; total = trans; // total 现在表示下一本书的销售额 } } cout << total << endl; // 打印最后一本书的结果 } else { // 没有输入！警告读者 cerr << \"No data?!\" << endl; return -1; } return 0; // 表示失败 }"
  },
  "Languages/Chapter1/intro.html": {
    "href": "Languages/Chapter1/intro.html",
    "title": "",
    "keywords": "#include <iostream> int main() { std::cout << \"Hello World!\\n\"; return 0; } 运行结果：Hello world!"
  },
  "Languages/Chapter10/10.1.html": {
    "href": "Languages/Chapter10/10.1.html",
    "title": "10.1 概述",
    "keywords": "10.1 概述 标准库提供了一套函数，实现了一些基本的算法，如排序，查找等。大多数算法定义在头文件 algorithm 中，在头文件 numeric 中定义了一组数值泛型算法。 这些算法并不直接操作容器，而是接受两个迭代器指定的元素范围进行操作。 int val = 42; auto result = find(vec.cbegin(), vec.cend(), val); cout << \"The value\" << val << (result == vec.cend()) ? \"is not present\":\"is present\" << endl; find 将范围中每个元素与给定值进行比较。它返回指向第一个等于给定值的元素的迭代器。如果范围内无匹配元素，则 find 返回第二个参数来表示搜索失败。因此，我们可以通过比较返回值和第二个参数来判断是否搜索成功。 由于 find 操作的是迭代器，因此我们可以用同样的 find 函数在任何容器中查找值。 list<string> lst = { \"there\",\"are\",\"so many\",\"a value\" }; string val = \"a value\"; auto result = find(lst.begin(), lst.end(), val); cout << *result << endl; 指针就像内置数组上的迭代器，find 也接受参数为指针的一个范围： int ia[] = {27, 210, 12, 47, 109, 83}; int val = 83; int* result = find(begin(ia), end(ia), val); 算法内部的一些实现细节 从第一个参数开始迭代遍历到第二个参数指向的位置的前一个元素，逐个与 val 进行值比较，这个过程中的比较用的是 == 关系运算符。如果是一个自定义类型，那么想用 find 函数，就需要这个类重载一个 == 关系运算符。或者自定义操作来代替默认的运算符。"
  },
  "Languages/Chapter10/10.2.html": {
    "href": "Languages/Chapter10/10.2.html",
    "title": "10.2 初识泛型算法",
    "keywords": "10.2 初识泛型算法 标准库提供了超过100个算法，死记硬背是可以背下来，但是过了一段时间不用就会忘却，因此也没必要背。等到需要时再去查阅即可。 10.2.1 只读算法 一些算法只会读取其输入范围内的元素，而从不改变元素。find 就是这样一种算法。 accumulate 在 numeric 中有一个 accumulate 函数，接受三个参数，是将 第一个参数到第二个参数之间的范围进行求和，第三个参数是求和的初值。 int sum = accumulate(vec.cbegin(), vec.cend(), 0); 第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 string sum = accumulate(v.cbegin(), v.cend(), string(\"\")); // 正确 // 编译错误，第三个参数传递的是一个字符串字面值，函数内部用于保存对象的类型是 const char* // const char* 并未定义+运算符。 string sum1 = accumulate(v.cbegin(), v.cend(), \"\"); 但是我在用VS019运行这段代码，并未出现编译错误，只是 sum1是个空字符串，sum的值为“test”。 equal 用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 true，否咋返回 false。此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素。 equal(roster1.cbegin(), roster1.cend(), roster.cbegin()); equal内部会对迭代器进行解引用然后那值进行 == 比较，因此两个序列中的元素类型不一定要一样，但是要能够支持类型之间的 == 符号即可。而且，第二个序列的起始位置往后的元素个数不少于要和第一个序列的范围中元素个数。 10.2.2 写容器元素的算法 fill fill(vec.begin(), vec.end(), 0); // 将每个元素重置为 0 算法不检查写操作 fill_n 拿fill_n函数来说，它接受三个参数，第一个参数是容器的起始位置，第二个参数是在起始位置往后多少个元素进行写值，第三个参数是要写入的值。 vector<int> vec(10); fill_n(vec.begin(), vec.size(), 1); // vec中每个元素值都改为1 // 一般式为 fill_n(dest, n, val) // 危险！ vect<int> vec; fill_n(vec.begin(), 10, 1); // vec的容量为0 back_inserter 通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。back_inserter 就是这么一个功能，它定义在头文件 interator 中。 back_inserter 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当通过此迭代器赋值时，赋值运算符会用 push_back 将一个具有给定值的元素添加到容器中： vector<int> vec; auto it = back_inserter(vec); *it = 42; // vec中含有 {42} *it = 90; // vec中含有 {42, 90} 这样就可以配合 fill_n 给容器添加元素了 vector<int> vec; fill_n(back_inserter(vec), 10, 1); // vec = {1,1,1,1,1,1,1,1,1,1} 拷贝算法 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。接受三个参数，前两个表示一个输入序列的范围，第三个表示目的序列的起始位置。传递给 copy 的目的序列至少要包含与输入序列一样多的元素。 int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int a2[sizeof(a1)/sizeof(*a1)]; auto ret = copy(begin(a1), end(a1), a2); copy 返回的是其目的位置迭代器的值。即 ret 恰好指向拷贝到 a2 的尾元素之后的位置。 多个算法都提供 “拷贝”。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。 raplace 读入一个序列，将其中所有等于给定值的元素都改成另一个值。此算法接受 4 个参数：前两个迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值 // 将 ilist 中所有值为 0 的元素改为 42 replace(ilist.begin(), ilist.end(), 0, 42); replace_copy replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42); ilst 并未改变，ivec 包含 ils的一份拷贝，不过原来在 ilst 中值为 0 的元素在 ivec 中都变为 42。 10.2.3 重排容器元素的算法 sort sort 会重排输入序列中的元素，使之有序，它是利用元素类型的 < 运算符来实现排序的。 vector<int> ivec = { 1,3,1,2,345,7,45,123 }; sort(ivec.begin(), ivec.end()); for (auto i : ivec) { visit(i); } 输出：1 1 2 3 7 45 123 345 利用 sort 、unique 和 erase 去掉重复单词 void elimDups(vector<string>& words) { // 排序 sort(words.begin(), words.end()); // unique 重排输入范围，使得每个单词只出现一次 // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器，也就是说这时候words把多余的重复单词放到后面 auto end_unique = unique(words.begin(), words.end()); // 删除重复单词 words.erase(end_unique, words.end()); }"
  },
  "Languages/Chapter10/10.3.html": {
    "href": "Languages/Chapter10/10.3.html",
    "title": "10.3 定制操作",
    "keywords": "10.3 定制操作 sort 的内部是使用元素类型的 < 运算符进行比较的，对 string 而言，< 系统有自己的一套比较规则，但是我们想定做额外的规则，我们需求是要定义自己的 < 运算符。 10.3.1 向算法传递函数 ​ 加入希望上一节的 elimDups 函数在排序时希望按照单词长度排序，大小相同再按字典序列排序。为了这个操作，我们使用接受三个参数的 sort 函数，第三参数是 谓词 。 ​ 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分两类： 一元谓词 ，意味着它们只接受单一参数； 二元谓词 ，意味着它们有两个参数。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换谓词的参数类型。 ​ 接受一个二元谓词参数的 sort 版本用这个谓词代替 < 运算符来比较元素。我们提供给 sort 的谓词必须满足将在 11.2.2 节中所提到的条件。 bool isShorter(const string& s1, const string& s2) { return s1.size() < s2.size(); } // 按长度由短到长排序 words sort(words.begin(), words.end(), isShorter); // 这里传一个 函数名进去，有点像C#的委托delegate 排序算法 假定序列是： vector<string> svec = {\"the\", \"more\", \"abandon\", \"banana\", \"mike\", \"theater\", \"moreadvance\", \"mora\"}; sort(svec.begin(), svec.end(), isShorter); 这样排序后，得到的 svec 中的序列为： the more mike mora banana abandon theater moreadvance 我们观察发现，排序真的仅仅是按照 isShorter 里的规则比较，但是我们又希望能够在相等长度的情况下，按照字符排序。 总结就是我们希望排序的规则是： 先按长度排序。 长度相等按字符字典中位置排序。 除了重新编写 isShorter 外，可以先用 sort 处理一遍容器，然后再使用 stable_sort 来处理，stable_sort维持相等元素的原有顺序。 vector<string> svec = {\"the\", \"more\", \"abandon\", \"banana\", \"mike\", \"theater\", \"moreadvance\", \"mora\"}; sort(svec.begin(), svec.end()); stable_sort(svec.begin(), svec.end(), isShorter); 这样输出的结果就是： the mike mora more banana abandon theater moreadvance 10.3.2 lambda 表达式 ​ 根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。 比如，现在要在排序好了的容器里输出长度大于等于5的字符串。我们可能这样写： void biggies(vector<string>& words, vector<string>::size_type sz) { elimDups(); // 将 words 按照字典排序，删除重复单词 // 按照长度排序 stable_sort(words.begin(), words.end(), isShorter); auto iter = words.begin(); // 找到第一个字符串长度大于等于 5 的迭代器 while((*iter).size() <= sz) { iter ++; } // 计算有多少个 int count = words.end() - iter; // 利用 count 执行打印 } 此外还可以用标准库中的 find_if 算法来查找第一个具有特定大小的元素，find_if 接受一对迭代器，表示一个范围。但与 find 不同， find_if 接受的第三个参数是一个谓词。find_if 算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非 0 值的元素，如果不存在这样的元素，则返回尾迭代器。 上面的代码我们可以这样写： bool customizeLength(const string& s1) { return s1.size() >= 5; } int main(int argc, char* argv[]) { vector<string> svec = {\"the\", \"more\", \"mora\", \"mike\", \"abandon\", \"banana\", \"theater\", \"moreadvance\"}; sort(svec.begin(), svec.end()); stable_sort(svec.begin(), svec.end(), isShorter); auto iter = find_if(svec.begin(), svec.end(), customizeLength); while (iter != svec.end()) { visit(*iter); iter++; } return 0; } 显然，在主函数 mian 中去调用 find_if 没法给 customizeLength 函数传入一个string::size_type类型的变量去定制。 介绍 lambda ​ 我们可以向一个算法传递任何类别的 可调用对象 。对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。即，如果 e 是一个可调用的表达式，则我们可以编写代码 e(args)，其中 args 是一个逗号分隔的一个或多个参数的列表。像函数、函数指针。 ​ 一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda 可能定义在函数内部。如下： [capture list](parameter list) -> return type{function body} capture list：lambda 所在函数中定义的局部变量的列表。 return type：返回类型 parameter list：参数列表 function body：函数体 必须用尾置返回来指定返回类型。 可以忽略参数列表和返回类型，必须包含捕获列表和函数体。 auto f = []{return 42;}; cout <<< f() << endl; ​ 在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。如果忽略返回类型，lambda 根据函数体中的代码推断出返回类型。如果函数体只是一个 return 语句，则返回类型从返回表达式的类型推断而来。否则，返回类型为 void。 向 lambda 传递参数 ​ 调用一个 lambda 时给定的实参被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda 不能有默认参数。因此，一个 lambda 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。 一个与 isShorter 函数完全相同功能的 lambda： [](const string& a, const string& b) { return a.size() < b.size(); } 捕获列表为空表示 lambda 不接受函数体中任何局部变量，lambda 的参数与 isShorter 的一样，是 const string 的引用。lambda 的函数体也与 isShorter 类型，比较两个参数的 size。 stable_sort(words.begin(), words.end(),[](const string& a, const string& b){ return a.size() < b.size(); }); 使用捕获列表 现在我们要给 find_if 调用一个 lambda 表示，希望 sz 能传到 lambda 的函数体内使用，那么先用捕获列表捕获 sz： [sz](const string& a) { return a.size() >= sz; }; 调用 find_if auto wc = find_if(words.begin(), words.end(), [sz](const string& a){ return a.size() >= sz; }); for_each 算法 打印长度大于 sz 的字符串，文章前面用的是 while，也可以用 for_each 来完成这个功能： for_each(wc, words.end(), [](const string& s){cout << s <<\" \";}); 这个算法接受一个可调用对象，并对输入序列中每个元素调用此对象。 捕获列表只作用于局部非 static 变量，lambda 可以直接使用局部 static 变量和在它所在函数体之外声明的名字。 完整的 biggies： void biggies(vector<string>& words, vector<string>::size_type sz) { elimDups(words); stable_sort(words.begin(), words.end(), [](const string& a, const string& b){ return a.size() < b.size(); }); auto wc = find_if(words.begin(), words.end(), [sz](const string& a){ return a.size() >= sz; }); auto count = words.end() - wc; // 有几个长度大于 sz的字符串 cout << \"有 \" << count << \"个字符串长度大于等于\" << sz << endl; // 打印长度大于等于 sz 的所有字符串 for_each(wc, words.end(), [](const string& a){ cout << a << \" \"; }); cout << endl; } 10.3.3 lambda 捕获和返回 ​ 当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名）类类型（参考14.8.1节）。当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 auto 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。 ​ 默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员。类似任何普通类的数据成员，lambda 的数据成员也在 lambda 对象创建时被初始化。 值捕获 ​ 类似参数传递，变量的捕获方式也可以是值或引用。 lambda 捕获列表 [] 空捕获列表。lambda 不能使用所在函数中的变量。一个 lambda 只有捕获变量后才能使用它们。 [names] names 是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了 &，则采用引用捕获方式。 [&] 隐式捕获列表，采用引用捕获方式。lambda 体中所使用的来自所在函数的实体都采用引用方式使用。 [=] 隐式捕获列表，采用值捕获方式。lambda 体将拷贝所使用的来自所在函数体的实体的值 [&, identifier_list] identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数体的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list 中的名字前面不能使用& [=, identifier_list] identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数体的变量。这些变量采用引用捕获方式，而任何隐式捕获的变量都采用值方式捕获。identifier_list 中的名字不能包括 this，且这些名字之前必须使用& 采用值捕获的前提是变量可以拷贝。被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。 // 值捕获 void fcn1() { size_t v1 = 42; auto f = [v1]{return v1;} v1 = 0; auto j = f(); // j = 42 } // 引用捕获 void fcn1() { size_t v1 = 42; auto f = [&v1]{return v1;} v1 = 0; auto j = f(); // j = 0 } ​ 引用捕获一个变量，要确保被引用的对象在 lambda 执行时还存在，否则可能在调用该 lambda 函数体时就出现未知访问的可能。如在一个函数体内用引用捕获一个函数体内部的普通变量，在出了函数体之外还想调用该lambda，这时候就出现未知访问的情况。 对于传递一个流来说，就必须使用引用捕获了，因为流不可拷贝。 void biggies(vector<string>& words, vector<string>::size_type sz, ostream& os = cout, char c = ' ') { for_each(words.begin(), words.end(), [&os, c](const string& s){ os << s << c; }); } 在函数体给另一个函数传入 lambda，是没有问题的，但是就像之前说的那样，如果退出了当前的函数体，还是引用了函数体内部变量，就有麻烦。而导致一个 lambda 能在函数体外部使用的一个原因是，函数可以返回 lambda。 隐式捕获 略。 可变 lambda ​ 默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。如果希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 mutable 。因此，可变 mutable 能省略参数列表： void fcn3() { size_t v1 = 42; auto f = [v1]()mutable{return ++v1;}; v1 = 0; auto j = f(); // j = 43; } 如果不加 mutable 行不行？答案是不行，编译不通过。当然如果是引用捕获，不用加 mutable。 指定 lambda 返回类型 在 lambda 函数体内部，只有单一的一条 return 语句，编译器可以推断出返回类型，此时 lambda 表达式就不需要写返回类型，但是形如下面这样： transform(vi.begin(), vi.end(), vi.begin(), [](int i){ if(i < 0) return -i; else return i; }); 是编译不通过的，此时编译器推断 lambda 返回的是 void。 但是我在 vs2019上运行上面的代码是正确的！ 当 lambda 不能推断出返回类型时，需要显式指定返回类型： transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int { if(i < 0) return -i; else return i; }); 10.3.4 参数绑定 标准库 bind 函数 加入我们调用 find_if 20次，那么我们就得写20个 lambda 表达式，虽然可以，但是这显然不是很合理。我们可以将 lambda 表达式写成函数： bool check_size(const string& s, string::size_type sz) { return s.size() >= sz; } 但是如果把 check_size 当参数传给 find_if ，就没办法把 sz 传入。为此，标准库中的 bind 函数可以解决参数的问题，bind 定义在头文件 functional 中。可以将 bind 函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来 “适应” 原对象的参数列表。 一般式： auto newCallable = bind(callable, arg_list); newCallable：一个可调用对象 arg_list：一个逗号分隔的参数列表，对应给定 callable 的参数。 当我们调用 newCallable 时，newCallable 会调用 callable，并传入 arg_list中的参数。 arg_list 中的参数可能包含形如 _n 的名字，其中 n 是一个整数。这些参数是 “占位符”，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的 “位置”。数值 n 表示生成的可调用对象中参数的位置：_1 为 newCallable 的第一个参数，_2 为第二个参数，以此类推。 绑定 check_size 的 sz 参数 auto check6 = bind(check_sz, _1, 6); 这个 bind 调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。此参数是一个 const string& 类型。因此，调用 check6 必须传递给它一个 string 类型的参数，check6 会将此参数传递给 check_size。 string s = \"hello\"; bool b1 = check6(s); // check6 会调用 check_size(s, 6) 这样，原来的 find_if 就可以写成如下： auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); 不过使用 _n 名字，需要声明 placeholders 这个命名空间 。 auto wc = find_if(words.begin(), words.end(), bind(check_size, std::placeholders::_1, sz)); bind 的参数 // f 是一个可调用对象 auto g = bind(f, a, b, _2, c, _1); 说明 g 是一个可调用对象，接受两个参数。 当我们调用 g 时： g(X,Y); // 相当于调用了 f(a,b,Y,c,X); 绑定引用参数 ​ 默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或者要绑定参数的类型无法拷贝，比如流。 lambda 表达式： for_each(words.begin(), words.end(), [&os, c](const string& s){ os << s << c; }); 相同功能的函数： ostream& print(ostream& os, const string& s, char c) { return os << s << c; } 但是不能用 bind 来代替对 os 的捕获： // 错误，不能拷贝流os for_each(words.begin(), words.end(), bind(print, os, _1, ' ')) 在bind时，需要用 ref 库函数对 os 进行引用： // 正确 for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '))"
  },
  "Languages/Chapter10/10.4.html": {
    "href": "Languages/Chapter10/10.4.html",
    "title": "10.4 再探迭代器",
    "keywords": "10.4 再探迭代器 本节介绍几个比较重要的迭代器： 迭代器名 插入迭代器 迭代器被绑定到一个容器上，可用来向容器插入元素。 流迭代器 迭代器被绑定到输入或输出流上，可用来遍历所有关联的 IO 流。 反向迭代器 迭代器向后而不是向前移动。除了 forward_list 之外的标准库容器都有反向迭代器。 移动迭代器 专用的迭代器不是拷贝其中的元素，而是移动它们。（参考13.6.2节） 10.4.1 插入迭代器 ​ 插入迭代器时一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。 操作 it = t 在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用 c.push_back(t)、c.push_front(t) 或 c.insert(t, p)，其中 p 为传递给 inserter 的迭代器位置。 *it, ++it, it++ 这些操作虽然存在，但是不会对 it 做任何事情，每个操作都返回 it。 插入器有三种： 插入器 back_inserter 创建一个使用 push_back 的迭代器。 front_inserter 创建一个使用 push_front 的迭代器。 inserter 创建一个使用 insert 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将插入到给定迭代器所表示的元素之前。 显然，如果一个容器没有push_back 操作，是不可以调用 back_inserter 的，其他类似。 当调用 inserter(c, iter) 时，我们得到一个迭代器，接下来使用它时，会将元素插入到 iter 原来所指向的元素之前的位置。即，如果 it 是由 inserter 生成的迭代器，则下面这样的赋值语句： *it = val; 等价于 it = c.insert(it, val); ++it; front_inserter 生成的迭代器的行为与 inserter 生成的迭代器完全不一样。当我们使用 front_inserter 时，元素总是插入到容器第一个元素之前。即使我们传递给 inserter 的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不在是容器的首元素了。 list<int> lst = {1, 2, 3, 4}; list<int> lst2, lst3; // 拷贝完之后，lst2 = {4,3,2,1} copy(lst.cbegin(), lst.cend(), front_inserter(lst2)); // 拷贝完之后，lst2 = {1,2,3,4} copy(lst.cbegin(), lst,cend(), inserter(lst3, lst3.begin())); 10.4.2 iostream 迭代器 ​ 虽然 iostream 类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。这些迭代器将它们对应的流当做一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读入数据以及向流写入数据。 istream_iterator 操作 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个 istream_iterator 使用 >> 来读取流。因此， istream_iterator 要读取的类型必须定义了输入运算符。当创建一个 istream_iterator 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样，就创建了一个可以当做尾后值使用的迭代器。 istream_iterator<int> int_it(cin); // 从 cin 读取 int istream_iterator<int> int_eof; // 尾后迭代器 ifstream in(\"afile\"); // istream_iterator<string> str_it(in); // 从 “afile” 中读取字符串 这节生涩难懂，日后再补充。 10.4.3 反向迭代器 ​ 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（递减）操作的含义会颠倒。递增一个反向迭代器(++it)会移动到前一个元素；递减一个迭代器(--it)会移动到下一个元素。 ​ 除了 forward_list 之外，其他容器都支持反向迭代器。我们可以通过调用 rbegin、rend、crbegin 和 crend 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前的一个位置的迭代器。 vector<int> vec = {1,2,3,4,5,6,7,8,9}; for(auto r_iter = vec.crbegin(); r_iter != vec.crend(); r_iter++) cout << *r_iter << endl; 反向迭代器也支持递减符号，就是 forward_list 和 流迭代器不支持递减运算符，所以 这两个不能创建反向迭代器。 反向迭代器转换普通迭代器 ​ 现在又一个名为 line 的 string，保持着一个用逗号分隔的单词列表： string line = \"water,watermelon,computer,sellphone,glass,container\"; 现在要打印第一个单词，怎么做? auto comma = find(line.cbegin(), line.cend(), ','); cout << string(line.cbegin(), comma) << endl; 如果希望打印最后一个单词。 我们可以用反向迭代器找到最后一个逗号所在的位置： auto comma = find(line.crbegin(), line.crend(), ','); 接着我们得意洋洋的要打印： cout << string(line.crbegin(), comma) << endl; 最后发现打印出来的单词为： reniatnoc 单词反过来了！！！ 这是因为我们使用的是反向迭代器，一切都得反着来。 我们可以把 comma 转换成一个普通的迭代器 ，再配合 line.cend() 的指向，就可以正常输出最后一个单词了。 cout << string(comma.base(), line.cend()) << endl; 输出： container"
  },
  "Languages/Chapter10/10.5.html": {
    "href": "Languages/Chapter10/10.5.html",
    "title": "10.5 泛型算法结构",
    "keywords": "10.5 泛型算法结构 略，待补充。"
  },
  "Languages/Chapter10/10.6.html": {
    "href": "Languages/Chapter10/10.6.html",
    "title": "10.6 特定容器的算法",
    "keywords": "10.6 特定容器的算法 略。"
  },
  "Languages/Chapter11/11.1.html": {
    "href": "Languages/Chapter11/11.1.html",
    "title": "11.1 使用关联容器",
    "keywords": "11.1 使用关联容器 关联容器：元素按关键字保存和访问。 顺序容器：元素按其在容器中的位置来顺序保存和访问。 ​ 关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是 map 和 set。map 中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。set 中每个元素只包含一个关键字；set 支持高效的关键字查询操作——检查一个给定关键字是否在 set 中。 ​ 标准库有 8 个关联容器。这 8 个容器的不同体现在三个维度上： 或者每个容器或者是一个 set，或者是一个 map； 或者要求不重复的关键字，或者允许重复关键字； 按顺序保存元素，或无序保存。 允许重复关键字的容器的名字中都包含单词 multi；不保持关键字按顺序存储的容器的名字都以单词 unordered 开头。因此 一个 unordered_multi_set 是一个允许重复关键字，元素无序保存的集合，而一个 set 则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。 类型 map 和 multimap 定义在头文件 map 中；set 和 multiset 定义在头文件 set 中；无序容器则定义在头文件 unordered_map 和 unordered_set 中。 类型 map 关联数组；保存关键字-值对 set 关键字即值，即只保存关键字的容器 multimap 关键字可重复出现的 map multiset 关键字可重复出现的 set unordered_map 用哈希函数组织的 map unordered_set 用哈希函数组织的 set unordered_muitlmap 哈希组织的 map；关键字可以重复出现 unordered_muitlset 哈希组织的 set；关键字可以重复出现 使用 map 例子：单词计数程序 map<string, size_t> word_count; // string 到 size_t 的空 map string word; while(cin >> word) { ++word_count[word]; // 提取 word的计数器并加1 } for(const auto& w: word_count) { cout << w.first << \" occurs \" << w.second << ((w.second > 1) ? \" times\" : \"time\") << endl; } 使用 set 统计时忽略掉一些不重要的单词： map<string, size_t> word_count; set<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\", \"the\", \"but\", \"and\", \"an\", \"a\"}; string word; while(cin >> word) { // set 容器中如果没有word，就返回尾迭代器 if(exclude.find(word) == exclude.end()) ++ word_count[word]; }"
  },
  "Languages/Chapter11/11.2.html": {
    "href": "Languages/Chapter11/11.2.html",
    "title": "11.2 关联容器",
    "keywords": "11.2 关联容器 ​ 关联容器不支持顺序容器的位置相关的操作，列如 push_front 或 push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。 11.2.1 定义关联容器 ​ 当定义一个 map 时，必须指明关键字类型又指明值类型。而定义一个 set 时，只需指明关键字类型，因为 set 中没有值。每个关联容器都定义了一个默认构造函数。也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。 map<string ,size_t> word_count; set<string> exclude = {\"the\", \"but\", \"and\", \"or\", \"an\", \"a\",\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\"}; map<string, string> authors = {{\"Joyce\", \"James\"}, {\"Austen\", \"Jane\"}, {\"Dickens\", \"Charles\"}}; 初始化 multimap 或 multiset ​ 一个map 或 set 中的关键字必须唯一，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器 multimap 和 multiset 没有此限制，它们都允许多个元素具有相同的关键字。 map<string, int> simple; pair<string, int> p; p.first = \"this\"; p.second = 9; simple.insert(p); p.first = \"this\"; p.second = 10; simple.insert(p); for (auto& r : simple) { cout << r.first << \" \" << r.second << endl; } 打印： this 9 说明 map 的第二次插入失败了。事实上 map 类型的对象simple在调用 insert 后，会返回一个pair，这个pair 的second是一个bool类型，true说明插入成功，false说明插入失败。 multimap<string, int> multi; pair<string, int> p; p.first = \"this\"; p.second = 9; multi.insert(p); p.first = \"this\"; p.second = 10; multi.insert(p); for (auto& r : multi) { cout << r.first << \" \" << r.second << endl; } 打印： this 9 this 10 说明第二次插入成功了，multimap 是允许关键字相同的 pair 插入的！ 11.2.2 关键字类型的要求 ​ 关联容器对其关键字类型有一些限制。对于有序容器——map、multimap set 以及 multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型 < 运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。 有序容器的关键字类型 ​ 可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的 < 运算符。所提供的操作必须在关键字类型上定义一个 严格弱序 。可以将 严格弱序 看做 “小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质： 两个关键字不能同时 “小于等于” 对方；如果 k1 “小于等于” k2，那么 k2 绝不能 “小于等于” k1。 如果 k1 “小于等于” k2，且 k2 “小于等于” k3，那么 k1 必须 “小于等于” k3。 如果存在两个关键字，任何一个不 “小于等于” 另一个，那么我们称这两个关键字是“等价”的。如果 k1 “等价于” k2，且 k2 \"等价于\" k3，那么 k1 必须 “等价于” k3。 如果两个关键字是等价的（任何一个都不 “小于等于” 另一个），那么容器将它们视作相等来处理。当做 map 的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。 使用关键字类型的比较函数 ​ 还记得 Sales_data 类型吗？我们现在可不能直接定义用 Sales_data 做关键字的 multiset，因为Sales_data 还没有 < 运算符。可以定义一个 compareIsbn 函数，这个函数用于在 Sales_data 对象的 ISBN 成员上定义一个 严格弱序 。 bool compareIsbn(const Sales_data& lhs, const Sales_data& rhs) { return lhs.isbn() < rhs.isbn(); } 为了使用自己定义的操作，在定义 multiset 时我们必须提供两个类型：关键字类型 Sales_data 和 比较操作类型——函数指针类型，指向 compareIsbn。 multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn); // 等价于multiset<Sales_data, bool(*)(const Sales_data&, const Sales_data&)> bookStore(compareIsbn); 用 compareIsbn 来初始化 bookstore 对象，意味当向 bookstore 添加元素时，通过调用 compareIsbn 来为这些元素排序。 11.2.3 pair 类型 定义在头文件 utility 中。 见名知意，pair 就是一对{关键字，值}；上文我们已经用到了 pair 对象当做参数调用 map的 insert 函数。 操作 pair<T1, T2> p; p 是一个 pair，两个类型分别为 T1 和 T2 的成员都进行了值初始化 pair<T1, T2> p(v1, v2) p 是一个成员类型为 T1 和 T2 的pair；first 和 second 成员分别用 v1 和 v2 进行初始化。 pair<T1, T2>p = {v1, v2}; 等价于 pair<T1, T2> p(v1, v2) make_pair(v1, v2) 返回一个用 v1 和 v2 初始化的 pair。pair 的类型从 v1 和 v2 的类型推断出来的 p.first 返回 p 的名为 first 的数据成员 p.second 返回 p 的名为 second 的数据成员 p1 relop p2 关系运算符（<、<=、>、>=）按字典序定义：如，p1.first < p2.first 或 !(p2.first < p1.first) && p1.second < p2.second 成立时，p1 < p2 为true。 p1 == p2 当 first 和 second 成员分别相等时，两个 pair 相等。 pair<string, string> anon; pair<string, vector<int>> line; pair<string, string> authors{\"?James\", \"Joyce\"}; 创建 pair 对象的函数 pair<string, int> process(vector<string>& v) { if(!v.empty()) { return {v.back(), v.back().size()}; // 列表初始化 } else{ return pair<string, int>(); // 隐式构造返回值 } } 或者 pair<string, int> process(vector<string>& v) { if(!v.empty()) { return make_pair(v.back(), v.back().size()); // 列表初始化 } else{ return pair<string, int>(); // 隐式构造返回值 } }"
  },
  "Languages/Chapter11/11.3.html": {
    "href": "Languages/Chapter11/11.3.html",
    "title": "11.3 关联容器的操作",
    "keywords": "11.3 关联容器的操作 类型别名 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型：只适用于 map value_type 对于 set，与 key_type 相同 对于 map，为 pair<const key_type, mapped_type> set<string>::value_type v1; // v1 是一个 string set<string>::key_type v2; // v2 是一个 string map<string, int>::value_type v3; // v3 是一个 pair<const string, int> map<string, int>::key_type v4; // v4 是一个 string map<string, int>::mapped_type v5; // v5 是一个int 像这种类型，也不必全部记住，用一些智能提示的工具如 vs，就能看一个类型到底是什么类型。 11.3.1 关联容器迭代器 ​ 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。对 map 而言，value_map 是一个 pair 类型，其 first 成员保存 const 的关键字，second 成员保存值： auto map_it = word_count.begin(); cout << map_it->first; // 打印此元素的关键字 cout << \" \" << map_it->second; // 打印此元素的值 map_it->first = \"new key\"; // 错误，关键字是const的 ++map_it->second; // 正确：我们可以通过迭代器改变元素 set 的迭代器是 const ​ 虽然 set 类型同时定义了 iterator 和 const_iterator 类型，但两种类型都只允许只读访问 set 中的元素。与不能改变一个 map 元素的关键字一样，一个 set 中的关键字也可以是 const 的。可以用一个 set 迭代器来读取元素的值，但不能修改。 set<int> iset = {0,1,2,3,4,5,6,7,8, 9}; set<int>::iterator set_it = iset.begin(); if(set_it != iset.end()) { *set_it = 42; // 错误，不允许写 cout << *set_it<< endl; // 正确 } 遍历关联容器 使用 begin 和 end 来操作遍历： auto map_it = word_count.cbegin(); while(map_it != word_count.cend()) { cout << map_it->first << \" occurs \" << map_it->second << \" times\" << endl; ++map_it; // 递增迭代器，移动到下一个元素 } 11.3.2 添加元素 对 map 和 set 而言，插入一个已存在关键字不会产生任何影响。 vector<int> ivec = {2, 4, 6, 8, 2, 4, 6, 8}; set<int> set2; set2.insert(ivec.cbegin(), ivec.cend()); // set2 有四个元素 set2.insert({1,3,5,7,1,3,5,7}); // 在 set2 = {2,4,6,8}的基础上扩充为set2={1,2,3,4,5,6,7,8} 如果这个时候打印set2的话，发现输出的是： 1 2 3 4 5 6 7 8 从新排序了，看了每次插入时，内部都会进行排序。（可能用的是平衡二叉树） 如果用map来操作的话，也是会重新排序的（unordered_map 则不同）： map<int, string> imap; imap.insert(make_pair(10, \"test10\")); imap.insert(make_pair(5, \"slsie5\")); imap.insert(make_pair(109, \"test109\")); imap.insert(make_pair(11, \"test11\")); for (auto i : imap) { cout << i.first << \" \" << i.second << endl; } 5 slsie5 10 test10 11 test11 109 test109 几种插入操作： word_count.insert({word, 1}); word_count.insert(make_pair(word, 1)); word_count.insert(pair<string, int>(word, 1)); word_count.insert(map<string, size_t>::value_type(word, 1)); 11.3.3 删除元素 ​ 关联容器定义了三个版本的 erase： 版本 c.erase(k) 从 c 中删除每个关键字为 k 的元素。返回一个 size_type 值，指出删除的元素的数量。 c.erase(p) 从 c 中删除迭代器 p 指定的元素。p 必须执行 c 中一个真实元素，不能等于 c.end()。返回一个指向 p 之后元素的迭代器，若 p 指向 c 中的尾元素，则返回 c.end()。 c.erase(b, e) 删除迭代器对 b 和 e 所表示范围中的元素。返回 e。 对于 map.erase，返回值要么是 0 要么是 1，而对于 multimap，可能返回 一个大于1的正整数。 11.3.4 map 的下标操作 ​ map 和 unordered_map 容器提供了下标运算符和一个对应的 at 函数。set 类型（关键字即是值本身）和 multimap 或者一个 unorder_map 进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。 ​ map 下标运算符接受一个索引，获取与此关键字相关联的值。但是如果关键字不存在 map 中，会为它创建一个元素并插入 map 中，关联值将进行值初始化。 map<string, size_t> word_count; word_count[\"Anna\"] = 1; 在 word_count 中搜索关键字为 Anna 的元素，未找到。 将一个新的关键字-值对插入到 word_count 中。关键字是一个 const string，保存 Anna。值进行初始化，在本列中意味着值为 0. 提取出新插入的元素，并将值 1 赋值给它。 由于下标运算符可能插入一个新元素，我们只可以对非 const 的 map 使用下标操作。 下标操作 c[k] 返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化。 c.at(k) 访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常。 unordered_map<int, string> imap; imap.insert(make_pair(10, \"test10\")); imap.insert(make_pair(5, \"slsie5\")); imap.insert(make_pair(109, \"test109\")); imap.insert(make_pair(11, \"test11\")); try { auto x = imap.at(12); } catch (out_of_range ex) { cout << ex.what() << endl; // 捕获异常 } return 0; 使用下标操作的返回值 ​ map 的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通常情况下，解引用一个迭代器符返回的类型与下标运算符返回的类型是一样的。当对一个 map 进行下标操作时，会获得一个 mapped_type 对象；当解引用一个 map 迭代器时，会得到一个 value_type 对象。 ​ 与其他下标运算符相同的是，map 的下标运算符返回一个左值。由于返回的是一个左值，所以我们即可以读也可以写元素： cout << word_count[\"Anna\"]; // 用 Anna 作为下标提取元素；会打印出 1 ++ word_count[\"Anna\"]; // 提取元素，将其增1 cout << word_count[\"Anna\"]; // 提取元素并打印它；会打印出 2 11.3.5 访问元素 ​ 关联容器提供多种查找一个指定元素的方法。 查找操作 c.find(k) 返回一个迭代器，指向第一个关键字为 k 的元素，若 k 不在容器中，则返回尾后迭代器。 c.count(k) 返回关键字等于 k 的元素的数量。对于不允许重复关键字的容器，返回值永远是 0 或 1 c.lower_bound(k) 返回一个迭代器，指向第一个关键字不小于 k 的元素 c.upper_bound(k) 返回一个迭代器，指向第一个关键字大于 k 的元素 c.equal_range(k) 返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 的两个成员均等于 c.end() 在 multimap 或 multiset 中查找元素 ​ 在multimap 或 multiset 可能存在着多个 key 一样的键值对，这些 key 相同的键值对在容器中是相邻存储的。意味着如果我们要访问某一个关键字的内容，只需要找出第一个键值对的迭代器，然后在该迭代器的基础上执行 ++，就可以遍历某一个关键字的所有值： string search_item(\"Alain de Botton\"); auto entries = authors.count(search_item); // map 中key 为 search_item 的个数 auto iter = authors.find(search_item); // 获取第一个 key 为 search_item 的pair while(entries) { cout << iter->second << endl; ++iter; -- entries; } 使用 lower_bound 和 upper_bound 查找元素 lower_bound 接受一个关键字，如果关键字在容器中，返回的迭代器指向第一个具有给定关键字的元素。 upper_bound 接受一个关键字，如果关键字在容器中，返回的迭代器指向最后一个匹配给定关键字的元素之后的位置。 如果元素不存在容器中，两个函数返回相等的迭代器——指向一个不影响排序的关键字插入位置。（不一定返回尾后迭代器） for(auto beg= authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg) { cout << beg->second << end; } equal_range 函数 ​ 此函数接受一个参数（关键字），返回一个迭代器 pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。 for(auto pos = authors.equal_range(search_item); pos.first != pos.second; ++pos.first) { cout << pos.first->second << endl; } 11.3.6 一个单词转换的map 略。（待补充）"
  },
  "Languages/Chapter11/11.4.html": {
    "href": "Languages/Chapter11/11.4.html",
    "title": "11.4 无序容器",
    "keywords": "11.4 无序容器 ​ 无序关联容器不是使用比较运算符来组织元素的，而是使用一个哈希函数和关键字类型的 == 运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器就比较有用了。 11.3节内容对一个 map<int, string> 对象进行插入时，用非传统for循环遍历，得到的结果是按key进行了排序的一个输出结果，那么无序容器map是很可能是按照插入的先后顺序进行排序的。 unordered_map<int, string> imap; imap.insert(make_pair(10, \"test10\")); imap.insert(make_pair(5, \"slsie5\")); imap.insert(make_pair(109, \"test109\")); imap.insert(make_pair(11, \"test11\")); for (auto i : imap) { cout << i.first << \" \" << i.second << endl; } 输出结果： 10 test10 109 test109 5 slsie5 11 test11 管理桶 ​ 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶上。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在同一个桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希哈数的质量和桶的容量和大小。 ​ 对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量的比较操作。 管理桶操作 c.bucket_count() 正在使用的桶的数目 c.max_bucket_count() 容器能容纳的最多的桶的数量 c.bucket_size(n) 第 n 个桶中有多少个元素 c.bucket(k) 关键字为 k 的元素在哪个桶中 local_iterator 可以用来访问桶中元素的迭代器类型 const_local_iterator 桶迭代器的 const 版本 c.begin(n)，c.end(n) 桶 n 的首元素迭代器和尾后迭代器 c.cbegin(n)，c.cend(n) 桶 n 的首元素迭代器和尾后迭代器，返回 const_local_iterator c.load_factor() 每个桶的平均元素数量，返回 float 值 c.max_load_factor() c 试图维护的平均桶大小，返回 float 值。c 会在需要时添加新的桶，以使得 load_factor<=max_load_factor c.rehash(n) 重组存储，使得 bucket_count >= n 且 bucket_count > size/ max_load_factor c.reverse(n) 重组存储，使得 c 可以保存 n 个元素且不必rehash 无序容器对关键字类型的要求 ​ 默认情况下，无序容器使用关键字类型的 == 运算符来比较元素，它们还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括 string 定义了 hash。因此我们可以直接定义关键字是内置类型（包括指针类型）、string 还是智能指针类型的无序容器。 ​ 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，必须提供自己的hash 模板版本。 ​ 我们不适用默认的 hash，而是用另外一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将 Sales_data 用作关键字，我们需要提供函数来替代 == 运算符和哈希值计算函数。 size_t hasher(const Sales_data& sd) { return hash<string>()(sd.isbn()); } bool eqOp(const Sales_data& lhs, const Sales_data& rhs) { return lhs.isbn() == rhs.isbn(); } 这里 hasher 函数使用标准库 hash 类型对象来计算 ISBN 成员的哈希值，该 hash 类型简历在 string 类型之上。类似的。eqOp 函数通过比较 ISBN 号来比较两个 Sales_data。 using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>; SD_multiset bookstore(42, hasher, eqOp);"
  },
  "Languages/Chapter12/12.1.html": {
    "href": "Languages/Chapter12/12.1.html",
    "title": "12.1 动态内存和智能指针",
    "keywords": "12.1 动态内存和智能指针 先了解几个名词。 静态内存：操作系统保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量。 栈内存：保存定义在函数内的非 static 对象。 堆内存：动态分配的对象的存储地区。 操作系统分配在静态或栈内存中的对象由编译器自动创建和销毁。栈对象仅在其定义的程序块运行时才存在。static 对象在使用之前分配，在程序结束时销毁。 存放在堆内存的对象，由程序控制，如果不在需要这些对象，就应该手动显示释放掉，否则就存在内存泄漏。 动态内存容易出现的问题： 对象不需要了忘记显示释放。 对象还需要，但是提前释放了，等到再去访问，就出现非法访问的情况。 为了解决上述问题，新的标准库引入了两种智能指针类型来管理动态对象。智能指针负责自动释放所指向的对象。 智能指针 shared_ptr 允许多个指针指向同一个对象 unique_ptr “独占” 所指向的对象 weak_ptr 弱引用，指向 shared_ptr 所管理的对象。 上述三种指针都定义在头文件 memory 中。 12.1.1 shared_ptr 类 智能指针是一种模板。创建智能指针时，必须提供额外的信息——指针可以指向的类型。 shared_ptr<string> p1; // 指向 string shared_ptr<list<int>> p2; // 指向int的list 默认初始化的智能指针中保存着一个空指针。 智能指针解引用得到其指向的对象： if(p1 && p1->empty()) *p1 = \"Hi\"; 操作表： Shared_ptr 和 unique_ptr 支持的操作 shared_ptr sp 空智能指针，可以指向类型为T的对象 unique_ptr up 空智能指针，可以指向类型为T的对象 p 将 p 用作一个条件判断，若 p 指向一个对象，则为true *p 解引用 p，获得它返回的对象 p->mem 等价于(*p).mem，mem是p指向对象的一个成员 p.get() 返回 p 中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 swap(p, q) 交换p 和 q中的指针 p.swap(q) 交换p 和 q中的指针 Shared_ptr 独有的操作 make_shared (args) 返回一个 shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 shared_ptr p (q) p 是 shared_ptr q 的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* p = q p 和 q 都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放。 p.unique() 若 p.use_count() 为1，返回true；否则返回false。 p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试。 make_shared 函数 ​ 最安全的分配和使用动态内部的方法是调用一个名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。 ​ 使用 make_shared 时，必须指定想要创建的对象的类型。定义方式与模板类型相同，在函数名之后跟一个尖括号，在其中给出类型： // 指向一个值为 42 的 int 的 shared_ptr shared_ptr<int> p3 = make_shared<int>(43); // 指向一个值为 “9999999999” 的string shared_ptr<string> p4 = make_shared<string>(10, '9'); // 指向一个值初始化的int，值为0 shared_ptr<int> p5 = make_shared<int>(); 类似容器的 emplace 成员，make_shared 用其参数来构造给定类型的对象。 shared_ptr 的拷贝和赋值 ​ 当进行拷贝或赋值操作时，每个shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象： auto p = make_shared<int>(42); // 此时 p指向对象只有一个引用者 auto q(p); // 此时 p 和 q指向相同对象，此对象有两个引用者 ​ 我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个 shared_ptr，计数器都会递增。列如，当用一个 shared_ptr 初始化另一个 shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁（列如一个局部的shared_ptr 离开其作用域时），计数器就会递减。 ​ 当一个 shared_ptr 的计数器为0时，他就会自动释放自己所管理的对象： auto r= make_shared<int>(42); // r 指向的对象此时只有一个引用者 r = q; // 将 q 赋值给r，r 指向另一地址 // 递增q指向对象的引用计数 // 递减r 原来指向对象的引用计数 // r 原来指向的对象已经没有引用者，会自动释放 shared_ptr 自动销毁所管理的对象 shared_ptr 的析构函数会递减它所指向对象的引用计数。如果引用计数变为 0，shared_ptr 的析构函数就会销毁对象，并释放它占用的内存。 由于在最后一个 shared_ptr 销毁前内存都不会释放，保证 shared_ptr 在无用之后不再保留就非常重要。shared_ptr 在无用之后仍然保留的一种情况是：将 shared_ptr 存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，应该确保用 erase 删除那些不再需要的 shared_ptr 元素。 class Student { public: string Name; int Age; Student() = default; Student(string name, int age) :Name(name), Age(age) {} ~Student() { cout << \"Student destroy\" << endl; } }; shared_ptr<Student> factory(string name, int age = 18) { return make_shared<Student>(name, age); } void testF() { vector<shared_ptr<Student>> svec = { make_shared<Student>(\"vincent\", 16), make_shared<Student>(\"clock\", 12), make_shared<Student>(\"ted\", 16), make_shared<Student>(\"smith\", 19) }; sort(svec.begin(), svec.end(), [](const shared_ptr<Student>& s1, const shared_ptr<Student>& s2) { return s1->Age < s2->Age; }); // 打印 for (auto s : svec) { cout << \" Name: \" << s->Name << \" age: \" << s->Age << endl; } } int main(int argc, char* argv[]) { testF(); return 0; } 这里看了一下，最后的输出信息显示所有的智能指针指向的对象都清除了： Name: clock age: 12 Name: vincent age: 16 Name: ted age: 16 Name: smith age: 19 Student destroy Student destroy Student destroy Student destroy 也就是说，只要容器能够被销毁，那么智能指针也会随着销毁。没必要担心，可能文中说的是一个常驻的容器吧。 12.1.2 直接管理内存 new 关键字 分配空间使用 new： // 分配空间但是未初始化 int* pi = new int; string* ps = new string; // 最后分配空间就进行初始化 int* pi = new int(1024); string* ps = new string(10, '9'); vector<int>* pv = new vector<int>{1,2,3,4,5,6,7,8,9}; // 动态分配空间进行值初始化 int* pi = new int(); string* ps = new string(); 关于使用 auto，编译器会从初始化器来推断我们想要的分配对象的类型，但是只接受单一初始化器： auto p1 = new auto{obj}; auto p2 = new auto{a,b,c}; // 错误 如果obj 是 int，那么 p1 是一个 int*；如果 obj 是一个string，那么 p1 是 string*。 动态分配的 const 对象 const int* pci = new const int(1024); const string* pcs = new const string(\"112\"); 如果某个电脑上的内存耗尽了，使用 new 就会抛出一个 bad_alloc 异常，要想不抛出异常，则请使用 定位new ： int* p2 = new (nothrow) int; // 分配失败的话，会返回一个空指针 delete 关键字 new 了之后，需要手动 delete 掉已经分配的空间，否则可能出现内存泄漏的情况。而且要养成 delete 之后将指针指向 nullptr。 12.1.3 shared_ptr 和 new 结合使用 shared_ptr<double> p1; shared_ptr<int> p2(new int(42)); 接受指针参数的智能指针构造函数是 explicit 的。 shared_ptr p1 = new int(1024); // 错误 shared_ptr p2(new int(1024)); // 正确 shared_ptr<int> clone(int p) { return new int(p); // 错误 // retuern shared_ptr<int>(new int(p)); // 正确 } 不要混合使用普通指针和智能指针 int *x(new int(1024)); // x 是一个普通指针 process(x); // 错误，x不能转换为 shared_ptr<int> process(make_shared<int>(x)); // 合法，但是这个语句会将 x 指向的内存销毁 int j = *x; // x已经被销毁，未知访问 小心使用 get 函数 shared_ptr<int> p(new int(42)); int* q = p.get(); // 不要让 q 被销毁 { shared_ptr<int>(q); } // 出了作用域，q 被销毁了，此时 q 也是一个悬空指针 int foo = *p; // 未知访问咯 reset 函数 reset 会更新引用计数，如果需要，会释放 p 指向的对象。reset 成员经常和 unique 一起使用，来控制多个 shared_ptr 共享的对象。 if(!p.unique()) { p.reset(new string(*p)); // 分配新的拷贝 } *p += newVale; 12.1.4 智能指针和异常 如果一个函数内部使用的是智能指针，那么函数执行过程中是发生了异常还是正常结束，都会对其申请的空间进行引用计数的递减甚至销毁（引用计数为零）。但是如果是直接内存管理，可能发生异常或者正常返回的代码路径没有走 delete 的代码，就存在内存泄漏的情况。 智能指针和哑类 有些类没有的定义析构函数来释放这些资源的类，可能会遇到与使用动态内存相同的错误，比如连接数据库。 struct destination; struct connection; connection connect(destination*); void disconnect(connection); void f(destination& d) { connection c = connect(&d); // 退出 f 函数，忘记关闭连接，资源没有得到释放 } 正确的做法是，使用智能指针： void f(destination& d) { connection c = connect(&d); shared_ptr<connection> p(&c, end_connection); } // 代替了智能指针的 delete void end_connection(connection *p){ disconnect(*p); } 12.1.5 unique_ptr ​ 一个 unique_ptr 拥有 它所指向的对象。与 shared_ptr 不同，某个时刻只能有一个 unique_ptr 指向一个给定的对象。当 unique_ptr 被销毁时，它所指向的对象也被销毁。 ​ unique_ptr 没有类似make_shared 函数返回一个 unique_ptr 对象，所以在定义时必须将其绑定到一个 new 返回的指针上。 unique_ptr<double> p1; // 可以指向一个 double的 unique_ptr unique_ptr<int>p2(new int(42)); // p2 指向一个值为 42 的 int unique_ptr 不支持普通的拷贝或赋值操作： unique_ptr<string> p1(new string(\"Stegosaurus\")); unique_ptr<string> p2(p1); // 错误 unique_ptr<string> p3; p3 = p2; // 错误 unique_ptr 操作 unique_ptr u1 空 unique_ptr，可以指向类型为T 的对象。u1 会使用 delete 来释放它的指针； unique_ptr<T,D> u2 u2会使用一个类型为 D 的可调用对象来释放它的指针 unique_ptr<T, D> u(d) 空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete u= nullptr 释放 u 指向的对象，将 u 置为空 u.release() u 放弃对指针的控制权，返回指针，并将 u 置空 u.reset() 释放 u 指向的对象 u.reset(q) 如果提供了内置指针 q，令 u 指向这个对象；否则将 u 置空 u.reset(nullptr) release 转移指针控制权 unique_ptr<string> p2(p1.release()); // release 将 p1 置为空，指针控制权转给 p2 unique_ptr<string> p3(new string(\"Trex\")); p2.reset(p3.release()); // reset 释放了 p2 原来指向的内存 传递 unique_ptr 参数和返回 unique_ptr 某些情况下可以进行 unique_ptr 的拷贝： unique_ptr<int> clone(int p) { return unique_ptr<int>(new int(p)); } unique_ptr<int> clone(int p) { unique_ptr<int> ret(new int(p)); return ret; } 向 unique_ptr 传入删除器 void f(destination& d) { connection c = connect(&d); unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection); // 当f退出时，正确关闭连接 } 12.1.6 weak_ptr ​ weak_ptr 是一种不控制所指对象生成期的智能指针，它指向由一个 shared_ptr 管理的对象。讲一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象还是会被释放。 weak_ptr 操作 weak_ptr w 空 weak_ptr 可以指向类型为 T 的对象 weak_ptr w(sp) 与 shared_ptr sp 指向相同的对象 weak_ptr。T 必须能转换为 sp 可以指向的类型 w = p; weak_ptr w(sp) 等价 w.reset() 将 w 置空 w.use_count() 与 w 共享对象的 shared_ptr 的数量 w.expired() 若 w.use_count() 为 0，返回 true；否则返回 false w.lock() 如果 expired 为 true，返回一个空 shared_ptr；否则返回一个指向 w的独享的 shared_ptr。 因此在访问 weak_ptr 指向对象时，应该使用 lock 来操作： if(shared_ptr<int> np == wp.lock()) { // ... }"
  },
  "Languages/Chapter12/12.2.html": {
    "href": "Languages/Chapter12/12.2.html",
    "title": "12.2 动态数组",
    "keywords": "12.2 动态数组 12.2.1 new 和数组 int* pia = new int[get_size()]; // pia 指向第一个 int 这里看得出来，动态申请一个数组时，方括号中的数值不必是常量的，但是必须是整数。 使用类型别名申请一个新的数组 typedef int arrT[42]; int* p = new arrT; // 申请一个 42个 int 的数组，p指向第一个int // 等价于 int* p = new int[42]; 分配一个数组会得到一个元素类型的指针 new T[] 通常称为 “动态数组”。当用一个 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。所以不能对动态数组调用 begin 或 end。也不能使用范围 for 语句处理。 初始化动态分配对象的数组 int* pia = new int[10]; // 10个未初始化的int int* pia2 = new int[10](); // 10个值初始化为0 的int string* psa = new string[10]; // 10个空string string* psa2 = new string[10](); // 10个空string int* pia3 = new int[10]{1,2,3,4,5,6,7,8,9,10}; string* psa3 = new string[10]{\"a\",\"an\",\"the\",string(3,'x')}; // 前4个用给定的初始化器初始化 动态分配一个空数组是合法的 size_t n=get_size(); int* p = new int[n]; for(int* q = p; q != p+n;q++) { // todo: visit array } 如果n为零，也是可以编译通过的，但是如果显示声明一个零长度的数组，是错误的。 释放动态数组 delete []pa; // pa 指向一个动态分配的数组或为空 特殊的是，数组中的元素按逆序被销毁，显示尾元素销毁，然后从尾元素一个一个到头元素。 智能指针和动态数组 标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。 unique_ptr<int[]> up(new int[10]); up.release(); // 自动调用 delete[销毁指针] 而访问up时，不能使用 . 或者 -> 去访问，而是用下标： up[1] = 10; shared_ptr 不支持直接管理动态数组。如果非要使用 shared_ptr，需要自定义delete[]： shared_ptr<int> sp(new int[10], [](int* p){delete []p;}); sp.reset(); // 使用我们提供的lambda 释放数组 而且 shared_ptr 不支持下标访问，只能通过 get 来访问数组中的元素： for(size_t i = 0; i != 10; ++i) *(sp.get() + i) = i; 12.2.2 allocator 类 ​ new 有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete 将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为这种情况下，我们几乎肯定知道对象应该有什么值。 ​ 当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（付出一定开销）。 一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。 string* const p = new string[n]; // 构造 n 个空string string s; string *q = p; while(cin >> s && q!=p+n) { *q++ = s; } const size_t size = q - p; delete[]p; // p 指向一个数组，要使用 delete[] new 表达式分配并初始化了 n 个 string。但是，我们可能不需要 n 个 string，少量 string 可能就足够了。这样，我们就可能创建了一些永远用不到的对象。而且，对于那些确实要使用的对象，我们也在初始化之后立即赋予它们新值。每个使用到的元素都被赋值了两次：第一次是在默认初始化时，随后是在赋值时。 ​ 更重要的是，那些没有默认构造函数的类就不能动态分配数组了。 allocator 标准库 allocator 类定义在头文件 memory 中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。 操作 allocator a 定义了一个名为 a 的 allocator 对象，它可以为类型为 T 的对象分配内存。 a.allocate(n) 分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象 a.deallocate(p, n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由 allocator 返回的指针，且 n 必须是 p 创建时所要求的大小啊。在调用 deallocator 之前，用户必须对每个在这块内存中创建的对象调用 destroy a.construct(p, args) p 必须是一个类型为 T* 的指针，指向一块原始内存；args 被传递给类型为T的构造函数，用来在 p 指向的内存中构造一个对象 a.destroy(p) p 为 T* 类型的指针，此算法对 p 指向的对象执行析构函数 allocator 分配为构造的内存 ​ allocator 分配的内存是未构造的。我们按需要在此内存中构造对象。在新标准库中，construct 成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素，额外参数用来初始化构造的对象。类似 make_shared 的参数，这些额外参数必须是与构造的对象的类型相匹配的合法的初始化器。 auto q = p; // q 指向最后构造的元素之后的位置 alloc.construct(q++); // *q为空字符串 alloc.construct(q++, 10, 'c'); // *q 为 cccccccccc alloc.construct(q++, \"hi\"); // *q 为 hi! 当用完对象后，必须对每个构造的元素调用 destroy 来销毁它们。函数 destroy 接受一个指针，对指向的对象执行析构函数。 while(q!=p) { alloc.destroy(--q); // 释放真正够早的string } 一旦元素被销毁后，就可以重新使用这部分内存来保存其他string，也可以释放归还给系统。释放内存通过调用 deallocate来完成。 alloc.deallocate(p, n); 传递给 deallocte 的指针不能为空，它必须指向由 allocate 分配的内存。而且传递给 deallocate的大小参数必须与调用 allocated 分配内存时提供的大小参数具有一样的值。 拷贝和填充未初始化内存的算法 ​ 标准库还未 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象。 算法 uninitialized_copy(b, e, b2) 从迭代器 b 和 e 指出的 输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中。b2 指向的内存必须足够大，能容纳输入序列中元素的拷贝。 uninitialized_copy_n(b, n, b2) 从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的内存中 uninitialized_fill(b, e, t) 在迭代器 b 和 e 指定的原始内存范围中创建对象，对象的值均为 t 的拷贝 uninitialized_fill_n(b, n, t) 从迭代器 b 指向的内存地址开始创建 n 个对象。b 必须指向足够大的未构造的原始内存，能够容纳给定数量的对象"
  },
  "Languages/Chapter13/13.1.html": {
    "href": "Languages/Chapter13/13.1.html",
    "title": "13.1 拷贝、赋值与销毁",
    "keywords": "13.1 拷贝、赋值与销毁 13.1.1 拷贝构造函数 拷贝构造函数：一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。 class Foo{ public: Foo(); // 默认构造函数 Foo(const Foo&); // 拷贝构造函数 } 拷贝构造函数的第一个参数必须是引用类型。拷贝构造函数在几种情况下都会被隐式地使用。拷贝构造函数通常不应该是 explicit 的。 合成拷贝构造函数 如果没有为一个类定义一个拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使定义了其他构造函数，编译器也会为类合成一个拷贝构造函数。 合成拷贝构造函数的作用是将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非 static 成员拷贝到正在创建的对象中。 class C13 { public: int x; int y; }; C13 c0; C13 c1; c0.x = 10; c0.y = 11; c1 = c0; // 使用了合成拷贝构造函数 cout << c1.x << \" \" << c1.y; 输出：10 11 每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。 class Sales_data{ public: Sales_data(const Sales_data&); private: std::string bookNo; int units_sold = 0; double revenue = 0.0; }; // 与 Sales_data 的合成的拷贝构造函数等价 Sales_data::Sales_data(const Sales_data& orig):bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue) { } string dots(10, '.'); // 直接初始化 string s(dots); // 直接初始化 string s2 = dots; // 拷贝初始化 string null_book = \"9-999-999999-9\"; // 拷贝初始化 string nines = string(100, '9'); // 拷贝初始化 拷贝初始化除了 = 定义变量时发生，以下情况也会发生拷贝初始化： 将一个对象作为实参传递个一个非引用类型的形参。 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。 某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器是调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对，用 emplace 成员创建的元素都进行直接初始化。 参数和返回值 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。当一个函数具有非引用的返回类型时，返回值会被用来初始化调用放的结果。 所以拷贝构造函数自己的参数必须是引用类型的，不然，其参数不是引用类型的，为了调用拷贝构造函数，必须拷贝其形参，但为了拷贝实参，又调用拷贝构造函数，成了死循环。 练习 练习 13.4 Point::Point(const Point& p) { x = p.x; y = p.y; } Point global; Point foo_bar(Point arg) // 这里算一次 { Point local = arg, * heap = new Point(global); // 这一行有两次 *heap = local; // 这个地方是拷贝赋值运算符，即 operator= 函数 Point pa[4] = { local, *heap }; // 这里算两次 return *heap; // 这里算一次 } // 总共6次 13.1.2 拷贝赋值运算符 ​ 与类控制其对象如何初始化一样，类也可以控制其对象如何赋值： Sales_data trans, accum; trans = accum; // 使用 Sales_data 的拷贝赋值运算符 重载赋值运算符 ​ 重载运算法本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 operator= 函数，这个函数也有参数列表和返回类型。 ​ 重载运算符的参数表示运算符的运算对象。某些运算符包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对于一个二元运算符，例如赋值运算符，其右侧运算啊对象作为显示参数传递。 class C13 { public: int x; int y; // 重载自增运算符 C13& operator++() { x++; y++; return *this; } }; C13 c0; c0.x = 10; c0.y = 11; cout << c0.x << \" \" << c0.y << endl; // 自增后 ++c0; cout << c0.x << \" \" << c0.y; // 输出： // 10 11 // 11 12 合成拷贝赋值运算符 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非处于此目的，它会将右侧运算对象的每个非 static 成员赋予左侧运算符对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。 Sales_data::operator=(const Sales_data& rhs) { bookNo = rhs.bookNo; // 调用string::operator= units_sold= rhs.units_sold; revenue = rhs.revenue; return *this; } 13.1.3 析构函数 析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。 析构函数完成什么工作 首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 在一个析构函数中，不存在初始化列表的东西，也不接受参数。成员销毁时放生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员不需要做什么。 什么时候调用析构函数？ 无论何时一个对象被销毁，就会自动调用其析构函数： 变量在离开其作用域时被销毁。 当一个对象被销毁时，其成员被销毁。 容器被销毁时，其元素被销毁。 对于动态分配的对象，当对指向它的指针应用 delete 时，被销毁。 对于临时对象，当创建它的完整表达式结束时被销毁。 13.1.6 阻止拷贝 如果我们不显式写拷贝赋值运算符函数，系统还是给我们一个默认的拷贝赋值运算符函数。当我们不希望这个类型的对象被拷贝时，可以用delete来操作： struct NoCopy{ Nocopy()=default; NoCopy(const NoCopy&)= delete; // 阻止拷贝 NoCopy& operator=(const NoCopy&) = delete; // 阻止赋值 ~NoCopy()=default; } 不能对析构函数使用delete。"
  },
  "Languages/Chapter13/13.2.html": {
    "href": "Languages/Chapter13/13.2.html",
    "title": "13.2 拷贝控制和资源管理",
    "keywords": "13.2 拷贝控制和资源管理 类的行为看起来像一个值： 当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响。 类的行为看起来像一个指针： 当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象。 class HasPtr { public: int x; int y; string* ptr; HasPtr(string p, int ix, int iy) { ptr = new string(p); x = ix; y = iy; } ~HasPtr() { delete ptr; } }; int main(int argc, char* argv[]) { HasPtr p(string(\"something\"), 1, 2); HasPtr x = p; *(x.ptr) = string(\"test\"); cout << *(p.ptr) << endl; cout << *(x.ptr) << endl; return 0; } 就像上面的代码一样，当执行 x=p 时，由于使用的是合成的拷贝赋值函数，x对象的成员ptr和p对象的成员ptr都指向了同一个对象，当执行析构函数时，ptr指向的对象执行了delete两次，所以会有异常。 这种情况应该要对赋值运算符函数进行一个显式定义的，将ptr进行一次拷贝。 // 拷贝构造函数 HasPtr(const HasPtr& hp) { this->x = hp.x; this->y = hp.y; this->ptr = new string(*(hp.ptr)); } // 拷贝赋值函数 HasPtr& operator= (const HasPtr& hp) { // 赋值前先检查一下原对象的ptr是否已经指向一个对象，如果有，则释放 auto news = new string(*(hp.ptr)); if(ptr) delete ptr; ptr = news; this->x = hp.x; this->y = hp.y; return *this; } 13.2.1 行为像值的类 为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于 ps 指向的 string，每个 HasPtr 对象都必须有自己的拷贝。所以定义类时需要： 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针 定义一个析构函数来释放string 定义一个拷贝赋值运算符来释放当前的 string，并从右侧运算对象拷贝 string 如果像下面这样赋值，可能导致自己给自己赋值时，ptr指向未知。 // 拷贝赋值函数 HasPtr& operator= (const HasPtr& hp) { // 赋值前先检查一下原对象的ptr是否已经指向一个对象，如果有，则释放 if(ptr) delete ptr; ptr = news; this->x = hp.x; this->y = hp.y; ptr = new string(*(hp.ptr)); return *this; } 13.2.2 定义行为像指针的类 ​ 对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受 string 参数的构造函数分配的内存。但是构造函数不能单方面地释放关联的 string，因为其他对象和当前对象的 string 是指向同一个内存的，只有当最后一个对象释放了，才能 delete string。 我们可以用 shared_ptr 来处理，但是也可以不用 shared_ptr。 使用引用计数 引用计数的共享方式如下： 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将引用计数初始化为1。 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。 析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的个共享状态没有用户了，拷贝赋值运算符就必须销毁。 计数器在存放在什么地方？ 计数器不能直接作为 HasPtr 对象的成员。 HasPtr p1(\"HiYa\"); HasPtr p2(p1); // p1 和 p2 指向同一个 string HasPtr p3(p1); // p1,p2,p3指向同一个 string 解决：将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。 定义一个使用引用计数器的类 class HasPtr{ public: HasPtr(const std::string& s= std::string()):ps(new std::string(s)), i(0), use(new std::size_t(1)) {} HasPtr(const HasPtr& p):ps(p.ps),i(p.i),use(p.use){++*use;} HasPtr& operator= (const HasPtr&); private: std::string* ps; int i; std::size_t* use; // 记录有多少个对象共享 *ps 成员 } 类指针的拷贝成员 “篡改” 引用计数 ​ 当拷贝或赋值一个 HasPtr 对象时，我们希望副本和原对象都指向相同的 string。即当拷贝一个 HasPtr 时，我们将拷贝 ps 本身，而不是 ps 指向的 string。当我们进行拷贝时，还会递增该 string 关联的计数器。 当析构时，不能简单的将指针 delete掉，而是进行递减，如果发现是最后一个对象了，就delete: HasPtr::~HasPtr() { if(--*use == 0) { delete ps; // 释放 string 内存 delete use; // 释放计数器内存 } } 拷贝赋值运算符 拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数，并递减左侧运算对象的引用计数，在必要时释放使用的内存。 还要处理赋值运算符的自赋值运算。 HasPtr& HasPtr::operator=(const HasPtr& hp) { ++(*hp.use); // 右侧运算符对象的引用计数自增 if(--*use == 0) // 递减本对象的引用计数，必要时释放空间 { delete ps; delete use; } ps= hp.ps; i = ph.i; use = hp.use; return *this; }"
  },
  "Languages/Chapter13/13.3.html": {
    "href": "Languages/Chapter13/13.3.html",
    "title": "13.3 交换操作",
    "keywords": "13.3 交换操作 ​ 除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数。对于那些与重排元素顺序的算法一起使用，定义 swap 是非常重要的。这类算法在需要交换两个元素时会调用 swap 。 ​ 如果一个类定义了自己的 swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的 swap。虽然与往常一样我们不知道 swap 是如何实现的，但是理论上很容易理解，为了交换两个对象我们需要进行一次拷贝和两次赋值。 HasPtr temp= v1; v1= v2; v2 = temp; 这段代码将原来 v1 中的 string 拷贝了两次——第一次是 HasPtr 的拷贝构造函数将 v1 拷贝给 temp，第二次是赋值运算符将 temp 赋予 v2。将 v2 赋予 v1 的语句还拷贝了原来 v2 中的 string。拷贝一个类值的 HasPtr 会分配一个新 string 并将其拷贝到 HasPtr 指向的位置。 ​ 然而这些操作看起来是不必要的。交换时，我们希望交换的是指针，而不是新分配的副本。 string* temp = v1.ps; v1.ps = v2.ps; v2.ps = temp; 编写自己的 Swap 函数 class HasPtr{ friend void swap(HasPtr&, HasPtr&); // ... }; inline void swap(HasPtr& lhs, HasPtr& rhs) { using std::swap; swap(lhs.ps, rhs.ps); // 交换指针，而不是 string 数据 swap(lhs.i, rhs.i); // 交换成员 } 在赋值运算符中使用 swap 定义 swap 的类通常用 swap 来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换： HasPtr& HasPtr::operator=(HasPtr rhs) { swap(*this, rhs); // rhs 现在指向本对象曾经使用的内存 return *this; // rhs被销毁，从而delete 了 rhs中的指针。 }"
  },
  "Languages/Chapter13/13.4.html": {
    "href": "Languages/Chapter13/13.4.html",
    "title": "13.4 拷贝控制示例",
    "keywords": "13.4 拷贝控制示例 两个类：Message 和 Folder，分别表示电子邮件消息和消息目录。 每个 Message 对象可以出现在多个 Folder 中。但是任意给定的 Message 的内容只有一个副本。因此，如果一条 Message 内容被改变，则可以从它所在的任何 Folder 来浏览此 Message 时，都能看到改变后的内容。 为了记录 Message 位于哪些 Folder 中，每个 Message 都会保存一个它所在 Folder 的指针 set，同样的，每个 Folder 都保存一个它包含的 Message 的指针的 set。 Message 类提供 save 和 remove 操作，来向一个给定 Folder 添加一条 Message 或是从中删除一条 Message。为了创建一个新的 Message ，我们会指明消息内容，但不会指出 Folder。为了将一条 Message 放到一个特定 Folder 中，我们必须调用 save。 当我们拷贝一个 Message 时，副本和原对象将是不同的 Message 对象，但两个 Message 都出现在相同的 Folder 中。因此，拷贝 Message 的操作包括消息内容和 Folder 指针 set 的拷贝。而且，我们必须在每个包含此消息的 Folder 中都添加一个指向新创建的 Message 的指针。 当我们销毁一个 Message 时，它将不复存在。因此，我们必须从包含此消息的所有 Folder 中删除指向此 Message 的指针。 当我们将一个 Message 对象赋予另一个 Message 对象时，左侧 Message 的内容会被右侧 Message 的内容所替代。我们还必须更新 Folder 集合，从原来包含左侧 Message 的 Folder 中将它删除，并将它添加到包含右侧 Message 的 Folder 中。 Message 类 class Message{ friend class Folder; public: explicit Message(const std::string& str =\"\"):contents(str){} Messge(const Message&); // 拷贝构造函数 Message& operator=(const Message&); // 拷贝赋值运算符 ~Message(); // 析构函数 void save(Folder&); void remove(Folder&); private: std::string contents; // 消息 std::set<Folder*> folders; //包含本Messge的 Folder void add_to_Folders(const Message&); void remove_from_folders(); }; save 和 remove 成员 void Message::save(Folder& f) { folders.insert(&f); // 将给定 Folder 添加到我们的 Folder 集合中 f.addMsg(this); // 将本 Message 添加到 f 的 message 集合中 } void Message::remove(Folder& f) { folders.erase(&f); // 将给定 folder 从我们的Folder列表中删除 f.remMsg(this); // 将本 Message 从 f 的Message 集合中删除 } Message 类的拷贝控制成员 当拷贝一个 Message 时，得到的副本应该与原 Message 出现在相同的 Folder 中。因此，我们必须遍历 Folder 指针的 set。对每个指向原 Message的 Folder 添加一个指向新 Message 的指针。拷贝构造函数和拷贝赋值运算符都需要做这个工作。 void Message::add_to_Folders(const Message& m) { for(auto f: m.folders) { f->addMsg(this); } } Message::Message(const Message& m):contents(m.contents),folders(m.folders) { add_to_Folders(m); } Message 的析构函数 当一个 Message 被销毁时，我们必须从指向此 Message 的 Folder 中删除它。拷贝赋值运算符也要执行此操作。 void Message::remove_from_Folders() { for(auto f : folders) f->remMsg(this); } Message::~Message() { remove_from_Folders(); } Message 的拷贝赋值运算符 这里要注意的是，如果等号左边和右边的对象是同一个，也要正确处理关系。 Message& Message::operator=(const Message& rhs) { remove_from_Folders(); // 更新已有 folders contents = rhs.contens; folders = rhs.folders; // 从 rhs 拷贝Folder 指针 add_to_Folders(rhs); // 将本 Message 添加到那些 folders中 return *this; } Message 的 Swap 函数 为什么定义 Swap? 标准库中定义了 string 和 set 的 swap 版本，如果能为 Message 类定义它自己的 swap 版本，它将从中受益。通过定义一个 Message 特定版本的 swap，我们可以避免对 contents 和 folders 成员进行不必要的拷贝。 void swap(Message& lhs, Message& rhs) { using std::swap; for(auto f : lhs.folders) f->remMes(&lhs); // 将左边的message对象从它的folders中移除 for(auto f: rhs.folders) f->remMes(&rhs); // 交换 contents 和 Folders指针set swap(lhs.folders, rhs.folders); swap(lhs.contents, rhs.contents); for(auto f: lhs.folders) f->addMsg(&lhs); for(auto f: rhs.folders) f->addMsg(&rhs); }"
  },
  "Languages/Chapter13/13.5.html": {
    "href": "Languages/Chapter13/13.5.html",
    "title": "13.5 动态内存管理类",
    "keywords": "13.5 动态内存管理类 这一节实现一个vector类的简化版本，不适用于模板，只适用于 string。 StrVec 类的设计 ​ vector 类将其元素保存在连续的内存中，为了获得可接受的性能，vector 预先分配足够的内存来保存可能需要的更多元素。vector 的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，vector 就会重新分配空间：它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。 ​ StrVec 也应该使用类似的策略。我们将使用一个 allocator 来获得原始内存。由于 allocator 分配的内存是未构造的，我们将在需要添加新元素时用 allocator.construct 成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们使用destroy 成员来销毁元素。 ​ 每个 StrVec 有三个指针成员指向其元素所使用的内存： elements，指向分配的内存中的首元素 first_free，指向最后一个实际元素之后的位置 cap，指向分配的内存末尾之后的位置。 StrVec 还有一个名为 alloc 的静态成员，其类型为 allocator<string>。alloc 成员会分配 StrVec 使用的内存。我们的类还有4个工具函数： alloc_n_copy 会分配内存，并拷贝一个给定范围中的元素。 free 会销毁构造的元素并释放内存。 chk_n_alloc 保证 StrVec 至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc 会调用 reallocate 来分配更多内存。 reallocate 在内存用完时，为 StrVec 分配新内存。 StrVec 类定义 class StrVec{ public: StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr){} StrVec(const StrVec&); // 拷贝构造函数 StrVec& operator=(const SteVec&); // 拷贝赋值运算符 ~StrVec(); // 析构 void push_back(const std::string&); // 拷贝元素 size_t size() const { return first_free - elements;} size_t capacity() const { return cap - elements;} std::string* begin() const {return elements;} std::string* end() const { return first_free;} private: static std::allocator<std::string> alloc; // 静态变量 void chk_n_alloc() { if(size() == capacity()) reallocate(); } std::pair<std::string*, std::string*> alloc_n_copy(const std::string*, std::string*); void free(); // 销魂元素并释放内存 void reallocate(); // 获得更多内存并拷贝已有元素 std::string* elements; // 指向数组首元素的指针 std::string* first_free; // 指向数组第一个空闲元素的指针 std::string* cap; // 指向数组尾后位置的指针 }; 使用 construc 函数 push_back 调用 chk_n_alloc() 确保有空间容纳新元素。如果需要，chk_n_alloc 会调用 reallocate 。当 chk_n_alloc() 返回时，push_back 知道必有空间容纳新元素。 void StrVec::push_back(const string& s) { chk_n_alloc(); // 确保有空间容纳新元素 alloc.construct(first_free++, s); } alloc_n_copy 成员 ​ 我们在拷贝或赋值 StrVec 时，可能会调用 alloc_n_copy 成员。类似 vector，我们的StrVec 类有类值的行为。当我们拷贝或赋值 StrVec 时，必须分配独立的内存，并从原 StrVec 对象拷贝元素至新对象。 ​ alloc_n_copy 成员会分配足够的内存来保证给定范围的元素，并将这些元素拷贝到新分配的内存中。此函数返回一个指针的 pair，两个指针分配指向新空间的开始位置和拷贝的尾后的位置： pair<string*, string*> StrVec::alloc_n_copy(const string* b, const string *e) { // 分配空间保存给定范围的元素 auto data = alloc.allocate(e - b); return {data, uninitialized_copy(b, e, data)}; } alloc_n_copy 用尾后指针减去首元素指针，来计算需要多少空间。在分配内存之后，它必须在此空间中构造给定元素的副本。 它是在返回语句中完成拷贝工作的，返回语句中对返回值进行了列表初始化。返回的 pair 的 first 成员指向分配内存的开始位置；second 成员则是uninitialized_copy 的返回值，此值是一个指向最后一个构造元素之后的位置的指针。 free 成员 free 主要做两件事情：destroy 元素；释放 StrVec 自己分配的内存空间。 void StrVec::free() { if(elements){ for(auto p = first_free; p != elements;) alloc.destroy(--p); alloc.deallocte(element, cap - elements); } } 拷贝控制成员 StrVec::StrVec(const StrVec& s) { // 分配空间以容纳与 s 中一样多的元素 auto newdata = alloc_n_copy(s.begin(), s.end()); elements = newdata.first; first_free = cap = newdata.second; } 析构函数 StrVec::~StrVec(){ free(); } 拷贝赋值运算符 StrVec& StrVec::operator=(const StrVec& rhs) { auto data= alloc_n_copy(rhs.begin(), rhs.end()); free(); elements=data.first; first_free = cap=data.second; return *this; } 在重新分配内存的过程中移动而不是拷贝元素 和 reallocate 函数前，思考： 为了一个新的、更大的 string 数组 分配内存 在内存空间的前一部分构造对象，保存现有元素 销毁原内存空间中的元素，并释放这块内存 为一个 StrVec 重新分配内存空间会引起从旧内存空间到新内存空间逐个拷贝 string。虽然我们不知道 string 的实现细节，但我们知道 string 具有类值行为。当拷贝一个 string 时，新 string 和原 string 是相互独立的。改变原 string 不会影响副本。 由于 string 的行为类似值，可以肯定，每个 string 对构成它的所有字符都会保存自己的一份副本。拷贝一个 string 必须为这些字符分配内存空间，而销毁一个 string 必须释放所占用的内存。 ​ 拷贝一个 string 必须真的拷贝数据。如果是 reallocate 拷贝 StrVec 中的string，则在拷贝后，每个 string 并不需要副本和原对象都存在。一旦将元素从旧空间拷贝到新空间，我们就会立即销毁旧空间的 string。因此拷贝这些 string 中的数据是多余的。在重新分配内存空间时，如果我们能避免分配和释放 string 的额外开销，StrVec 的性能会好很多。 移动构造函数和 std::move ​ 通过使用新标准库引入的两种机制，就可以 避免 string 的拷贝。首先，有一些标准库类，包括 string，都定义了所谓的“移动构造函数”。关于 string 的移动构造函数如何工作的细节，以及有关实现的任何其他细节，目前都尚未公开。但是，我们知道，移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且我们知道标准库保证“移后源”string 任然保持一个有效的、可析构的状态。对于 string， 我们可以想象每个 string 都有一个指向 char 数组的指针。可以假定 string 的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符。 ​ 我们使用的第二个机制是标准库函数 move，它定义在 utility 头文件中。目前，关于 move 需要了解两点： 当 reallocate 在新内存中构造 string 时，它必须调用 move 来表示希望使用 string 的移动构造函数，原因我们后新章节会讲到（13.6.1）。如果它漏掉了 move 调用，将会使用 string 的拷贝构造函数。 其次，我们通常不为 move 提供一个 using 声明，原因将在 18.2.3（我的天，我都不一定看到那个资料）节中解释。当我们使用 move 时，直接调用 std::move 而不是 move。 reallocate 成员 每次 reallocate 的策略是，容量翻倍。 void StrVec::reallocate() { auto newcapacity = size() ? 2 * size(): 1; auto newdata = alloc.allocate(newcapacity); auto dest = newdata; // 指向新数组中下一个空闲位置 auto elem = elements; // 指向旧数组中下一个元素 for(size_t i = 0; i != size(); ++i) { alloc.construct(dest++, std::move(*elem++)); } // 释放旧内存空间 free(); // 更新我们的数据结构，执行新元素 element = newdata; first_free = dest; cap = elements + newcapacity; } for 循环遍历每个已有元素，并在新内存空间中 construct 一个对应元素。我们使用 dest指向构造新 string 的内存，使用 elem 指向元素数组中的元素。我们每次用后置递增运算将 dest 和 elem 推进到各自数组中的下一个元素。 construct 的第二个参是 move 的返回的值。调用 move 返回的结果会令 construct 使用 string 的移动构造函数。由于我们使用了移动构造函数，这些 string 管理的内存不会被释放，相反，我们构造的每个 string 都会从 elem 指向的 string 那里接管内存的所有权。 ​ 在元素移动完毕后，我们调用 free 销毁旧元素并释放 StrVec 原来使用的内存。 string 成员不在管理它们曾经指向的内存；其数据的管理职责已经转移到新 StrVec内存中的元素了。我们不知道旧 StrVec 内存中的 string 包含什么值，但是保证对它们执行 string 的析构函数是安全的。"
  },
  "Languages/Chapter13/13.6.html": {
    "href": "Languages/Chapter13/13.6.html",
    "title": "13.6 对象移动",
    "keywords": "13.6 对象移动 ​ 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝，某些情况下，拷贝后立即被销毁。而且一些算法比如排序，做大量的移动会消耗性能。 ​ 如果能像 StrVec 类那样不用拷贝而是 “移动”多好。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于 IO 类或 unique_ptr 这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。（不是有引用了吗） ​ 在旧 C++ 标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如 string）。进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。 标准库容器、string 和 shared_ptr 类即支持移动也支持拷贝。IO 类和 unique_ptr 类可以移动但不能拷贝 。 13.6.1 右值引用 ​ 为了支持移动操作，新标准引入了一种新的引用类型——右值引用。所谓右值引用就是必须绑定到右值的引用。通过 && 而不是 & 来获得右值引用。如我们将要看到的，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源 “移动” 到另一个对象中。 ​ 左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示对象的值。 ​ 类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用（为了与右值引用区分开来，我们可以称之为 左值引用 ），我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上。 int i = 42; int& r = i; // 正确，r 引用 i int&& rr = i; // 错误，不能将一个右值引用绑定到一个左值上 int& r2 = i * 42; // 错误，i*42 是一个右值 const int& r3 = i*42; // 正确，我们可以将一个 const 的引用绑定到一个右值上 int&& rr2 = i*42; // 正确，将 rr2 绑定到乘法结果上 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。 ​ 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式上。 左值持久：右值短暂 ​ 考查左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 ​ 由于右值引用只能绑定到临时对象： 所引用的对象将要被销毁。 该对象没有其他用户。 意味着使用右值引用的代码可以自由地接管所引用的对象的资源。 右值引用值指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象 “窃取” 状态。 变量是左值 变量可以看作只有一个运算对象而没有运算符的表达式"
  },
  "Languages/Chapter2/2.1.html": {
    "href": "Languages/Chapter2/2.1.html",
    "title": "2.1 基本内置类型",
    "keywords": "2.1 基本内置类型 2.1.1 算术类型 c++定义了一套基本算术类型，包括算术类型和空类型。 算术类型 字符 整型数 浮点数 布尔值 还有一个空类型，常见用于当函数不返回任何值时使用。 常见的算术类型如下表： 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode字符 16位 char32_t Unicode字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 支持国际化的基本的字符类型是 char ，一个 char 类型的大小和机器字节大小一样。 ​ c++ 规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 浮点数可表示单精度、双精度和扩展精度值。 c++ 标准只是指定了一个浮点数有效位数的最小值，大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64比特）来表示， long double 以3个或4个字来表示。（这依赖于编译器和机器）。类型 float 和 double 分别有7和16位个有效位；类型 long double 带符号类型和无符号类型 ​ 除了布尔型和扩展的字符型，其他整型可以分为带符号的和无符号的。带符号类型可以表示正数、零和负数，无符号仅能表示大于等于0的数值。 带符号类型 无符号类型 int unsigned int short unsigned short long unsigned long long long unsigned long long 字符型比较特殊，被分为三种： char 、 signed char 、 unsigned char 。 char 和 signed char 不一定一样，取决于编译器，char可能是 signed char ，也可能是 unsigned char 。 无符号类型中，所有的数据比特都用于表示存储值，有符号类型则用一个比特表示符号，即 0 表示 + ， 1 表示 - 。 如何选择类型 当明确知道数值不可能为负数时，选用无符号类型。 使用 int 执行整数运算。现实中 short 太小而 long 一般和 int 一样，如果 int 范围不够，则用 long long 。 在算术表达式中不要使用 char 和 bool ,只有在存放字符或布尔值时才使用它们。因为 char 在一些机器上是有符号，在一些机器上是无符号。 执行浮点数运算使用 double ，因为 float 往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器， double 的运算比 float 还要快。而 long double 在一般情况下没必要，且计算代价高。 练习 练习2.1 类型 int 、 long 、 long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？ float 和 double 的区别是什么？ int 、 long 、 long long 和 short 都表示整形，在C++标准中，这四个类型定义的最小尺寸不一样。 short 短整形的最小尺寸是16位， int 整形的最小尺寸是16位， long 长整形的最小尺寸是32位， long long 长整形的最小尺寸是64位。一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 float 和 double 都表示浮点数， float 用一个字表示， double 用两个字表示， float 有效为为7位， double 有效位为16位。 练习2.2 计算按揭贷款，对于利率、本金和付款分别选择何种数据类型？说明你的理由。 应选择double类型，执行浮点数运算使用 double ，因为 float 往往精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。对某些机器， double 的运算比 float 还要快。而 long double 在一般情况下没必要，且计算代价高。 2.1.2 类型转换 类型转换就是将对象从一种给定的类型转换为另一种相关类型。 bool b = 42; // b 为真 int i = b; // i 的值为1 i = 3.14; // i的值为3 double pi = i; // pi的值为3.0 unsigned char c = -1; // 假设 char占8比特，c的值为255 signed char c2 = 256; // 假设 char占8比特，c2的值时未定义的 把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为 false ，否则结果为 true 。 把一个布尔值赋给非布尔类型时，初始值为 false 则结果为0，初始值为 true 则结果为1。 把一个浮点数赋给整型类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当把一个整数值赋值给浮点类型时，小数部分记为0。如果整数所占空间超过浮点类型的容量，精度可能有损失。 当赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如8比特大小的 unsigned char 可以表示0至255区间的值，如果给我们赋一个区间以外的值，则实际结果该值对256取模后所得的余数。比如把-1赋给8比特大小的 unsigned char 所得结果是255。 一般不在算术表达式中使用布尔类型，因为布尔类型转换为整形后非零即一。 含有无符号类型的表达式 当一个表达式中含有无符号和 int 类型变量值时， int 值就会转换成无符号数。 unsigned u =10; int i = -42; cout << i + i << endl; // 输出-84 cout << u + i << endl; // 输出 4294967264 这是因为32位的 unsigned int 类型的u值为10的机器码表示为 (0000 0000 0000 0000 0000 0000 0000 1010）(二进制)，而 int 类型的i值为-42的机器码表示为(1111 1111 1111 1111 1111 1111 1101 0110 )（负数的机器码为真值的原码取反加1，高位为1），相加后得到的机器码为(1111 1111 1111 1111 1111 1111 1110 0000)，是一个 unsigned int 类型，所以打印输出时结果为 4294967264。 // 错误示范：这个循环会是个死循环，因为u不可能小于0。 for(unsigned u =10; u>=0;u--) { cout << u << endl; } 因此不要在计算表达式中混用带符号类型的变量和无符号类型的变量。 练习 练习2.3 读程序写结果： unsigned u =10, u2 = 42; cout << u2 - u << endl; cout << u - u2 << endl; int i = 10, i2 =42; cout << i2 - i << endl; cout << i - i2 << endl; cout << i - u << endl; cout << u - i << endl; unsigned int 和 int 是32位的机器上的类型。 真值 机器码（补码） 10 0000 0000 0000 0000 0000 0000 0000 1010 42 0000 0000 0000 0000 0000 0000 0010 1010 -10 1111 1111 1111 1111 1111 1111 1111 0110 -42 1111 1111 1111 1111 1111 1111 1101 0110 u2 - u ， 的结果是 0000 0000 0000 0000 0000 0000 0010 0000 ，类型是 unsigned int ，打印的值为32。 u - u2 ， 相当于10的机器码加上 -42的机器码，返回的类型是 unsigned int 类型。相加后的值为 1111 1111 1111 1111 1111 1111 1110 0000 ，打印得值为 4294967264。 i2 - i , 就是42的机器码加上-10的机器码，返回类型是 int 类型。相加后的值为 0000 0000 0000 0000 0000 0000 0010 0000 ，打印的值为32。 i - i2 ，就是10的机器码加上-42的机器码，返回类型是 int 类型。相加后的值为 1111 1111 1111 1111 1111 1111 1110 0000 ，打印的值为 -32。 i - u ，就是10的机器码加上 - 10的机器码，返回的是 unsigned int 类型 ，相加后的值为 0000 0000 0000 0000 0000 0000 0000 0000 。打印的值为0。 u - i ，就是10的机器码加上-10的机器码，返回的是 unsigend int 类型，相加后的值为 0000 0000 0000 0000 0000 0000 0010 0000 ,打印的值为0。 2.1.3 字面值常量 如“42”，”A“，这样的值，一望而知，称为字面值常量，每个字面值常量对应一种数据类型。 整型和浮点型字面值 整型字面值 十进制 八进制 十六进制 20 024 0x14 以0开头 以0x或0X开头 浮点型字面值 3.14159 3.14E1 .001 字符和字符串字面值 字符字面值 字符串字面值 'a' \"hello world\" 字符串由常量字符构成数组，编译器在每个字符串的结尾处添加一个空字符('\\0')，因此，字符串字面值的实际长度要比它的内容多1。 两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则实际上它们是个整体。 // 一行写不下，可以换行 cout << \"a really, really long string literal \" \"that spans two lines\" <<endl; // 相当于 \"a really, really long string literal that spans two lines\" 转义序列 两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是c++语言中有特殊含义的字符。需要转义序列，转义序列均以反斜线开始。 名称 换行符 \\n 纵向制表符 \\v 反斜线 \\\\ 回车符 \\r 横向制表符 \\t 退格符 \\b 问号 ? 进纸符 \\f 报警符 \\a 双引号 \\\" 单引号 \\' 泛化的转义序列，形式是\\x后紧跟1个或多个十六进制数字，或\\后紧跟1个或2个或3个八进制数字，其中数字部分表示的是字符对应的数值。因此， 反斜线\\后面紧跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。如“\\1234”表示两个字符，“\\123”和“4”。 指定字面值的类型 字符和字符串字面值 前缀 含义 类型 u Unicode16字符 char16_t U Unicode32字符 char32_t L 宽字符 wchar_t u8 UTF-8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double L'a' // 宽字符类型字面值，类型是 wchar_t u8 \"hi!\" // utf-8字符串字面值(utf-8用8位编码一个unicode字符) 42ULL // 无符号整数字面值，类型是unsigned long long 1E-3F // 单精度浮点型字面值，类型是float 3.14159L // 扩展精度浮点型字面值，类型是 long double 布尔字面值和指针字面值 布尔字面值 指针字面值 true和false。 nullptr 练习 练习2.5 指出下述字面值的数据类型并说明每一组内几种字面值的区别： (a) 'a'，L'a'，“a”，L\"a\" (b) 10, 10u, 10L，10uL，012，0xC (c) 3.14，3.14f，3.14L (d) 10，10u，10.，10e-2 答： ​ (a)组，'a'是 char 类型，内存占用1个字节。L'a'是 wchar_t 类型，内存占2个字节。“a”是字符串，存储串尾部还有一个'\\0'，编码格式为ASCIII编码格式。L\"a\"编码格式为 Unicode 编码格式，每个字符占用两个字节，因为串尾部结束符'\\0'也占两个字节，故该串占用4个字节。 (b)组， 10 是int类型常量，默认为有符号整型，最小尺寸为16位。 10u 是 unsigned int 类型，最小尺寸为16位。 10L 是 Long 类型，最小尺寸为32位。 10uL 是 unsigned long 类型，无符号长整型，最小尺寸为32位。012 是八进制的int类型常量，表示数值10（十进制）。0xC表示十六进制的int类型，数值为10。 (c)组，3.14表示双精度浮点数，类型为double，最小尺寸为10位有效数字。3.14f为单精度浮点数，类型为float，最小尺寸为6位有效数字.3.14L，表示 long double 类型，最小尺寸为10位有效数字。 (d)组，10表示int类型。10u表示 unsigned int 类型。10.表示双精度浮点数类型double。10e-2，用科学计数法表示的浮点数0.1。 练习2.6 下面两组定义是否有区别，如果有，请叙述之。 int month = 9,day = 7; int month = 09, day =07; 有区别，第一行是用十进制表示month和day，值分别为9和7。第二行用八进制表示month和day，但是month的值为无效字符，八进制的位不能大于7，是错误的，编译时不通过。 练习2.7 下述字面值表示何种含义？它们各自的数据类型是什么？ (a) \"who goes with F\\145rgus?\\012\"、 (b) 3.14e1L （c）1024f (d) 3.14L (a) \\145表示小写字母e，\\012表示换行符。为字符串类型，因此表示字符串为 who goes with Fergus? (b) 3.14e1L表示类型为 Long double 类型，值为31.4。 (c) 表示类型为 float 类型值为1024。 (d) long double 类型的3.14。 练习2.8 请利用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。 #include <iostream> using namespace std; int main() { cout << \"2\\115\\012\" << endl; // 输出2M和换行 cout << \"2\\t\\115\\012\" << endl; // 输出2 制表符 M 换行 return 0; }"
  },
  "Languages/Chapter2/2.2.html": {
    "href": "Languages/Chapter2/2.2.html",
    "title": "2.2 变量",
    "keywords": "2.2 变量 ​ 变量提供一个具名的、可供程序操作的存储空间。c++中每个变量都有其数据类型，数据类型决定着变量所占内存空间大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。 2.2.1 变量定义 基本形式：类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。 int sum = 0, value, units_sold = 0; // 其中sum 和 units_sold 初始值为0 Sales_item item; // item的类型是 Sales_item std::string book(\"0-201-78345-X\"); // book 通过一个string 字面值初始化 当对象在创建时获得一个特定的值，就做对象初始化。 列表初始化 初始化的形式有几种，如下，是给int类型变量进行初始化。 int units_sold = 0; // 常用 int units_Sold = {0}; int units_sold{0}; int units_sold(0); 用花括号来初始化变量，作为C++11新标准的一部分，已经得到全面应用，过去这种花括号初始化仅限在某些场合下使用。 使用花括号初始化存在丢失精度的风险时，编译器会报错。 long double ld = 3.1415926536; int a{ld}, b = {ld}; // 错误，转换为执行，因为存在丢失精度的风险 int c(ld), d =ld; // 正确，转换执行，且确实存在丢失了部分值 去掉上述第二行代码，加上两行打印代码运行，编译器会报警： 警告 C4244 “初始化”: 从“long double”转换到“int”，可能丢失数据 1.1.cpp 12 ，并且打印的值为 3，3。 cout << \"c: \" << c << endl; cout << \"d: \" << d << endl; 默认初始化 ​ 定义变量时没有指定初值，则变量被<font color= blue >默认初始化，此时变量被赋予默认值。默认值到底是什么取决于变量类型，同时定义变量的位置也会对此有影响。 ​ 如果是内置类型的变量被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不会被初始化。 一个未被初始化的内置类型变量的值是未定义的，试图拷贝或者以其他形式访问该类值将会引发错误。 ​ 每个类各自决定其初始化对象的方式。是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 ​ 绝大多数类都支持无需显式初始化而定义对象，这样的类提供了一个合适的默认值。比如std::string 类型，默认初始化为一个空串。自定义类Sales_item类也有其默认构造函数初始化。 练习 练习2.9 解释下列定义的含义。对于非法的定义，请说明在何处并将其改正。 (a) std::cin >> int input_value; (b) int i = {3.14}; (c) double salary = wage = 9999.99; (d) int i = 3.14; 答：(a) cin右侧紧跟的是已经定义的对象。此处应改为： int input_value; std::cin >> input_value; (b) 花括号初始化，如果存在精度丢失风险，编译器会报错。此处应改为： int i =3.14; // 或者 double i = {3.14}; (c) 定义double类型变量salary和wage，并显示初始化9999.99。定义形式错误，应该用逗号 隔开。此处应改为： double salary = 9999.99, wage = 9999.99; (d)定义一个int变量并初始化3.14，存在精度丢失，但是编译器允许编译通过。 练习2.10 下列变量的初值分别是什么？ std::string global_str; int global_int; int main() { int local_int; std::string local_str; } global_str初始化为一个空串；global_int初始化为0；local_int未执行初始化，因为定义在函数体内部，编译报错！ local_str初始化为一个空窜，即使在函数体内部定义了并没初始化，编译时也会通过。 因此，应当都每一个内置类型变量进行初始化，虽然不是必须，但是不这样做，可能存在访问时对时错的风险。 2.2.2 变量声明和定义的关系 ​ c++支持分离式编译机制，这个机制允许将程序分为若干文件，每个文件可被独立编译。 声明 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<font color= blue >定义负责创建与名字关联的实体。 ​ 变量声明规定了变量的类型和名字。定义也规定了变量的类型和名字，但是还要申请存储空间，也可能进行初始化。 ​ 如果仅仅是声明一个变量而不是定义它，那么在变量名前面添加关键字 extern ，而且不要显示初始化变量。 extern int i; // 声明i 而非定义i int j; // 声明并定义 j ​ 任何包含了显示初始化的声明即称为定义。 在函数体内部，试图初始化一个由 extern 关键字标记的变量，将会引发错误。 变量能且只能被定义一次，但是可以被多次声明。 ​ 如果在多个文件中使用同一个变量，就必须将声明和定义分离。变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 练习 练习2.11 指出下面的语句是声明还是定义。 (a) extern int ix = 1024; (b) int iy; (c) extern int iz; （a)是定义。(b)是声明。(c)是声明。 2.2.3 标识符 C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是大小写敏感。 C++关键字 alignas continue friend register true alignof decltype goto reinterpret_cast try asm default if return typedef auto delete inline short typeid bool do int signed typename break double long sizeof union case dynamic_cast mutable static unsigned catch else namespace static_assert using char enum new static_cast virtual char16_t explicit noexcept struct void char32_t export nullptr switch volatile class extern operator template wchar_t const false private this while constexpr float protected thread_local const_cast for public throw C++操作符代替名 and bitand compl not_eq or_eq xor_eq and_eq bitor not or xor 上述两个表格的关键字不能用作标识符。 练习 练习2.12 请指出下面的名字中哪些是非法的？ (a) int double = 3.14; (b) int _; (c) int catch-32; (d) int 1_or_2 =1; (e) double Double = 3.14; (a)显然非法，变量名的位关键字double。 (b)编译通过，但是一般不会这样命名，命名要准守一定的规范外最好做到 见名知意 。 (c)非法，变量名不能有“-”符号。 (d) 非法，必须以下划线开头或者字母开头。 (e)编译通过，变量名字是大小写敏感的，Double首字母大写，与double关键字不冲突。 2.2.4 名字作用域 代码中同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。 作用域是程序的一部分，在其中名字有其特定的含义。c++语言中大多数作用域都以花括号分隔。 同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 #include <iostream> using namespace std; int _testData; std::string global_str; int global_int; int main() { double local_data = 3.14; cout << local_data << endl; { int block_data = 10; cout << block_data << endl; } int data = block_data; // 访问block_data失败 return 0; } 代码中， _testData ， global_str 的作用域是 全局作用域 ，在整个程序代码中都能访问到，而像 local_data 的作用域是 块作用域 ，在声明之后的代码都能访问到，但是离开 main 函数再去访问 local_data ，就访问不到。而 block_data 这样的变量，定义在一个花括号括起来的块，出了块之后就不能再访问到。 嵌套作用域 作用域能包含彼此，被包含的作用域称为内层作用域，包含着别的作用域的作用域称为外层作用域。作用域一旦声明了某个名字，它所嵌套着的所有作用域都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。 #include <iostream> using namespace std; int _testData = 10; // _testData 为全局作用域 int main() { cout << _testData << endl; // 输出 10 double local_data = 3.14; double _testdata = 5; cout << _testdata << endl; // 优先使用距离代码最近的作用域，即输出 5 return 0; } 因此，当函数内部某个地方使用到全局变量，就不应该再定义一个同名的局部变量 。 练习 练习 2.13 下面程序中j的值是多少？ int i =42; int main() { int i = 100; int j = i; } j的值为100，给j赋值的i优先使用内部作用域。 练习2.14 下面的程序合法吗？如果合法，它将输出什么？ int i = 100, sum = 0; for(int i =0; i != 10; ++i) { sum+=i; } std::cout << i << \" \"<< sum <<std::endl; 合法，输出：100 45"
  },
  "Languages/Chapter2/2.3.html": {
    "href": "Languages/Chapter2/2.3.html",
    "title": "2.3 复合类型",
    "keywords": "2.3 复合类型 ​ 符合类型指基于其他类型定义的类型。这里仅介绍 引用 和 指针 。 2.3.1 引用 ​ 引用为对象起了另一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名： int ival = 1024; int &refVal = ival; // refVal指向ival（相当于给ival起了另一个名字） int &refVal2; // 报错，引用必须初始化 ​ 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。 引用即别名 ​ 引用不是一个对象，它只是一个已存在的对象所起的另一个名字，对其操作是在与之绑定的对象基础上进行操作。 int ival = 1024; int &refVal = ival; // refVal指向ival（相当于给ival起了另一个名字） refVal = 2048 cout << ival << endl; // 打印 2048 引用的定义 ​ 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头。 int i = 1024, i2 = 2048; int &r = i, r2 = i2; int i3 = 1024, &ri = i3; int &r3 = i3, &r4 = i2; ​ 引用只能绑定在对象上，不能绑定在字面值或某个表达式的计算结果。 int &refVal = 1024; // 报错 double dVal = 3.14; int refVal2 = dVal; // 报错，引用类型的初始值类型不匹配 练习 练习2.15 下面的哪个定义是不合法的？ (a) int ival= 1.01; (b) int &rvall = 1.01; (c) int &rval2 = ival; (d) int &rval3; ​ 答：(a)和(c)合法，(b)绑定只能绑定到对象上，不能绑定到具体的字面值上，(d)绑定必须初始化。 练习2.16 考查下面所有的赋值然后回答，哪些赋值是不合法的，为什么?哪些赋值是合法的，他们执行了什么操作？ int i = 0,&r1 = i; double d= 0, &r2 = d; (a) r2 = 3.14159; (b) r2 = r1; (c) i = r2; (d) r1 = d; ​ 答：(a) 合法，将3.14159赋值给了与r2绑定的对象。(b) 合法，将 r1绑定对象的值，赋值给 r2绑定的对象，因为r2绑定的对象是double类型，r1 是int类型，所以是可以运行的。(c) 不合法，会报警提示可能存在数据精度丢失。(d) 不合法。会报警提示可能存在数据精度丢失。 练习2.17 执行下面的代码段将会输出什么？ int i, &ri = i; i = 5; ri = 10; cout << i << \" \" << ri <<endl; ​ 输出10 10，这里ri与i的对象绑定在一起，对ri的任何操作都是对i的操作。 2.3.2 指针 ​ 指针是指向另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。指针是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象。指针无须在定义时赋初始值。 int *ip1, *ip2; // 两个指向int类型的指针 int dp, *ip3; // dp是int类型对象，ip3是指向int类型的指针。 获取对象的地址 ​ 指针存放某个对象的地址，而给指针赋值地址时需要 取地址符& 。 int ival = 42; int *p = &ival; // p指针指向ival对象 ​ 引用不是对象，无实际地址，所以不能将指针指向引用。 ​ 一般情况下，指针的类型要和它所指向的对象类型严格匹配。 double ival; double* pd = &ival; int* p1 = pd; // 报错，类型不匹配 int* p = &ival; // 报错，类型不匹配 指针值 ​ 指针的值是地址。指针要么指向一个对象，要么指向紧邻对象所占空间的下一个位置，要么是个空指针（因此对指针操作一般要进行判空），或者是个无效指针，随意访问可能导致程序崩溃。 利用指针访问对象 ​ 要知道指针指向一个对象，直接访问指针名，其实访问的是对象的地址，而一般数据是对象的内容，因此需要一个 解引用符* 来访问对象内容。 int ival = 42; int *p = &ival; // p 指向ival cout << p; // 输出p的地址 cout << *p; // 输出 42 ​ 给指针指向的对象赋值，也需要 解引用符* 。 *p=1024; // 给p指向的对象赋值 cout << *p; // 输出 1024 cout << ival; // 输出 1024 ​ 解引用符只适用于指针指向了明确的对象。 int ival = 42; int* p = NULL; // p 指向ival cout << *p << endl; // 运行时报错 空指针 ​ 空指针不指向任何对象，在试图使用一个指针之前代码可以先判空。三种生成空指针的方法。 int *p1 = nullptr; // c++11标准推荐使用这种方式赋值空指针 int *p2 = 0; int *p3 = NULL; // NULL实际就是0 赋值和指针 ​ 引用一旦绑定到某个对象之后，再解绑并对另一个对象绑定是不可能的。而指针就不同，指针可以再指向另一个对象。给指针赋值(地址)，就是令指针重新存放了一个地址，从而指向一个新的对象。 ​ 任何非0地址的指针在条件判断是都是true。 void* 指针 ​ void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个 void* 指针存放一个地址，存放什么类型地址我们不得而知。 double obj = 3.14159, * pd = &obj; void* pv = &obj; pv = pd; cout << *pv << endl; // 报错，void* 类型不允许访问，必须提前知道void*指针指向什么类型的地址，再用该类型的指针指向void*指向的指针，方可访问对象 return 0; 练习 练习2.18 编写代码分别更改指针的值以及指针所指向对象的值。 double obj = 3.14159, * pd = &obj; // pd指向obj对象 double x = 1919; pd = &x; // 更改pd的值，令其指向x对象 *pd = 1024; // 更改pd指向对象的值，即x值为1024 练习2.19 说明指针和引用的主要区别。 答，引用不是一个对象，没有实际地址，引用一旦绑定到某个对象，要再绑定到另一个对象是不可能的，因此引用必须初始化。指针是一个对象，有实际地址，指针可以更改值，从而指向新的对象，也不用初始化。 练习2.20 请叙述下面这段代码的作用。 int i =42; int *p1 = &i; *p1 = *p1 * *p1; 答：定义一个int类型变量i，指针p1指向i对象，将p1指向对象的值相乘然后赋值给pi指向的对象，因此i对象的值最后变为42*42。 练习2.21 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？ int i = 0; (a) double* dp = &i; (b) int *pi = i; (c) int *p = &i; 答：(a)非法，非空指针要和指向的对象严格类型匹配。(b) 指针初始化时是赋值地址，而非具体对象的值。 练习2.22 假设p是一个int型指针，请说明下述代码的含义。 if(p) // p如果是非空指针，则执行if后的代码块 if(*p) // 指针p指向的对象如果值不为0，这执行if后的代码块 练习2.23 给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断思路；如果不能，也请说明原因。 答：可以通过判空来确定是否指向了一个合法的对象。 练习2.24 在下面这段代码中为什么p合法而lp非法？ int i = 42; void *p = &i; long *lp = &i; 答：void*指针是特殊的指针，可以指向任意对象。而long指针只能指向long类型的对象。 2.3.3 理解复合类型的声明 int i = 1024, *p = i, &r = i; ​ 只需在某行代码前面写一个关键字 int ，然后声明变量的名字用逗号分隔，可以定义不同类型的变量。 指向指针的指针 ​ 不像引用，指针是内存中的对象，有自己的地址，因此可以将指针的地址存放到另一个指针中。通过*符号的个数可以区分指针的级别。 ** 表示指向指针的指针， *** 表示指向指针的指针的指针。 int ival = 1024; int *pi = &ival; // 指向ival的指针 int **ppi = &pi; // 指向pi指针的指针 cout << *pi << endl; // 输出 1024 cout << *ppi << endl; // 输出 pi的地址 cout << **ppi << endl; // 输出 1024 指向指针的引用 ​ 引用本身不是一个对象，因此不能定义一个指向引用的对象。但是指针是一个对象，可以定义一个指向指针的引用。 int i = 42; int *p; int *&r = p; // r是指向p的引用，相当于p有另一个名字：r r=&i; // 相当于将p指向了i *r=0; // 将i的值改为0 练习 练习2.25 说明下列变量的类型和值。 (a) int* ip, i, &r = i; (b) int i, *ip = 0; (c) int * ip, ip2; 答：(a) ip是个int类型指针，i是int类型对象，r是一个指向i对象的int类型引用。 (b) i是个int类型对象，ip是个空的int类型指针。 (c) ip是个int类型的指针，ip2是个int类型的对象。"
  },
  "Languages/Chapter2/2.4.html": {
    "href": "Languages/Chapter2/2.4.html",
    "title": "2.4 const 限定符",
    "keywords": "2.4 const 限定符 ​ const 关键字修饰的变量，它在初始化之后值不可再变。因此 const 修饰的的变量必须初始化。 const int value = 1024; // 正确 const int key; // 错误，const修饰必须初始化 默认状态下， const 对象仅在文件内有效 。 ​ 当以编译时初始化的方式定义一个 const 对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。即编译器会找到代码中所有用到变量的地方，替换成变量具体值。比如上述value，用到value的代码的地方，编译后全部被替换成1024。 ​ 编译器为了替换操作，必须在程序运行前知道变量的初始值。如果程序包含多个文件，则每个用了 const 对象的文件都必须能够访问到它的初始值。因此，必须在每个用到变量的文件中都对它进行定义。为了支持这一做法，同时避免对同一变量的重复定义，默认情况下， const 对象被设定为仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。 本人在vs2019的环境下，建立两个头文件test1.h和test2.h的头文件，分别定义const int data变量，一个初始化10，另一个初始化20，但是运行时报data重复定义(头部的#programe once去掉）。 ​ 如果不希望编译器为每个文件分别生成独立的变量，可以在变量声明定义时加上 extern 关键字。 // file_1.cc 定义初始化一个常量 extern const int bufSize = fcn(); // file_1.h extern const int bufSize; // 与file_1.cc中定义的bufSize是同一个 ​ file_1.h头文件的声明中也加了extern关键字，说明bufSize并非本文件所独有，它的定义在别处。 练习 练习2.26 下面哪些句子是合法的？如果有不合法的句子，请说明为什么？ (a) const int buf; (b) int cnt = 0; (c) const int sz = cnt; (d) ++cnt; ++ sz; (a) 不合法，常量必须初始化。(b)合法。(c)合法。(d)不合法，常量sz初始化之后不能再更改值。 2.41 const 的引用 ​ 可以把引用绑定到const对象上，即对常量的引用。其实就是给常量变量起了个别名，和正常的const对象一样，不能通过别名去更改const对象的值。 const int ci = 1024; const int &r1 = ci; r1 = 42; // 错误 int &r2 = r1; // 错误，不能将非常量引用指向一个常量引用。 初始化和对const的引用 ​ 引用的类型必须与其所引用对象的类型匹配，这里算是个特例：初始化常量时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。因此，允许一个常量引用绑定到非常量的对象、字面值，甚至一个表达式。 int i = 42; const int &r1 = i; const int &r2 = 42; const int r3 = r1 * 2; int &r4 = r1 * 2; // 不允许，r4是个非常量引用 编译器可能在运行过程中产生一个 临时量 。 double dval = 3.14; const int &ri = dval; 编译器编译后为了确保ri能绑定上一个数，自动添加代码： const int temp = dval; const int &ri = temp; 如果ri不是常量，编译器不会让代码编译通过，因为如果编译通过，那么ri绑定到的是temp，而非dval。 对const的引用可能引用一个并非const的对象 ​ 常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量不关心，所以引用的对象可能是个非常量，如果是个非常量，那就可以通过其他方法改变对象的值。因此对某些数据处理时，不希望处理的方法中改变原有数据，则可以对参数进行一个常量引用。 int i = 42; int &r1 = i; const int &r2 = i; r1 = 0; r2 = 0; // 不允许，r2是常量引用，不允许通过r2操作改变对象值 2.4.2 指针和 const ​ 可以令指针指向常量或非常量。 指向常量的指针 不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 const double pi = 3.14; double *ptr = &pi; // 错误，ptr是一个普通指针 const double *cptr = &pi; *cptr = 42; // 错误，不能给*cptr赋值 ​ 之前提到指针的类型必须与其所指向对象的类型一至，这里是特例，允许令一个指向常量的指针指向一个非常量对象： double dval = 3.14; cptr = dval; // 编译通过，但不能通过cptr改变dval的值 const 指针 ​ 常量指针就是把一个指针定为常量。常量指针必须初始化，一旦初始化完成，则它的值就不能再改变。把 * 放在 const 关键字之前用以说明指针是一个常量。即不可以改变指针的地址，但是可以改变指针所指向的对象的内容。 class Test{ public: double x; double y; Test() { x = 0.0; y = 0.0; } }; int main() { Test t; const Test* ptr = &t; // 指针常量 cptr->x = 10; // 错误，不能改变ptr指向对象的内容，但是可以改变ptr的地址 Test *const cptr = &t; // 常量指针 cptr->x = 10; // 正确，可以改变cptr指向对象的内容，但是不能改变cptr的地址 return 0; } 指向常量对象的常量指针 const double pi = 3.1415; const douboe *const ptr = &pi; // 意味着不能改变指针的地址，也不能改变指针指向对象的内容 练习 练习2.27 下面哪些初始化是合法的？ (a) int i = -1, &r = 0; (b) int *const p2 = &i2; (c) const int i = -1, &r = 0; (d) const int *const p3 = &i2; (e) const int *p1 = &i2; (f) const int &const r2; (g) const int i2 = i, &r = i; 答： (a)普通引用r绑定到字面值0上，这是不允许的。 (b)合法，p2是个常量指针，指向的地址不能变，但是可以改变i2对象的值。 (c)合法。 (d)合法。p3是一个指向常量的常量指针，不能改变指向的地址，也不能改变指向i2对象的内容。 (e)合法。p1是一个指向常量对象的指针，可以改变p1指向的地址，但是不能改变p1指向对象的内容。 (f)非法。引用本身不是一个对象。 (g)合法。 练习2.28 说明下面的这些定义是什么意思。挑出其中不合法的。 (a) int i, *const cp; (b) int *p1, *const p2; (c)const int ic, &r = ic; (d) const int *const p3; (e)const int *p; 答： (a) 不合法，i 是个int类型的普通变量。cp是个int类型的常量指针，必须要初始化。 (b) 不合法，p2是个常量指针，必须初始化。 (c)不合法， ic是个常量，必须初始化。 (d)不合法，p3是个指向常量对象的常量指针，必须要初始化。 (e) 合法，p是个指向常量的指针，不需要初始化。 练习2.29 假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？ (a) i = ic; (b) p1 = p3; (c) p1 = &ic; (d)p3 = &ic; (e) p2 = p1; (f)ic = *p3; 答： (a)合法，可以将int类型的常量赋值给普通变量i。 (b)不合法，不可以将普通变量指针指向一个指向常量的常量指针。 (c)不合法，不可以将普通变量指针指向一个常量对象。 (d)不合法，p3是个常量指针，不能再次赋值，应该在声明定义时对其进行初始化。 (e)不合法。p2是个常量指针，不能再次赋值，应该在声明定义时对其进行初始化。 (f)不合法。ic初始化之后不能再次赋值。 2.4.3 顶层 const ​ 顶层 const 表示指针本身是个常量，而 底层 const 表示指针所指的对象是个常量。 ​ 顶层const 可以表示任意的对象是常量， 底层const 则与指针和引用等复合类型的基本类型部分相关。 int i = 0; int *const p1 = &i; // 不能改变p1的值，可以改变p1指向对象的内容，这是一个顶层const const int ci = 42; // 不能改变ci的值，这是一个顶层const const int *p2 = &ci; // 允许改变p2的值，这是一个底层const const int *const p3 = p2; // 靠右的const是顶层const，靠左的const是底层const const int &r = ci; // 用于声明引用的const都是底层const 执行对象的拷贝操作时， 顶层const 几乎没什么影响。 i = ci; p2 = p3; 对 底层const 而言，拷贝和赋值的对象必须具有相同的 底层const 。 int *p = p3; // 错误，p3包含底层const，p是个普通变量指针， p2 = p3; // 正确，p2和p3都是底层const p2 = &i; // 正确，int*能转换成const int* int &r = ci; // 错误，普通的int&不能绑定到int常量上 const int &r2 = i; // 正确，const int&可以绑定到一个普通int上 练习 练习2.30 对于下面的这些语句，请说明对象被声明成了 顶层const 还是 底层const ？ const int v2 = 0; int v1 = v2; int *p1 = &v1, &r1 = v1; const int *p2 = &v2, *const p3 = &i, &r2 = v2; v2是顶层const；p2是底层const，p3及时底层const也是顶层const，r2是底层const。 2.4.4 constexpr 和常量表达式 ​ 常量表达式 是指值不会变并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。 const int max_files = 20; // max_files 是常量表达式 const int limit = max_files + 1; // limit是常量表达式 int staff_size = 27; // staff_size 不是常量表达式 const int sz = get_size(); // sz不是常量表达式 ​ sz是因为它的具体值直到运行时才能取到，所以也不是常量表达式。 constexpr 变量 ​ 在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始化值并非常量表达式的情况。在此种情况下，对象的定义和使用时两回事。 ​ c++11新标准规定，允许将标量声明为 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 。 constexpr int mf = 20; // 20 是常量表达式 constexpr int limit = mf + 1; // mf + 1是常量表达式 constexpr int sz = size(); // 只有当size是一个constexpr函数时，才是一条正确的声明语句 字面值类型 ​ 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。 ​ 算术类型、引用和指针都属于字面值类型。自定义类Sale_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。 ​ 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 ​ 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。此外，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体外的变量一样有固定地址。constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。 指针和constexpr ​ 在 constexpr 声明中如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。 const int *p = nullptr; // p是一个指向整型常量的指针 constexpr int *q = nullptr; // q是一个指向整型的常量指针 constexpr把它所定义的对象置为了 顶层const 。 constexpr int *np = nullptr; // np是一个指向整数的常量指针，其值为空 int j = 0; constexpr int i = 42; // i的类型是整型常量 // i和j都必须定义在函数体之外 constexpr const int *p = &i; // p是常量指针，指向整型常量i constexpr int *p1 = &j; // p1是常量指针，指向整数j 练习 练习2.32 下面的代码是否合法？如果非法，请设法将其修改正确。 int null = 0, *p = null; 答：非法， int null = 0, *p = &null;"
  },
  "Languages/Chapter2/2.5.html": {
    "href": "Languages/Chapter2/2.5.html",
    "title": "2.5 处理类型",
    "keywords": "2.5 处理类型 ​ 程序越是复杂，程序用到的类型也越复杂。一些类型难于拼写，名字难记容易拼错，程序员不能望明知意，有时不清楚需要定义什么类型，得联系程序的上下文。 2.5.1 类型别名 ​ 类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂名字变得简单明了，易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。 ​ 两种方法定义类型别名。传统方法是使用关键字typedef: typedef double wages; // wages 是double的同义词 typedef wages base, *p; // base 是double的同义词，p是double*的同义词 含有typedef关键字的声明语句定义的不再是变量而是类型别名。 新标准规定了一种新的方法，使用别名声明类定义类型的别名： using SI = Sales_item; // SI 是Sales_item的别名 如何使用类型别名 ​ 相当于类型别名就是绑定的类型的一个别名，就当一种类型使用即可。事实上，编译器编译的时候就是把使用wages的地方替换成double。 wages mike = 5000; // 相当于 double mike = 5000; 指针、常量和类型别名 ​ 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生一些意想不到的后果。 typedef char *pstring; // 是类型char*的别名 const pstring cstr = 0; // cstr 是指向char的常量指针 const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针。 ​ 因为 pstring 是指向 char 的指针， const pstring 就是指向char类型的常量指针，意味着cstr一旦初始化之后，就不能再次更改其所指向的地址。因此不能把 const pstring cstr = 0 等同于 const char* cstr = 0 。 2.5.2 auto类型说明符 ​ 编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引进auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须知道初始值。 auto item = val1 + val2; // item的类型通过val1和val2相加的结果推算出来 ​ 同时也要注意，在一条语句声明多个变量中，变量的初始值要确保类型相同。 auto i = 0, * p = &i; // 正确，auto为int类型 auto sz = 0, pi = 3.14; // 错误，sz为int，而pi为double 复合类型、常量和auto ​ 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。 ​ auto一般会忽略掉顶层const，保留底层const。 const int ci = i, &cr = ci; auto b = ci; // b 是个int类型，而不是const int auto c = cr; // c 是个int类型，而不是const int auto d = &i; // d 是个整型指针 auto e = &ci; // e 是个指向整数常量的指针 因此如果希望推断出的auto类型是个顶层const，需要显示定义出来。 const auto f = ci; // ci 推演出int类型，则f是const int 和引用结合： auto &g = ci; // g是一个整型常量引用，绑定ci auto &h = 42; // 错误，不能为非常量引用绑定字面值 const auto &j = 42; // 正确 练习 练习 2.33 判断下列语句的运行结果 a = 42; b = 42; c = 42; d = 42; e = 42; g = 42; a是int类型，可再次赋值，运行正确。 b是int类型，可再次赋值，运行正确。 c是int类型，可再次赋值，运行正确。 d是整型指针，赋值42是错误的行为。 e是一个指向整数常数的指针，赋值42是错误行为。 g是一个整型常量引用，不可再次赋值。错误行为。 练习2.34 略 练习2.35 判断下列定义推断出的类型是什么，然后编写程序进行验证。 const int i = 42; auto j = i; const auto &k = i; auto *p = &i; const auto j2 = i, &k2 = i; j是int类型变量； k是对i对象的const int类型引用。 p是指向常量int的指针。 j2是常量int类型变量。 k2是对i对象的常量引用。 2.5.3 decltype 类型指示符 ​ 希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。C++11新标准引入第二种类型说明符 decltype ，其作用是选择并返回操作数的数据类型。在编译过程中，编译器分析表达式并得到其类型，却不实际计算表达式的值。 decltype(f()) sum = x; // sum类型就是函数f的返回类型 编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。 ​ decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用表达式是一个变量，则decltype返回该变量的类型。 const int ci = 0, &cj = ci; decltype(ci) x = 0; // x 的类型是const int decltype(cj) y = x; // y 的类型是const int&,y绑定到变量x decltype(cj) z; // 错误，z是一个引用，必须初始化 decltype和引用 ​ 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。 // decltype 的结果可以是引用类型 int i = 42, *p = &i, &r = i; decltype(r+0) b; // 正确，加法结果是int类型，所以b是一个int类型变量 decltype(*p) c; // 错误，c是int&, 必须初始化 如果表达式的内容是解引用操作，decltype将得到引用类型。 ​ decltype与auto的一个重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有所不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型。如果给变脸加上一层或多层括号，编译器就会把它当成一个表达式。变量时一种可以作为赋值语句左值的特殊表达式。 // decltype的表达式如果是加了括号的变量，结果将是引用 decltype((i)) d; // 错误，d是int&，必须初始化 decltype(*p) c; // 正确，e是一个int decltype((variable))（双层括号）的结果永远是引用，而decltype(variable)结果是只有当variable本身就是一个引用时才是引用。 练习 练习 2.36 请指出每一个变量的类型以及程序结束时它们各自的值。 int a = 3, b = 4; decltype(a) c = a; decltype((b)) d = a; ++c; ++d; a是int类型变量； b是int类型变量； c是int类型变量； d是int&类型变量，是对a的引用； 程序结束时，a的值为4；b是4；c是4；d是4； 练习2.37 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果i是int类型，则表达式i=x的类型是int&。根据这一特点，指出下面代码中每一个变量的类型和值。 int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // 这里d的类型是int& 变量名 类型 程序运行结束时的值 a int 3 b int 4 c int3 3 d int 3 练习2.38 说明decltype指定类型和由auto指定类型有何区别。 // case1: int i = 10； auto x = i; // x是int类型 decltype(i) v = i; // v是int类型 //case2: const int i = 10; auto x = i; // x 是int类型 decltype(i) v = i; // v是const int类型"
  },
  "Languages/Chapter2/2.6.html": {
    "href": "Languages/Chapter2/2.6.html",
    "title": "2.6 自定义数据结构",
    "keywords": "2.6 自定义数据结构 ​ 数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。C++允许用户以类的形式自定义数据雷兴国，而库类型string、istream、ostream等也都是以类的形式定义的。 此处内容不做笔记，详情参考第一章1.5节相关类的介绍。"
  },
  "Languages/Chapter3/3.1.html": {
    "href": "Languages/Chapter3/3.1.html",
    "title": "3.1 命名空间 using 的声明",
    "keywords": "3.1 命名空间 using 的声明 std::cin表示从标准输入中读取内容。作用域操作符::的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。故std::cin 的意思就是使用命名空间std中的名字cin。 如果在代码文件的前部使用：using namespace::name; 声明了语句，就可以直接访问命名空间name中的名字。 #include <iostream> using std::cin; int main() { int i; cin >> i; // 正确 cout << i; // 错误 std::cout << i; // 正确 return 0; } 每个名字都需要独立的using声明 如果想用std作用域下的所有名字，可以使用这样的声明方式： using namespace std; #include <iostream> using namespace std; int main() { int i; cin >> i; // 正确 cout << i; // 正确 std::cout << i; // 正确 return 0; } 头文件不应包含using声明 头文件的代码不应使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。"
  },
  "Languages/Chapter3/3.2.html": {
    "href": "Languages/Chapter3/3.2.html",
    "title": "3.2 标准库类型 string",
    "keywords": "3.2 标准库类型 string 标准库类型 string 表示可变长的字符序列，使用 string 类型必须首先包含 string 头文件。string 定义在命名空间 std 中。 3.2.1 定义和初始化 string 对象 初始化 string 对象常用的一些方式： string s1; // 空字符串 string s2 = s1; // s2是s1的副本 stirng s3 = \"hello\"; // s3是字符串hello的副本 string s4(10,'c'); // s4的内容是cccccccccc 如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所以的字符都被拷贝到新建的 string 对象中去。 代码 解释 string s1; 默认初始化，空串。 string s2(s1); s2是s1的副本。 string s2=s1; s2是s1的副本。 string s3(\"value\"); s3是字面值“value”的副本，除了字面值最后的那个空字符。 string s3 = \"value\"; 等价于 string s3(\"value\");。 string s4(n,'c'); 把s4初始化为连续n个字符c组成的串。 直接初始化和拷贝初始化。 使用等号(=)初始化一个变量，实际上是执行拷贝初始化，编译器把等号右侧的初始值拷贝到新建的对象中去。如果不使用等号，则执行的是直接初始化。(对基本类型也是适用的) int s(5); cout << s << endl; // 输出 5 3.2.2 string 对象上的操作 一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义<<、+等各种运算符在该类的新含义。 接口名 解释 os << s 将 s 写到输出流 os 当中，返回 os。 is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给s，返回 is。 s.empty() s 为空返回true，否则返回false。 s.size() 返回 s 中字符的个数。 s[n] 返回 s 中第n个字符的引用，位置 n 从0开始。 s1 + s2 返回 s1 和 s2 连接后的结果。 s1=s2 用 s2 的副本代替 s1 中原来的字符。 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等，返回true，否则返回false；判断对字母的大小写敏感。 s1!=s2 如果s1和s2中所含的字符完全一样，返回false，否则返回true；判断对字母大小写敏感 <，<=，>，>= 利用字符在ASCII字典中的顺序进行比较，且对字母大小写敏感。 string s1 = \"aacdaa\"; string s2 = \"abcd\"; if(s1 > s2) { cout << \"hit true s1 < s2\"; } // 如果s1 = \"accdaa\",则hit ture,因为第二个字符，c比b大 else { cout << \"hit false s\";} // hit false getline 代替>>运算符可以得到输入时的空白符。 string line; while (getline(cin, line)) cout << line << endl; empty和size的应用。 string line; while (getline(cin, line)) if(!line.empty()) // 空串不输出 cout << line << endl; string line; while (getline(cin, line)) if(line.size() > 20) // 超过20个字符才会输出 cout << line << endl; string::size_type 类型 size函数返回的是一个string::size_type类型而不是int类型。可以通过auto或decltype来推断变量的类型： auto len = line.size(); // len的类型是string::size_type size_type是一个无符号类型的值而且足够存放下任何string对象的大小。因此所有用于存放string类型的size函数返回值的变量，都应该是string::size_type类型。 因此应当小心使用带有int类型的变量与size()构成表达式，因为形如s.size()<n的判断结果，如果n是负数，则表达式中，赋值n会自动转换成一个比较大的无符号值 。 比较 string 对象 ==和!=分别检验两个 string 对象相等或不相等，string 对象相等意味着它们长度相同而且所包含的字符也全都相同。关系运算符>、<、>=、<=分别校验一个 string 对象是否小于、大于、小于等于、大于等于另外一个 string 对象。上述运算符依照ASCII码(大小写敏感)字典顺序: 如果两个 string 对象的长度不同，而且较短 string 对象的每个字符都与较长 string 对象对应位置上的字符相同，就说较短 string 对象小于较长 string 对象。 如果两个 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实是 string 对象中第一对相异字符比较的结果。 字面值和string对象相加 标准库允许字符字面值和字符串字面值转换成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面值代替。 当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算(+)的两侧的运算对象至少有一个是 string类型。 string s4 = s1 + \",\"; // 正确 string s5 = \"hello\" + \", world!\"; // 错误 string s6 = \"hello\" + s2 + \",please.\"; // 正确 string s7 = \"hello\" + \", world\" + s2; // 错误 string s7 = s2 + \"hello\" + \", world\"; // 正确，s2 + \"hello\"返回的是一个string对象，所以可以继续和后面的字符串相加 C++语言中的字符串字面值不是标准库中的string类型对象。 练习 练习 3.2 ：编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词。 int main() { string line; while (getline(cin, line)) // 读入一行 { cout << line << endl; // 打印 } return 0; } ----------------------------------------------- int main() { string word; while (cin >> word) // 读入数据，遇见空格符进入循环体 { cout << word << endl; // 打印 } return 0; } 练习 3.3 ：请说明 string 类的输入运算符和 getline 函数分别是如何处理空白字符的。 ​ 输入运算符遇到空白符就结束输入，因此输入的串中不会保留有空白字符。getline是保留输入时的空白符，从给定的输入流中读入内容，知道遇到换行符为止（换行符也被读进来了），之后把所读的内容存入到参数string对象中（去掉换行符）。总结就是，输入运算符是遇到空白符就停止输入并返回结果，getline函数是遇到换行符就停止输入并返回结果。 练习 3.4 ：编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等，输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。 int main() { string line1, line2; cout << \"input first line:\" << endl; getline(cin, line1); cout << \"input second line:\" << endl; getline(cin, line2); if (line1 == line2) // 字符串相等 { cout << \"相等：\" << line1 << endl; } else if (line1 > line2) // line1 比较大，输出line1 { cout << line1 << endl; } else // line2 比较大，输出line2 { cout << line2 << endl; } return 0; } 改写后： int main() { string line1, line2; cout << \"input first line:\" << endl; getline(cin, line1); cout << \"input second line:\" << endl; getline(cin, line2); auto len1 = line1.size(); auto len2 = line2.size(); if (len1 == len2) // 两个string对象长度相等 { cout << \"相等：\" << line1 << endl; } else if (len1 > len2) // line1 长度更长 { cout << line1 << endl; } else // line2 长度更长 { cout << line2 << endl; } return 0; } 练习 3.5 ：编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。 int main() { string line, sum; int count = 5; for (; count > 0; count--) // 输入5个字符串 { getline(cin, line); sum += line; // 拼接起来 } cout << sum << endl; return 0; } 改写： int main() { string line, sum; int count = 5; for (; count > 0; count--) // 输入5个字符串 { getline(cin, line); sum += line + \" \"; // 拼接起来 } cout << sum << endl; return 0; } 3.2.3 处理 string 对象中的字符 有时候需要单独处理 string 对象中的字符： 检查一个 string 对象是否有空白字符。 把字符中的大写变小写。 查看某个特定字符是否出现。 cctype头文件中定义了一组标准库函数处理这部分工作。 函数名 解释 isalnum(c) 当c是字母或者数字时为真。 isalpha(c) 当c是字母时为真。 iscntrl(c) 当c是控制字符时为真。 isdigit(c) 当c是数字时为真。 isgraph(c) 当c不是空格但可打印时为真。 islower(c) 当c是小写字母时为真。 isprint(c) 当c是可打印字符时为真。（即c是空格或c具有可视形式） ispunct(c) 当c是标点符号时为真。（即c不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当c是大写字母时为真。 isxdigit(c) 当c是十六进制数字时为真。 tolower(c) 如果c是大写字母，输出对应的小写字母；否则原样输出。 toupper(c) 如果c是小写字母，输出对应的大写字母；否则原样输出。 因此如果检查一个 string 对象是否包含某种空白字符，就可用到cctype头文件中的函数，遍历string对象串中每个字符进行处理。 遍历 string 对象可以用C++11最新提供的范围 for 语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作： for (declaration : expression) statement; 示例：统计字符串中标点符号的个数 #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"hello, world.\"; decltype(s1.size()) punct_nt = 0; // 标点符号个数 for (auto c : s1) { if (ispunct(c)) { punct_nt++; } } cout << punct_nt << \" punctuation characters in \" << s1 << endl; return 0; } // 输出结果： 2 punctuation characters in hello, world. 示例：将串改成小写字母 #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"HELLO, WORLD.\"; string s2; // 用于保存结果 for (auto c : s1) { s2 += tolower(c); } cout << \"after translate: \" << s2 << endl; return 0; } // 输出结果：after translate: hello, world. 书本上的示例： #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"HELLO, WORLD.\"; for (auto &c : s1) { c = tolower(c); // 如果s1是const常量类型，就不可用这种方式实现 } cout << \"after translate: \" << s1 << endl; return 0; } 使用下标运算符 将一行的首字母改为大写： #include <iostream> #include <string> #include<cctype> using namespace std; int main() { string s1 = \"hello, world.\"; if (!s1.empty()) // 判断是否为空，如果为空，不能访问下标，这样会造成越界 { s1[0] = toupper(s1[0]); } cout << \"after translate: \" << s1 << endl; // 输出结果：after translate: Hello, world. return 0; } 使用下标执行遍历： int main() { string s1 = \"hello, world.\"; for (decltype(s1.size()) index = 0; index != s1.size() && !isspace(s1[index]); index++) { s1[index] = toupper(s1[index]); } cout << \"after translate: \" << s1 << endl; // 运行结果：after translate: HELLO, world. return 0; } 使用下标执行随机访问 编写一个程序把0到15之间的十六进制数转换成对应的十六进制数形式，只需初始化一个字符串令其存放16个十六进制“数字”。 int main() { const string hexdigits = \"0123456789ABCDEF\"; // 可能的十六进制数字 cout << \"enter a series of number between 0 to 15\" << \"separated by spaces. Hit ENTER when finished: \" << endl; string result; // 用于保存十六进制的字符串 string::size_type n; // 用于保存从输入流读取的数 while (cin >> n) { if (n < hexdigits.size()) { result += hexdigits[n]; // 得到对应的十六进制数字 } } cout << \"Your hex number is :\" << result << endl; return 0; } 练习 练习3.6 ：编写一段程序，使用范围for语句将字符串内的所有字符用X代替。 int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; for (auto& c : s1) // 范围for遍历 { if (isalpha(c)) { c = 'X'; } } cout << s1 << endl; return 0; } // 运行： // since i own you 3000 dollars, i will give you 2000 two days late. // XXXXX X XXX XXX 3000 XXXXXXX, X XXXX XXXX XXX 2000 XXX XXXX XXXX. 练习 3.7 ：就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什么？先预估一下结果，再实际编程进行验证。 一样啊，没什么变化。 练习 3.8 ：分别用while循环和传统for循环重写第一题的程序，你觉得那种形式更好？为什么？ while循环： int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; decltype(s1.size()) index = 0; while (index !=s1.size()) { if (isalpha(s1[index])) { s1[index] = 'X'; } index++; } cout << s1 << endl; return 0; } 传统for： int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; for (decltype(s1.size()) index = 0; index != s1.size(); index++) { if (isalpha(s1[index])) { s1[index] = 'X'; } } cout << s1 << endl; return 0; } 运行结果都一样，如果字符串不是const常量，用范围for更简洁。while和传统for没什么区别。 练习 3.9 ：下面的程序有何作用？它合法吗？如果不合法，为什么？ string s; cout << s[0] << endl; 输出s串的第一个字符。不合法，因为没对s串进行判断第一个字符串是否存在，如果不存在，就存在越界访问的行为，后果可能导致软件程序崩溃。 练习 3.10 ：编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。 int main() { string s1 = \"since i own you 3000 dollars, i will give you 2000 two days late.\"; cout << s1 << endl; string temp; // 保存结果 for (auto& c : s1) { if (!ispunct(c)) { temp += c; } } s1 = temp; cout << s1 << endl; return 0; } // 运行结果: since i own you 3000 dollars, i will give you 2000 two days late. // since i own you 3000 dollars i will give you 2000 two days late 练习 3.11 ：下面的范围for语句合法吗？如果合法，c的类型是什么？ const string s = \"keep out!\"; for(auto &c : s){/*...*/} 不合法，s是个const string类型，是不允许再次更改内容，而&c是引用，可能导致在for循环体内对c进行赋值操作。 c的类型是char&。"
  },
  "Languages/Chapter3/3.3.html": {
    "href": "Languages/Chapter3/3.3.html",
    "title": "3.3 标准库类型 vector",
    "keywords": "3.3 标准库类型 vector ​ 标准类型库 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。也称为容器。使用 vector，必须包含头文件 #include<vector> using std::vector; // vector是一个类模板 vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不包含引用的vector。组成vector的元素也可以是vector（有点像二维数组）。 某些编译器可能需以老式声明语句处理元素为vector的vector对象，如 vector<vector<int> > ，而不是 vector<vector<int>> 。 3.3.1.定义和初始化 vector 对象 定义 vector 对象的常用方法。 定义 释义 vector v1 v1 是一个空 vector，它潜在的元素T类型，执行默认初始化。 vector v2(v1) v2中包含有v1所有元素的副本。 vector v2=v1 等价于v2(v1)。 vector v3(n, val) v3 包含了n个重复的元素，每个元素的值都是val。 vector v4(n) v4 包含了n个重复执行了值初始化的对象。 vector v5{a,b,c,d} v5 包含了初始值个数的元素，每个元素被赋予相应的初始值。 vector v5={a,b,c,d} 等价于vector v5{a,b,c,d} vector 拷贝需要注意两个vector对象类型必须相同： vector<int> ivec; vector<int> ivec2(ivec); vector<int> ivec3 = ivec2; vector<string> ivec4 = ivec2; // 错误，类型不一样 列表初始化 vector 对象 vector<string> articles = {\"a\", \"an\", \"the\"}; 含三个元素，“a”、“an”、“the”。 创建指定数量的元素 vector<int> ivec(10,-1); // 10 个int类型的元素，每个都被初始化为-1 vector<string> svec(10,\"hi!\"); // 10 个string类型的元素，每个都被初始化为 hi! 值初始化 只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋值给容器中的所有元素。这个初始值由vector对象中元素的类型决定。 vector<int> ivec(10); // 10个元素，每个都初始化为0 vector<string> svec(10); // 10个元素，每个都是空string对象 如果有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。 如果只提供了元素数量而没有设定初始值，只能使用直接初始化。 vector<int> vi = 10; // 错误 圆括号和尖括号初始化的不同 vector<int> v1(10); // v1有10个元素，每个元素值为0 vector<int> v2{10}; // v2有1个元素，值为10 vector<int> v3(10, 1); // v3有10个元素，每个值为1 vector<int> v4{10, 1}; // v4有两个元素，值分别为10,1 vector<string> v5{\"hi\"}; // 列表初始化：v5只有一个元素 vector<string> v6(\"hi\"); // 错误 vector<string> v7{10}; // v7有10个默认初始化的元素 vector<string> v8{10, \"hi\"}; // v8有10个值为hi的元素 练习 练习3.12 ：下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。 (a) vector<vector<int>> ivec; (b) vector<string> svec= ivec; (c) vector<string> svec(10, \"null\"); (a) 对c++11来说是正确的，老版c++不正确。 (b) 不正确，svec和ivec类型不匹配。 (c) 对。 练习3.13 ：下列的vector对象各包含多少个元素？这些元素的值分别是多少？ (a) vector<int> v1; (b) vector<int> v2(10); (c) vector<int> v3(10, 42); (d) vector<int> v4{10}; (e) vector<int> v5{10, 42}; (f) vector<string> v6{10}; (g) vector<string> v7{10, \"hi\"}; (a) 包含0个元素。 (b) 包含10个元素，每个元素值为0。 (c) 包含10个元素，每个元素值为42。 (d) 包含1个元素，值为10。 (e) 包含2个元素，值分别为10和42。 (f) 包含10个元素，值为空串。 (g) 包含10个元素，每个值为“hi”。 3.3.2 向 vector 中添加元素 push_back函数可以向vector函数中添加新的元素。新元素会被添加到vector尾部。 vector<int> v2; for(int i =0; i < 10; i++) { v2.push_back(i); } // 将1-9一共10个int类型对象按序放到v2尾部 vector对象能高效增长。不需要初始化时指定vector的大小。指定大小了反而会导致动态添加元素时性能的降低。 练习 练习3.14 ：编写一段程序，用cin读入一组整数并把它们存入一个vector对象。 int i; vector<int> ivec; while(cin>i) { ivec.push_back(i); } 练习3.15 ：改写上题的程序，不过这次读入的是字符串。 string word; vector<string> ivec; while(cin > word) { ivec.push_back(word); } 3.3.3 vector 其他操作 方法名 释义 v.empty() 如果v不含有任何元素，返回true；否则返回false。 v.size() 返回v中元素的个数。 v.push_back(t) 向v的尾部添加一个值为t的元素。 v[n] 返回v中第n个位置上元素的引用。 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a, b, c, d} 用列表中的元素拷贝替换v1中的元素v1 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <，<=，>，>= 以字典顺序比较。 计算 vector 内对象的索引 使用下标运算符能获取到指定的元素。vector 对象下标的起始是从0开始记起，下标对应的类型是size_type: vector<int>::size_type // 正确 vector::size_type // 错误 // 以 10分为一个分数段统计成绩的数量：0-9,10-19，...，90-99，100 vector<unsigned> scores(11, 0); // 11个分数段，全都初始化为0 unsigned grade; while(cin >> grade) // 读入成绩 { if(grade <= 100) // 只处理有效的成绩 ++scores[grade/10]; // 将对应分数段的计数值+1 } for(auto count: socres) { cout << count << \" \"; } // 输入 42 65 95 100 39 67 95 76 88 76 83 92 76 93 // 输出 0 0 0 1 1 0 2 3 2 4 1 不能用下标形式添加元素 vector不能通过下标的方式添加vector集合中的元素。 vector<int> ivec; for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec[ix] = ix; // 错误 } // 可以理解为vector长度为0的数组，因此，不能通过下标的方式添加新元素 ----------------------------------------------------------------- vector<int> ivec(10); for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec[ix] = ix; // 正确 } ----------------------------------------------------------------- vector<int> ivec; for(decltype(ivec.size()) ix = 0; ix != 10; ++ix) { ivec.push_back(ix); // 错误 } 练习 练习3.16 ：编写一段程序，把 练习3.13 中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确。 vector<int> v2; for(int i =0; i < 10; i++) { v2.push_back(i); } // 将1-9一共10个int类型对象按序放到v2尾部 for(auto i : v2) { cout << i << \" \"; } 练习3.17 ：从 cin 读入一组词并把它们存入一个 vector 对象，然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。 string word; vector<string> svec; while (cin >> word) { svec.push_back(word); } for (auto& s : svec) { for (auto& c : s) { c = toupper(c); } } for (auto s : svec) { cout << s << endl; } return 0; 练习3.18 ：下面的程序合法吗？如果不合法，你准备如何修改？ vector<int> ivec; ivec[0]=42; 不合法，修改： vector<int> ivec; ivec.push_back(42); ---------------------------------- // 或者 vector<int> ivec(1); ivec[0] = 42; 练习3.19 ： 如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请列举三种不同的实现方法。哪种方法更好呢？为什么？ // 方法一： vector<int> vec(10, 42); // 方法二： vector<int> vec{42, 42, 42, 42, 42, 42, 42, 42, 42, 42}; // 方法三： vector<int> vec = {42, 42, 42, 42, 42, 42, 42, 42, 42, 42}; 当然是第一种方法好，理由是代码更简洁。 练习3.20 ：读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒数第2个元素的和，以此类推。 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; decltype(vect.size()) len = vect.size(); // 从第一个和第二个元素开始计算，依次类推 for (int i = 0; i < len - 1; i++) { cout << (vect[i] + vect[i + 1]) << endl; } 改写后： vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; decltype(vect.size()) len = vect.size(); // 奇数个数则不再计算中间的数 for (int i = 0; i < len / 2; i++) { cout << (vect[i] + vect[len -i -1]) << endl; }"
  },
  "Languages/Chapter3/3.4.html": {
    "href": "Languages/Chapter3/3.4.html",
    "title": "3.4 迭代器介绍",
    "keywords": "3.4 迭代器介绍 对于string和vector对象，可以通过下标的方式访问其中的元素，也可以通过迭代器的机制访问元素。 3.4.1使用迭代器 和指针不同，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器。 // b表示v的第一个元素，e表示v尾元素的下一位置 auto b = v.begin(), e = v.end(); 迭代器运算符 运算符 释义 *iter 返回迭代器iter所指元素的引用。 iter->mem 解引用并获取该元素的名为mem的成员，等价于(*iter).mem ++iter 令iter指示容器的下一个元素。 --iter 令iter指示容器的上一个元素。 iter1 == iter2 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾后迭代器，则相等。反之，不等。 iter1 != iter2 与iter1 == iter2 相反。 和指针类似，可以通过解引用迭代器获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或尾后迭代器都是未被定义的行为。 string s(\"some thing\"); if(s.begin()!s.end()){ // 确保s非空 auto it = s.begin(); // it 表示s的第一个字符 *it = toupper(*it); // 首个单词的首字母大写。 } 将迭代器从一个元素移动到另一个元素 使用递增运算符（++）： for( auto it = s.begin(); it != s.end(); it++) { *it = toupper(*it); // 依次将当前字符改写成大写形式 } 迭代器类型 我们不知道也无需知道迭代器的精确类型。那些拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型。 vector<int>::iterator it; // it 能读写vector<int> 的元素。 string::iterator it2; // it2 能读写 string 对象中的字符 vector<int>::const_iterator it3; // it3只能读元素，不能写元素 string::const_iterator it4; // it4 只能读元素，不能写元素 可以理解为iterator是个指针，指向对象可读可写。const_iterator 是个指向常量的指针变量，指向的对象可读不可写。 begin和end运算符 begin和end运算符返回的具体类型由对象是否是常量决定。 运算符 常量对象的返回类型 非常量对象的返回类型 begin const_iterator iterator end const_iterator iterator C++11专门引入两个新函数。cbegin和cend。无论对象是否是常量，cbegin和cend返回值都是const_iterator类型。 结合解引用和成员访问操作 // 假如需要读取 vector<string> 对象的内容，判断是否为空串 (*it).empty() // 解引用it，然后调用结果对象的empty()成员 *it.empty() // 错误，尝试读取it的empty成员，it是个迭代器，没有empty成员 箭头运算符将解引用和成员访问操作结合在一起。 it->empty() //等价于(*it).empty() 注意事项 不能在范围for循环中向vector对象添加元素。任何一种可能改变vector对象容量的操作，如push_back，都会使该vector对象的迭代器失效。 3.4.2 迭代器运算 迭代器的算术运算 迭代器和一个整数值相加或相减，其返回值是向前或向后移动了若干个位置的迭代器。类似指针在迭代器“连续”的地址中前进或后退。 可以运用运算符(>、>=、<、<=)进行指向同一个容器的两个迭代器之间的前后关系。 // 计算得到最接近vi中间元素的一个迭代器 auto mid = vi.begin() + vi.size() / 2; if(it < mid) // 处理vi的前半部分元素 使用迭代器运算 二分搜索： // text 必须有序 auto beg = text.begin(), end = text.end(); auto mid = text.begin() + (end - beg) / 2; // 初始状态下的中间点 // 当还有元素尚未检查并且还没有找到sought时执行循环 while(mid != end && *mid != sought) { if(sought < *mid) end = mid; // 在 mid 之前找 else beg = mid + 1; // 在 mid 之后找 mid = beg + (end - beg) / 2; // 新的中间点 } 练习 练习3.24 ：请使用迭代器重做3.3.3节的最后一个练习。 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14 }; for (auto beg = vect.cbegin(); beg != vect.cend() - 1; beg++) { cout << (*beg) + *(beg + 1) << endl; } // 输出结果 15 15 15 15 15 15 15 改写后： // 奇数个数，则不输出中间位和自己相加 vector<int> vect = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 }; auto mid = vect.cbegin() + vect.size() / 2; // 中间位置 for (auto cbeg = vect.cbegin(), cend =vect.cend() - 1; cbeg != mid; cbeg++, cend--) { cout << (*cbeg) + (*cend) << endl; } // 输出结果 16 16 16 16 16 16 练习3.25 ：3.3.3节划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序并实现完全相同的功能。 // 以 10分为一个分数段统计成绩的数量：0-9,10-19，...，90-99，100 vector<unsigned> scores(11, 0); // 11个分数段，全都初始化为0 unsigned grade; auto beg = scores.begin(); while (cin >> grade) // 读入成绩 { if (grade <= 100) // 只处理有效的成绩 *(beg+ grade / 10) = *(beg + grade / 10) + 1; // 将对应分数段的计数值+1 } for (auto count : scores) { cout << count << \" \"; } 练习3.26 :在100页的二分搜索程序中，为什么用的是mid=beg+(end - beg) / 2，而非mid = (beg + end) / 2？ end - beg 表示两个迭代器的距离，除2再加上beg就得到了中间位置。显然(beg + end)/2得到的并不是迭代器的中间位置。"
  },
  "Languages/Chapter3/3.5.html": {
    "href": "Languages/Chapter3/3.5.html",
    "title": "3.5 数组",
    "keywords": "3.5 数组 ​ 数组是一种类似标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。数组是存放类型相同的对象的容器，这些对象本身没有名字，可以通过其所在位置访问。数组大小固定不变，不能随意向数组中添加元素。可见灵活性差了点。 3.5.1 定义和初始化内置数组 数组中的元素个数必须大于0；编译时维度，即数组个数应该是已知的。 unsigned int cnt = 42; // 不是常量表达式 constexpr unsigned int sz = 42; // 常量表达式 int arr[10]; // 含有10个整数的数组 int* parr[sz]; // 含有42 个整型指针 string bad[cnt]; // 错误，cnt不是常量表达式 string strs[get_size()]; // 当get_size是constexpr 时正确，否则错误 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 显示初始化数组 const unsigned sz = 3; int ia1[sz] = {0, 1, 2}; // 含有3个元素的数组，元素值分别是0 ， 1， 2 int a2[] = {0, 1, 2}; //维度是3的数组 int a3[5] = {0, 1, 2}; // 等价于 a3={0,1,2,0,0} string a4[3] = {\"hi\", \"bye\"}; // 等价于a4[] = {\"hi\", \"bye\", \"\"} int a5[2] = {0, 1, 2}; // 错误，初始值过多 字符数组的特殊性 字符字面值的结尾处有一个空字符，不显示在代码中。 char a1[] = {'C', '+', '+'}; // 列表初始化，没有空字符 char a2[] = {'C', '+', '+', '\\0'}; // 列表初始化，含有显式的空字符 char a3[] = \"c++\"; // 自动添加表示字符串结束的空字符 const char a4[6] = \"Daniel\"; // 错误，没有空间可存放空字符 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： int a[] = {0, 1, 2}; int a2[] = a; // 错误 a2 = a; // 错误 理解复杂的数组声明 int *ptrs[10]; // ptrs是含有10个整型指针的数组 int &refs[10] = /*?*/; // 错误，不存在引用数组 int (*Parray)[10] = &arr; // Parray 指向一个含有10个整数的数组。 int (&arrRef)[10] = arr; // arrRef 引用一个含有10个整数的数组。 (*Parray)[0] = 10; // 正确使用 arrRef[0] = 100; // 正确使用 int* (&array)[10] = ptrs; // array 是数组的引用，该数组含有10个指针 练习 练习3.27 假设 txt_size 是一个无参数的函数，它的返回值是 int。请回答下列哪个定义是非法的，为什么？ unsigned buf_size = 1024; (a)int ia[buf_size]; (b)int ia[4 * 7 - 14]; (c)int ia[txt_size()]; (d) char st[11] = \"fundamental\"; a是非法的，buf_size不是常量，数组在编译时就必须知道其大小。 c是非法的，理由同a。 d是非法的，字符串字面值结尾有一个隐含的空格字符，\"fundamental\"实际上的长度为12。 练习3.28 下列数组中元素的值是什么？ string sa[10]; int ia[10]; int main() { string sa2[10]; int ia2[10]; } sa中含有10个空字符串； ia含有10个初始化为0的字符串； sa2数组有10个未定义的string类型； ia2数组含有10个未定义的值。 如果打印每个数组的信息的话： ia的打印信息为： 0 0 0 0 0 0 0 0 0 0 ia2的打印信息为： -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有为定义的值。 3.5.2 访问数组元素 可以使用范围for语句或者下标运算符访问数组元素。数组索引从0开始。 unsigned scores[11] = {}; // 11 个分数段，全部初始化为0 unsigned grade; while( cin>> grade) { if(grade <= 100) ++scores[grade/10]; // 将当前分数段的计数值加1 } for( auto i : scores) { cout << i << \" \"; } 检查下标的值 编译器编译时并不会检查数组下标是否越界，要靠人工检查。要防止越界行为，因为越界产生各种意想不到的后果。 练习 练习3.30 指出下面代码中的索引错误。 constexpr size_t array_size = 10; int ia[array_size]; for(size_t ix = 1; ix <= array_size; ++ ix) ia[ix] = ix; 数组索引的下标从0开始，而for语句中的ix从1开始，遍历下标从1到10，ia[10]导致数组越界。 练习3.31 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。 int arr[10]={}; for(int index = 0; index < 10; index++) { arr[index] = index; } 练习3.32 将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。 int arr2[10]; for(int i = 0;i < 10; i++) { arr2[i] = arr[i]; } 练习3.33 对于104页的程序来说，如果不初始化scores将会发生什么？ 因为函数内部定义的数组默认初始化是未定义的值，因此可能导致数据并不是预期的。 3.5.3 指针和数组 ​ 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针。 string nums[] = {\"one\", \"two\", \"three\"}; // 数组的元素是string对象 string *p = &nums[0]; // p指向nums的第一个元素 // 用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。 string *p2 = nums; // 等价于 p2 = &nums[0]; int ia2[10] = {}; int* p = &ia2[3]; *p = 1; p++; *p = 2; for(auto s : ia2) { cout << s << \" \"; } // 打印 0 0 0 1 2 0 0 0 0 0 ​ 在一些情况下，对数组的操作，实际上是对指针的操作。如果对数组使用auto变量的初始值时，推断得到的类型是指针而非数组。 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素，等价于 auto ia2(&ia[0]) ia2 = 42; // 错误。ia2是个指针 ​ 但是如果用decltype关键字时，decltype(ia)返回的类型是由10个整数构成的数组： decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; // 错误，ia3不能用整型指针给数组赋值 ia3[4] = i; // 正确 int *e = &arr[10]; // arr数组只有10个元素，arr[10]是arr数组的最后一个元素指向的下一个位置 for(int *b = arr; b != e; ++b) { cout << *b << endl; // 输出arr的元素 } 标准库函数begin和end ​ C++11标准引入两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。这两个函数定义在头文件 iterator 中。 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7 , 8, 9}; int *beg = begin(ia); // 指向ia首元素的指针 int *last = end(ia); // 指向arr尾元素的下一位置的指针 int *pbeg = begin(arr), *pend = end(arr); // 寻找第一个负值元素，如果已经检查完全部元素则结束 while(pbeg != pend && *pbeg > 0) pbeg++; 指针运算 ​ 可以把指针看做是一种迭代器，可以解引用、递增、比较、与整数相加、两个指针相减。 constexpr size_t sz = 5; int arr[sz] = {1, 2, 3, 4, 5}; int *ip = arr; int *ip2 = ip + 4; // ip2指向arr的尾元素arr[4] // 正确，arr转换成指向它的首元素的指针；p指向arr尾元素的下一位置 int *p = arr + sz; // 不要使用解引用 int *p2 = arr + 10; // 指向了未知内存 ​ 如果指针指向的位置超过了数组的尾元素，则会指向未知内存，访问未知内存可能引发无法意料的后果。编译器编译过程中无法发现类似的问题。 ​ 两指针相减是他们之间的距离。两指针相减的结果类型是名为ptrdiff_t的标准库类型，定义在cstddef头文件中的机器相关的类型。是一种有符号类型。 auto n = end(arr) - begin(arr); // n的值是5 ​ 如果两个指针指向不相关的数组，他们之间的运算是毫无意义的。 解引用和指针运算的交互 ​ 指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。 int ia[] = {0,2,4,6,8}; int last = *(ia + 4); // 等价于last = ia[4]; 下标和指针 int ia[] = {0,2,4,6,8}; int i = ia[2]; int *p = ia; i = *(p+2); // 等价于i=ia[2] 只要指针指向的是数组中的元素，都可以执行下标运算。 int *p = &ia[2]; // p指向索引为2的元素 int j = p[1]; // p[1] 等价于*(p+1),就是ia[3]表示的那个元素 int k = p[-2]; // p[-2]是ia[0]表示的那个元素 虽然标准库类型string和vector也能执行下标运算，但是数组和它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 练习 练习3.34 ：假定p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？ p1 += p2 - p1; p1指向数组元素不变。如果p1和p2分别指向不同的数组，那么是非法的。 练习3.35 ：编写一段程序，利用指针将数组中的元素置为0。 int arr[sz] = { 1, 2, 3, 4, 5 }; auto pbegin = begin(arr); auto pend = end(arr); while (pbegin != pend) { (*pbegin) = 0; pbegin++; } 练习3.36 ：编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。 // 比较两个数组是否相等 int a1[] = {1,2,3,4,5}; int b1[] = {1,2,3,4,5}; bool ret = true; // 长度不等，数组直接不相等 if(sizeof(a1) != sizeof(b1)) { ret = false; } else{ for(int index = 0; index < sizeof(a1); index ++) { if(a1[index] != b1[index]) { ret = false; } } } if(ret) { cout << \"数组相等\" << endl; } else { cout << \"数组不相等\" << endl; } vector<int> vect1 = {1,2,3,4,5}; vector<int> vect2 = {1,2,3,4,5}; if(vect1 == vect2) { cout << \"两个vector对象相等\" << endl; } else { cout << \"两个vector对象不等\" << endl; } 3.5.4 C 风格字符串 字符串字面值是一种通用结构的实例，是C++继承C而来的C风格字符串。字符串存放在字符数组中以空字符（'\\0'）结束。 C 标准库 String 函数 cstring头文件提供了一组用于操作C风格字符串的函数。 函数名 释义 strlen(p) 返回p的长度，空字符不计算在内。 strcmp(p1, p2) 比较p1和p2的相等性。如果 p1 和 p2 相等，返回0；如果 p1 > p2，返回一个正值；如果 p1 < p2，返回一个负值。 strcat(p1, p2) 将 p2 附加到 p1 之后，返回 p1。要注意p1的容量是否足够容纳下追加之后的字符串，如果不够，会报弹窗。 strcpy(p1, p2) 将 p2 拷贝给 p1，返回 p1。要注意p1的容量是否足够容纳下p2的字符串，如果不够，会报弹窗。 char s1[80] = \"this is a world station6\"; char s3[] = \"this is a world station3\"; char s2[] = \"Don't go into the night with gentle.\"; auto x = strcat_s(s1, s3); cout << strlen(s1) << endl; // 输出 48 // strcat函数现在的编译器会报不安全，使用strcat_s函数，功能一样 // 同理strcpy也由strcpy_s代替。 对上述的函数，传入的数组必须要用空字符作为结束符。 char ca[] = {'C', '+', '+'}; // 不以空字符结束 cout << strlen(ca) << endl; // 错误，ca没有以空字符结束 运行上述代码，因为strlen是以遇到'\\0'作为结束标记，所以就一直沿着ca地址不断递增，知道遇到'\\0'才结束，因此每次运行的结果不一定一样。 练习 练习3.37 ：下面的程序是何定义，程序的输出结果是什么？ const char ca[] = {'h', 'e', 'l', 'l', 'o'}; const char *cp = ca; while(*cp){ cout << *cp << endl; ++cp; } C风格字符串以空字符结束。必须指向以空字符作为结束。 将数组ca的每个元素逐个打印出来；因为没有以'\\0'结束，就一直沿着ca地址循环输出未知字符。 练习3.38 ：为何将两个指针相加没意义？ 一个地址加上另一个地址，对寻址内容来说毫无意义。 练习3.39 ：编写一段程序，比较两个string对象。再编写一段程序，比较两个C风格字符串的内容。 string s1 = \"this is a string\"; string s2 = \"this is a string.\"; if (s1 == s2) { cout << \"s1 = s2\" << endl; } else if(s1 < s2) { cout << \"s1 < s2\" << endl; } else { cout << \"s1 > s2\" << endl; } 比较两个C风格字符串时： ①如果长度相等，则逐个比较大小，一旦某个相同位置下出现大于或者小于，停止比较，否则就是相等。 ②如果长度不等，则在前L个位置比较（假设长度较短的数组长为L），如果出现大于或者小于的情况，停止比较。否则就是更长的那个数组大于更短的数组。 char s1[] = \"this is a string\"; char s2[] = \"this is a string\"; int len1 = strlen(s1); int len2 = strlen(s2); int iseq = 0; // 0：相等；1：大于；-1：小于 if (len1 == len2) { for (int i = 0; i < len1; i++) { if (s1[i] > s2[i]) { iseq = 1; break; } else if (s1[i] < s2[i]) { iseq = -1; break; } else { continue; } } } else if(len1 < len2) { bool ishit = false; // 是否在逐个字符比较中确定大于或小于 for (int i = 0; i < len1; i++) { if (s1[i] > s2[i]) { ishit = true; iseq = 1; break; } else if (s1[i] < s2[i]) { ishit = true; iseq = -1; break; } else { continue; } } if (!ishit) // s1 小于 s2 { iseq = -1; } } else { bool ishit = false; // 是否在逐个字符比较中确定大于或小于 for (int i = 0; i < len2; i++) { if (s1[i] > s2[i]) { ishit = true; iseq = 1; break; } else if (s1[i] < s2[i]) { ishit = true; iseq = -1; break; } else { continue; } } if (!ishit) // s1 大于 s2 { iseq = 1; } } switch (iseq) { case 0: cout << \"s1 = s2\" << endl; break; case 1: cout << \"s1 > s2\" << endl; break; case -1: cout << \"s1 < s2\" << endl; break; } 练习3.40 ：编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组中。 char c1[100] = \"hello world!\"; char c2[100] = \"welcome to China!\"; char c3[100]; strcat_s(c1, c2); // 将c2 追加到 c1后面 strcpy_s(c3, c1); // 将c1 拷贝给 c3 cout << c3 << endl; 3.5.5 与旧代码的接口 ​ 旧代码的来源是，有些老项目，没出现标准库vector、string之前就写好了。现在可能要重新维护功能，引入标准库之后如何去操作？ 混用 string 对象和 C 风格字符串 ​ 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代。 允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是数组）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 string 转 const char char *str = s; // 错误 const char *str = s.c_str(); c_str 函数的返回值是一个C风格的字符串。函数返回的结果是个指针，该指针指向一个以空字符结束的字符数组。这个数组所存的数据恰好与那个string对象的一样。无法通过str去改变字符数组的内容，但是如果改变了s的内容，那么str指向的内容也会变化。 char c1[100] = \"hello world!\"; string s1 = \"welcome to China!\"; char c2[100] = \"hi\"; const char *s2 = s1.c_str(); cout << s2 << endl; s1 = \"never give up\"; cout << s2 << endl; // 输出：welcome to China! // never give up 如果执行完c_str()函数后程序想一直都能使用其返回的内容，最后将该 数组内容拷贝一份。 使用数组初始化 vector 对象 不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用 vector 对象初始化数组。但是允许使用数组来初始化 vector 对象。 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr), end(int_arr)); 练习 练习3.41 ：编写一个程序，用整型数组初始化一个 vector 对象。 char c1[] = \"hello world!\"; vector<char> cvect(begin(c1), end(c1)); for (auto c : cvect) { cout << c << endl; } 练习3.42 ：编写一段程序，将含有整数元素的 vector 对象拷贝给一个数组。 vector<int> cvect = { 1, 3, 4, 5, 6,7,8 }; int arr[7]; for(int i = 0; i < 7; i++) { arr[i] = cvect[i]; } for (auto i : arr) { cout << i << endl; }"
  },
  "Languages/Chapter3/3.6.html": {
    "href": "Languages/Chapter3/3.6.html",
    "title": "3.6 多维数组",
    "keywords": "3.6 多维数组 ​ 可以理解多维数组为数组的数组，就是一个数组的每个元素就是一个数组。 int a[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组 // 大小为10的数组，它的每个元素都是大小为20道德数组 // 这些数组的元素是含有30个整数的数组 int arr[10][20][30] = {0}; 多维数组的初始化 int ia[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} } // 等价于 int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; // ia[0][0] = 0; ia[0][1] = 1; ia[0][2] = 2; ia[0][3] = 3; // ia[1][0] = 4; ia[1][1] = 5; ia[1][2] = 6; ia[1][3] = 7; // ia[2][0] = 8; ia[2][1] = 9; ia[2][2] = 10; ia[2][3] = 11; // 显示初始化每行的首元素。 int ia[3][4] = {{0},{4},{8}}; // 等价于 // ia[0][0] = 0; ia[0][1] = 0; ia[0][2] = 0; ia[0][3] = 0; // ia[1][0] = 4; ia[1][1] = 0; ia[1][2] = 0; ia[1][3] = 0; // ia[2][0] = 8; ia[2][1] = 0; ia[2][2] = 0; ia[2][3] = 0; // 显示化初始化第一行，其他元素执行值初始化 int ix[3][4] = {0,3,6,9} // 等价于 // ia[0][0] = 0; ia[0][1] = 3; ia[0][2] = 6; ia[0][3] = 9; // ia[1][0] = 0; ia[1][1] = 0; ia[1][2] = 0; ia[1][3] = 0; // ia[2][0] = 0; ia[2][1] = 0; ia[2][2] = 0; ia[2][3] = 0; 多维数组的下标引用 可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。 int a[3][4]; int arr[10][20][30] = {0}; a[2][3] = arr[0][0][0]; int (&row)[4] = ia[1]; // 把row绑定到ia的第二个元素数组上，即row指向a[1]地址 使用范围 for 语句处理多维数组 size_t cnt = 0; for(auto &row : ia) { for(auto &col:row) { col = cnt++; } } 使用范围 for 语句处理多维数组，除了最内层的循坏外，其他所以循坏的控制变量都应该是引用类型。 指针和多维数组 ​ 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 int ia[3][4]; int (*p)[4] = ia; // p 指向含有4个元素的数组 p = &ia[2]; // p 指向ia的尾元素 int *p[4]; // 整型数组 int (*p)[4]; // 指向含有4个整数的数组 可以使用auto或者decltype去声明变量，避免在数组前面加上一个指针类型。 for(auto p = ia; p != ia + 3; ++p) { for(auto q = *p; q != *p + 4; ++q) { cout << *q << ' '; } cout << endl; } 使用begin和end: for(auto p = begin(ia); p != end(ia); ++p) { for(auto q = begin(*p); q != end(*p); ++q) { cout << *q << ' '; } cout << endl; } 类型别名简化多维数组的指针 using int_array = int[4]; // 新标准下的类型别名声明，参考2.5.1节 typedef intg int_array[4]; // 等价的typedef 声明。参见2.5.1节 for(int_array *p = ia; p != ia + 3; ++p) { for(int *q = *p; q != *p + 4; ++q) { cout << *q << ' '; } cout << endl; }"
  },
  "Languages/Chapter4/4.1.html": {
    "href": "Languages/Chapter4/4.1.html",
    "title": "4.1 基础",
    "keywords": "4.1 基础 ​ 表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。 4.1.1 基本概念 ​ C++定义了一元运算符和二元运算符。作用于一个运算对象的运算符是一元运算符，如取地址 & 何解引用 * ；作用于两个运算对象的运算符是二元运算符，如相等 == 和乘法 * ； ?: 是三元运算符。 组合运算符和运算对象 ​ 一条语句含有多个运算符，需要了解运算符的优先级、结合律以及运算对象的求值顺序。比如： 5 + 10 * 20 / 2 这个表达式并不是从左到右计算的，而是先计算 10 * 20 ，得200，原表达式等价于 5 + 200 / 2 ，再计算 200 / 2 ，得 100，等价于 5 + 100 ，结果为 105。 运算对象转换 ​ 通常来说，二元运算符左右两边的对象要求是同类型的，但是运算对象常常由一种类型转换成另外一种类型。比如加法+左右两边可以是int和double相加。 重载运算符 ​ C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。这种自定义的过程事实上是为已存在的运算符赋予了另外的含义，故称重载运算符。 ​ 使用重载运算符时，运算对象的类型和返回值，是由运算符定义的；但是运算对象的个数、运算符的优先级和结合律是无法改变的。 左值和右值 ​ 表达式要么左值要么右值。左值可以位于赋值语句的左侧，右值不可以。 ​ 当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份。 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。 内置解引用运算符、下标运算符、迭代器解引用运算符、string 和 vector的下标运算符的求值结果都是左值。 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。 4.1.2 优先级和结合律 ​ 在复合表达式中，优先级和结合律决定了运算对象组合的方式。但是表达式中的括号无视优先级和结合律。"
  },
  "Languages/Chapter5/5.1.html": {
    "href": "Languages/Chapter5/5.1.html",
    "title": "5.1 简单语句",
    "keywords": "5.1 简单语句 ​ C++ 语言中大多数语句都以分号结束，一个表达式，末尾加上分号就变成了表达式语句。表达式语句的作用是执行表达式并丢弃掉执行结果，所以需要一个变量来存储执行结果。 ival + 5; // 什么也不做 cout << ival; // 打印ival值 ret = ival + 5; 将ival + 5的结果保存到ret中。 空语句 只有一个分号，表示什么也不执行。 多余的分号有可能导致程序编译不通过或者循环体漏判。 while(iter != svec.end()); // 循环体语句执行的是一个空语句，而并非++iter;语句 ++iter; 复合语句 ​ 复合语句指用花括号括起来的语句和声明的序列，复合语句也被称作块。一个块就是一个域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。 for (int i = 0; i < 10; i++) { int temp = 0; temp = i * i + 9; cout << temp << \" \"; } temp = 100; //错误，temp是在块中定义的，出了块，temp就失效了，需要重新定义。"
  },
  "Languages/Chapter5/5.2.html": {
    "href": "Languages/Chapter5/5.2.html",
    "title": "5.2 语句作用域",
    "keywords": "5.2 语句作用域 ​ 可以在 if、switch、while 和 for 语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了。 while(int i = get_num()) // 每次迭代时创建并初始化变量i cout << i << endl; i = 0; // 错误，在循环外部无法访问i ​ 如果外部代码也要访问变量，则变量必须定义在语句的外部。 auto beg = v.begin(); while(beg != v.end() && *beg >= 0) ++beg; if(beg == v.end()) // 此时我们知道v中的所有元素都大于等于0"
  },
  "Languages/Chapter5/5.3.html": {
    "href": "Languages/Chapter5/5.3.html",
    "title": "5.3 条件语句",
    "keywords": "5.3 条件语句 C++ 语言提供了两种按条件执行的语句。一种是 if 语句，它根据条件决定控制流；另外一种是 switch 语句，它计算一整个表达式的值，然后根据这个值从几条执行路径中选择一条。 5.3.1 if 语句 ​ 判断一个指定的条件是否为真。根据判断结果决定是否执行另外一条语句。 condition 是能够转换为 bool 类型的表达式。如果 condition 为真，则执行 statement。 if (condition) statement; 带 else 的 if 语句。 if (condition) statement; else statement2; // condition 为真，则执行statement；否则执行 statement2 else 搭配 if 遵循就近原则。但是花括号无视else 的就近原则。 if (condition) if(condition2) statement1; else statement2; // else 和 condition2的if搭配。 if (condition) { if(condition2) statement1; } else // 和condition的if搭配 { statement2; } 5.3.2 switch 语句 ​ switch 语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。要注意case 后面加break。 ​ case 标签必须是整型常量表达式。 unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0; char ch; while(cin >> ch) { switch(ch){ case ‘a’: ++aCnt; break; case 'e': ++eCnt; break; case 'i': ++iCnt; break; case 'o': ++oCnt; break; case 'u': ++uCnt; break; default: ; } } char ch = getVal(); int iVal = 42; switch(ch) { case 3.14: // 错误，case标签不是一个整数 case ival: // 错误，case标签不是一个常量 } switch 内部的控制流 ​ 某个 case 标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式中断了这一过程，否则直到switch的结尾处才会停下来。中断过程用 break语句。 int i = 0; switch (i) { case 0: cout << 0 << endl; case 1: cout << 1 << endl; case 2: cout << 2 << endl; case 3: cout << 3 << endl; default: cout << -1 << endl; } // 输出 0 // 1 // 2 // 3 // -1 int i = 0; switch (i) { case 0: cout << 0 << endl; break; case 1: cout << 1 << endl; break; case 2: cout << 2 << endl; break; case 3: cout << 3 << endl; break; default: cout << -1 << endl; break; } // 输出 0"
  },
  "Languages/Chapter5/5.4.html": {
    "href": "Languages/Chapter5/5.4.html",
    "title": "5.4 迭代语句",
    "keywords": "5.4 迭代语句 ​ 迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while 和 for 语句在执行循环体之前检查条件， do while 语句先执行循环体，然后再检查条件。 5.4.1 while 语句 只要条件为真，while 语句就重复执行循环体，它的语法形式是： while (condition) statement; 定义在while条件部分或循环体内的变量每次都经历从创建到销毁的过程。 5.4.2 传统 for 语句 for(init-statement; condition; expression) statement; for 语句头中定义的对象只在 for 循环体内可见。 5.4.3 范围 for 语句 for (declaration : expression) statement; expression 表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者 vector 或 string等类型的对象。因为这些类型能够返回迭代器的begin和end成员。 declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。 5.4.4 do while 语句 ​ do while 语句是先执行循环体后检查条件。不管条件如何，先执行一次循环体。 int i = 5; do{ cout << i << \" \"; }while(i-- > 0); // 输出：5 4 3 2 1 0"
  },
  "Languages/Chapter5/5.5.html": {
    "href": "Languages/Chapter5/5.5.html",
    "title": "5.5 跳转语句",
    "keywords": "5.5 跳转语句 ​ 跳转语句中断当前的执行过程。C++语言提供了4中跳转语句：break、continue、goto 和 return。 5.5.1 break 语句 ​ break 语句负责终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。 5.5.2 continue 语句 ​ continue 语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for、while 和 do while 循环的内部，或者嵌套在此类循环里的语句或块的内部。和 break 不同，continue 只是中断当前循环的一个迭代。 5.5.3 goto 语句 语法形式： goto label; begin: int sz = get_size(); if(sz <= 0) { goto begin; } 大多数公司写的程序是禁止使用goto语句的，因为代码难以维护和理解。"
  },
  "Languages/Chapter5/5.6.html": {
    "href": "Languages/Chapter5/5.6.html",
    "title": "5.6 try 语句块和异常处理",
    "keywords": "5.6 try 语句块和异常处理 ​ 异常是指存在于运行时的返常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理返常行为可能是设计所有系统最难的一部分。 ​ 异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++中，异常处理包括： throw 表达式，异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。 try 语句块。异常处理部分使用try语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个catch子句结束。 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。 5.6.1 throw 表达式 ​ 程序异常检测部分使用 throw 表达式引发一个异常。throw 表达式包含关键字 throw 和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw 表达式后面通常紧跟一个分号，从而构成一条表达式语句。 Sales_item item1, item2; cin >> item1 >> item2; // 首先检查 item1 和 item2 是否表示同一种书籍 if(item1.isbn() == item2.isbn()) { cout << item1 + item2 << endl; return 0; } else{ cerr << \"data must refer to same ISBN\" << endl; return -1; } 应该把对象相加的代码和用户交互（输入数据）的代码分离出来。 // 首先检查 item1 和 item2 是否表示同一种书籍 if(item1.isbn() ！= item2.isbn()) { throw runtime_error(\"data must refer to same ISBN\"); } cout << item1 + item2 <<endl; 5.6.2 try 语句块 通用语法： try{ program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } 5.6.3 标准异常 C++ 标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中： exception 头文件定义了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息。 stdexcept 头文件定义了几种常用的异常类。 new 头文件中定义了 bad_alloc 异常类型。 type_info 头文件定义了 bad_cast 异常类型。 释义 exception 常见的问题。 runtime_error 只有在运行时才能检测出的问题。 range_error 运行时错误，生成的结果超出了意义的值域范围。 overflow_error 运行时错误，计算上溢。 underflow_error 运行时错误，计算下溢。 logic_error 程序逻辑错误。 domain_error 逻辑错误，参数对应结果值不存在。 invalid_argument 逻辑错误，无效参数。 length_error 逻辑错误，试图创建一个超出该类型最大长度的对象。 out_of_range 逻辑错误，使用一个超出有效范围的值。 只能以默认初始化的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为这些对象提供初始值。 异常类型只定义一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。"
  },
  "Languages/Chapter6/6.1.html": {
    "href": "Languages/Chapter6/6.1.html",
    "title": "6.1 函数基础",
    "keywords": "6.1 函数基础 ​ 函数定义包括：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。形参以逗号隔开，形参列表位于一对括号内。函数执行操作在语句块中，也称为函数体。 写一个阶乘函数 // 1 * 2 * 3 * 4 *5 int fact(int val) { int ret = 1; // 保存结果。 while (val > 1) ret *= val--; return ret; } int main() { int j = fact(5); cout << \"5! is \" << j << endl; return 0; } 形参和实参 ​ 实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。编译器能以任意可行的顺序对实参求值。不一定从左到右或从右到左逐个赋值。 ​ 实参的类型必须与对应的形参类型匹配，这一点与之前的规则一致。函数有几个形参，必须提供相同数量的实参。 函数的返回类型 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 6.1.1 局部对象 名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。 形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域可见，局部变量还会隐藏在外层作用域中同名的其他所有声明中的变量。 在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。 自动对象 ​ 对于普通局部变量对应的对象，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为 自动对象 。当块的执行结束后，块中创建的自动对象的值就变成了未定义的了。 string* getString() { string s = \"this is a string\"; return &s; } int main() { auto p = getString(); cout << *s << endl; return 0; } // 输出空字符串，因为程序控制出了函数体getString之后，s对象已经销毁了 ​ 形参也是一种自动对象。函数开始时为形参申请空间，函数结束，形参对象被销毁。 局部静态变量 ​ 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显示的初始化，它将执行值初始化，内置类型的局部静态变量初始化为0。 size_t count_calls() { static size_t ctr = 0; // 调用结束后，这个值仍然有效 return ++ctr; } int main() { for(size_t i = 0; i != 10; ++i) { cout << count_calls() << \" \"; } return 0; } // 输出：1 2 3 4 5 6 7 8 9 10 6.1.2 函数声明 ​ 函数名字必须在使用之前声明。函数只能定义一次，但是可以声明很多次。可以只声明不定义。函数声明和函数定义的区别就是函数声明无须函数体，用一个分号代替即可。函数声明可以省略形参的名字，但是形参的类型还是要保留的。函数的三要素：返回类型，函数名，形参类型，说明了函数所需的全部信息。函数声明也称作 函数原型 。 size_t count_calls(int, int); int main() { for (size_t i = 0; i != 10; ++i) { cout << count_calls(4, 5) << \" \"; } return 0; } size_t count_calls(int x, int y) { static size_t ctr = 0; // 调用结束后，这个值仍然有效 return ++ctr + x + y; } 在头文件中进行函数声明 ​ 可以将函数声明放在头文件中，就能确保同一函数的所有声明保持一致。如果想改变函数的接口，只需改变一条声明即可。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 6.1.3 分离式编译 分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。 编译和链接多个源文件 假设 fact 函数定义位于一个名为 fact.cc 的文件中，它的声明位于名为 Chapter6.h 的头文件中。显然与其他所有用到 fact 函数一样， fact.cc 应该包含 Chapter6.h 头文件。另外，我们在名为 factMain.cc 的文件中创建 main 函数， main 函数将调用 fact 函数。要生成可执行文件，必须告诉编译器我们用到的代码在哪里。分离式编译的一个好处是，如果修改其中的一个源文件，那么只需要重新编译那个改动了的文件。如果一个项目很大的话，这一机制可以节省编译时间。 ​"
  },
  "Languages/Chapter6/6.2.html": {
    "href": "Languages/Chapter6/6.2.html",
    "title": "6.2 参数传递",
    "keywords": "6.2 参数传递 每次调用函数时都会重新创建它的形参，并用传入的实参是对形参进行初始化。 如果形参是引用类型，它将绑定到对应的实参上面；否则，将实参的值 拷贝 后赋给形参，这意味着要创建新的对象。 当形参是引用类型时，它对应的实参被 引用传递 或者函数被 传引用调用 。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。 ​ 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。这样的实参被 值传递 或者函数被 传值调用 。 6.2.1 传值参数 当初始化一个非引用类型的变量时，初始值被拷贝给变量。在函数内部的改动不会影响函数外部传进来的变量的值。 指针形参 ​ 当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。 void reset(int* ip) { *ip = 0; ip =0; } int main() { int i = 42; reset(&i); cout << \"i = \" << i << endl; // 输出 i = 0 } 练习 练习6.10 ：编写一个函数，使用指针形参交换两个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。 void swap(int* x, int* y); int main(){ int i1 = 10; int i2 = 19; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; swap(&i1, &i2); cout << \" after swap\" << endl; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; return 0; } void swap(int* x, int* y) { int* temp = y; y = x; x = temp; } // 输出： // i1 = 10 // i2 = 19 // after swap // i1 = 10 // i2 = 19 在main函数外，i1指向了值为10的对象object1，i2指向了值为19的对象object2。到了swap函数内部，x原本指向object1，y原本指向object2。执行函数swap后，x指向了object2，y指向object1。控制权回到main函数时，i1还指向object1，i2还指向object2。 void swap(int* x, int* y) { auto temp = *x; *x = *y; *y = temp; } int main() { int i1 = 10; int i2 = 19; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; swap(&i1, &i2); cout << \" after swap\" << endl; cout << \"i1 = \" << i1 << endl; cout << \"i2 = \" << i2 << endl; return 0; } 6.2.2 传引用参数 引用形参允许函数改变一个或多个实参的值。 下面代码中i仅仅只是j的别名。 void reset(int &i) { i = 0; // 实参的值被改变为0 } int main() { int j =42; reset(j); // j的值被改变成为0了 return 0; } 使用引用避免拷贝 ​ 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 ​ 例如，比较两个字符串的长度大小，字符串很长，拷贝创建对象花销大，应该使用引用形参来避免这种情况。 bool isShorter(const string &s1, const string s2) { return s1.size() < s2.size(); } 如果函数无须改变引用形参的值，最好将其声明为常量引用。 使用引用形参返回额外信息 ​ 一个函数只能返回一个值，有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。 // 返回 s 中 c第一次出现的位置索引 // 引用形参 occurs 负责统计 c 出现的总次数 string::size_type find_char(const string &s, char c, string::size_type &occurs) { auto ret = s.size(); occurs = 0; // 设置表示出现次数的形参的值 for(decltype(ret) i = 0; i != s.size(); ++i) { if(s[i] == c) { if(ret == s.size()) ret = i; // 记录c第一次出现的位置 occurs++; // 将出现的次数加1 } } return ret; // 返回出现的次数 } int main() { string s= \"hello world\"; string::size_type occurs = 0; string::size_type firstoccur = 0; firstoccur = find_char(s, 'o', occurs); return 0; } 6.2.3 const 形参和实参 const int ci = 42; // 不能改变ci，const是顶层 int i = ci; // 正确：当拷贝ci时，忽略了它的顶层 const int* const p = &i; // const是顶层的，不能给p赋值 *p = 0; // 正确，通过p改变对象的内容是允许的，现在i变成了0 当实参初始化型参时会忽略掉顶层 const。当形参有顶层 const 时，传给它常量对象或者非常量对象都是可以的。 void fcn(const int i){/*不能对i进行写操作*/} void fcn(int i){/* ... */} // 错误，重读定义了fcn(int) 指针或引用形参与 const ​ 可以使用非常量初始化一个底层 const 对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。 int i = 42; const int *cp = &i; // 正确，但是不能通过 cp 改变 i const int &r = i; // 正确，但是不能通过 r 改变 i const int &r2 = 42; // 正确 int *p = cp; // 错误，p的类型和cp的类型不匹配 int &r3 = r; // 错误，r3的类型和r的类型不匹配 int &r4 = 42; // 错误，不能用字面值初始化一个非常量引用 int i = 0; const int ci = i; string::size_type ctr = 0; reset(&i); // 调用形参类型是int*的reset函数 reset(&ci); // 错误，不能用指向const int对象的指针初始化int* reset(i); // 调用形参类型是int&的reset函数 reset(ci); // 错误，不能把普通引用绑定到const对象ci上 reset(42); // 错误，不能把普通引用绑定到字面值上 reset(ctr); // 错误，类型不匹配，ctr是无符号类型 尽量使用常量引用 如果 find_char 的接口像下面这样定义，在调用时容易出现各种不兼容的情况。 string::size_type find_char(string &s, char c, string::size_type &occurs); 调用： find_char(\"Hello world\", 'o', ctr); 在编译时发生错误。因为 “Hello world” 是字面值常量，而string &s是非常量。 如果被另一个函数包装起来，也不易察觉。 bool is_sentence(const string &s) { // 如果在 s 的末尾有且只有一个句号，则 s 是一个句子 string::size_type ctr = 0; return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1; // 编译错误，s是const string &类型 } 练习 练习6.16 ：下面的这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善。 bool is_empty(string& s){ return s.empty(); } 功能上来说，该函数仅仅是判断形参s是否为空串，没有对s进行写操作而定义形参为可读可写，调用传入的实参只能是string对象，对const string对象而言，不能调用这个函数。 修改： bool is_empty(const string& s){ return s.empty(); } 练习6.17 ：编写一个函数，判断 string 对象中是否含有大写字母。编写另一个函数，把 string 对象全都改写成小写形式。在这两个函数中你使用的形参类型相同吗？为什么？ // 判断 string 对象中是否含有大写字母 bool IsContainUpper(const string& s) { for (auto c : s) { if (isupper(c)) return true; } return false; } // 将参数s全部小写字母改成大写字母 void ToUpper(string& s) { for (auto& c : s) { c = toupper(c); } } 不同，因为 IsContainUpper 函数没有改参数的内容，所以最好定义长引用常量形参， ToUpper 函数改动了形参，所以不能定义为常量。 练习6.18 ：为下面的函数编写函数声明，从给定的名字中推测函数具备的功能。 (a) 名为 compare 的函数，返回布尔值，两个参数都是matrix类的引用。 (b) 名为 change_val 的函数，返回 vector<int> 的迭代器，有两个参数：一个是 int，另一个是 vector<int> 的迭代器。 答：(a)是一个比较两个 matrix 类是否相同，如果相同返回 true；不同，返回 false。 (b) 改变形参迭代器指向的地址的内容为 int 形参类型的值。 练习6.19 ：假定有如下声明，判断哪个调用合法、哪个调用不合法。对于不合法的函数调用，说明原因。 double calc(double); int count(const string&, char); int sum(vector<int>::iterator, vector<int>::iterator, int); vector<int> vec(10); (a) calc(23.4, 55.1); (b) count(\"abcda\", 'a'); (c) calc(66); (d) sum(vec.begin(), vec.end(), 3.8); (a)不合法，参数个数不对。 (b) 合法。 (c)合法。 (d)合法。 练习6.20 ：引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么情况？ 当函数内部不会对形参进行写操作时，应该用常量引用。如果形参应该是常量引用，而我们将其设为了普通引用，可能会编译不通过，因为形参类型不同。 6.2.4 数组形参 ​ 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，不许拷贝数组以及使用数组时会将其转换成指针。因为无法拷贝数组，所以无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 ​ 尽管不能以值传递的方式传递数组，但是可以把形参写成类似数组的形式： void print(const int*); void print(const int[]); void print(const int[10]); // 这里规定了数组大小为10，但是实际传的还是数组首地址，传入的数组容量大于10也是可以的 尽管表现形式不同，但上面的三个函数是等价的。每个函数的唯一形参是 const int* 类型的。当编译器处理对 print 函数的调用时，只检查传入的参数是否是 const int* 类型。 int i = 0, j[2] = {0, 1}; print(&i); // 正确：&i 的类型是int* print(j); // 正确：j转换成 int* 并指向 j[10] 如果传给 print 函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。但是内部使用数组时，要人为确保不会越界。 因为传入函数的数组只有首地址，函数不能通过首地址知道知道数组的大小尺寸，调用者应该提供一些额外的信息。 使用标记指定数组长度 ​ 管理数组实参的一个方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。因为字符串最后一个字符后面跟着一个空字符。 void print(const char *cp) { if(cp) // 若cp不是一个空指针 { while(*cp) // 只要指针所指的字符不是空字符 cout << *cp++; // 输出当前字符并将指针向前移动一个位置 } } 使用标准库规范 管理数组实参的第二个方法是传递指向数组首元素和尾元素的指针。 void print(const int* beg, const int* end) { while(beg != end) cout << *beg++ << endl; } 显示传递一个表示数组大小的形参 第三种方法是专门定义一个表示数组大小的形参。 void print(const int ia[], size_t size) { for(size_t i = 0; i != size; ++i) { cout << ia[i] << endl; } } int j[] = {0, 1}; print(j,end(j) - begin(j)); 数组形参和 const 函数内部如果不改动数组元素时，尽可能使用 const。 数组引用形参 ​ C++ 语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。 void print(int (&arr)[10]) // (&arr) 两边的括号必不可少 { for (auto elem : arr) { cout << elem << endl; } } ​ 因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，只能将函数作用于大小为10的数组。 int i = 0, j[2] = {0, 1}; int k[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; print(&i); // 错误：实参不是含有10个整数的数组 print(j); // 错误，实参不是含有10个整数的数组 print(k); // 正确，实参是含有10个整数的数组 传递多维数组 // matrix 指向数组的元素，该数组的元素是由 10 个整数构成的数组 void print(int (*matrix)[10], int rowSize) { } void print(int arr[][4]) { for (int row = 0; row < 3; row++) { for (int list = 0; list < 4; list++) cout << arr[row][list] << \" \"; cout << endl; } } int main() { int arr[][4] = { {0,1,2,3},{4,5,6,7},{8,9,10,11} }; print(arr); return 0; } 和所有的数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组的第二维的大小都是数组类型的一部分，不能省略。 int *matrix[10]; // 10个指针构成的数组 int (*matrix)[10]; // 指向含有10个整数的数组的指针 也可以使用数组的语法定义函数，此时编译器会忽略掉第一个维度大小，所以最好不要把它包括在形参列表内。 void print(int matrix[][10], int rowSize); 练习 练习 6.21 ：编写一个函数，令其接受两个参数：一个是int型的数，另一个是int指针。函数比较int的值和指针所指的值，返回较大的那个。在该函数中指针的类型应该是什么？ int compare(const int left,const int* right) { return left > *right ? left : *right; } const int* 类型。 练习 6.22 ：编写一个函数，令其交换两个 int 指针。 void swap(int* &left,int* &right) { int* temp = right; right = left; left = temp; } int main() { int left = 10; int right = 11; int* pleft = &left; int* pright = &right; cout << \"before swap\" << endl; cout << \"*pleft = \" << *pleft << endl; cout << \"*pright = \" << *pright << endl; swap(pleft, pright); cout << \"after swap\" << endl; cout << \"*pleft = \" << *pleft << endl; cout << \"*pright = \" << *pright << endl; return 0; } // before swap // *pleft = 10 // *pright = 11 // after swap // *pleft = 11 // *pright = 10 练习 6.23 ：参考本书介绍的几个 print 函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的 i 和 j： int i = 0, j[2] = {0, 1}; 略。 练习 6.24 ：描述下面这个函数的行为。如果代码存在问题，请指出并改正。 void print(const int ia[10]) { for(size_t i = 0; i != 10; ++i) { cout << ia[i] << endl; } } 逐个输出打印数组中的数。 问题，如果传入的数组长度小于10，就出现多余的数。 6.2.5 main: 处理命令行选项 有时需要给main传递实参，一种常见的情况是：有些exe，用命令行启动，但是又需要传递一些额外信息，就需要给main传参数。 int main(int argc, char *argv[]) {} 调用： 1.1.exe prog -d -o ofile data0 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令提供的实参。最后一个指针之后的元素值保证为0。 argv[0] = \"prog\"; argv[1] = \"-d\"; argv[2] = \"-o\"; argv[3] = \"ofile\"; argv[4] = \"data0\"; argv[5] = 0; 6.2.6 含有可变形参的函数 ​ 为了编写能处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为 initializer_list 的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板，在知识点参考16.4节。 ​ C++还有一种特殊的形参类型，省略符，可以用它传递可变数量的实参。省略符一般只用于与C函数交互。 initializer_list 形参 ​ 如果函数的参数数量未知但是全部实参的类型都相同，initializer_list 支持这种做法。它存在于头文件 initializer_list 中。 initializer_list 提供的一些相关的操作： 方法 释义 initializer_list lst; 默认初始化：T类型元素的空列表。 initializer_list lst{a,b,c...}; lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。 lst2(lst) 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst 同 lst2(lst)。 lst.size() 列表中的元素数量。 lst.begin() 返回指向 lst 中首元素的指针。 lst.end() 返回指向 lst 中尾元素的下一位置的指针。 initializer_list 是一种模板类型，定义 intializer_list 对象时，必须说明列表中所含元素的类型。 initializer_list<string> ls; initializer_list<int> li; initializer_list 对象中的元素永远是常量值。 void error_msg(initializer_list<string> il) { for(auto beg = il.begin(); beg != il.end(); ++beg) { cout << *beg << \" \"; } cout << endl; } int main() { /* ... */ // expected 和 actual 是 string 对象 if (expected != actual) { error_msg({\"functionX\", expected, actual}); } else { error_msg({\"functionX\", \"okay\"}); } } ​ 如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内。"
  },
  "Languages/Chapter6/6.3.html": {
    "href": "Languages/Chapter6/6.3.html",
    "title": "6.3 返回类型和 return 语句",
    "keywords": "6.3 返回类型和 return 语句 ​ return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。 return 语句有两种形式。 ① return; ② return expression 6.3.1 无返回值函数 没有返回值的 return 语句只能用在返回类型是 void 的函数中。返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。 6.3.2 有返回值函数 值是如何被返回的 ​ 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 // 如果 ctr 的值大于1，返回 word 的复数形式 string make_plural(size_t ctr, const string& word, const string& ending) { return (ctr > 1) ? word + ending : word; } 该函数的返回类型是 string，意味着返回值将被拷贝到调用点。因此，该函数将返回word的副本或者一个未命名的临时对象，该对象的内容是 word 和 ending 的和。 ​ 同其他引用类型一样，如果函数返回引用，则该引用仅是它所引用对象的一个别名。假定某函数跳出两个 string 形参中较短的那个并返回其引用。 const string& shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 其中形参和返回类型都是 const string 的引用，不管是调用函数还是返回结果都不会真正拷贝 string 对象。 不要返回局部对象的引用或指针 ​ 函数完成后，它所占用的存储空间也随之被释放掉。函数局部变量的引用将指向不再有效的内存区域。 // 严重错误，这个函数试图返回局部对象的引用 const string& manip() { string ret = \"this is a string\"; if(!ret.empty()) return ret; // 错误，返回局部对象的引用！ else return \"Empty\"; // 错误，\"Empty\" 是一个局部临时量 } 返回类类型的函数和调用运算符 auto sz = shorterString(s1, s2).size(); 函数 shorterString 返回的类型是 string，可以直接调用函数并当成一个 string 对象，对其调用 size 函数。 引用返回左值 char& get_val(string& str, string::size_type ix) { return str[ix]; } int main() { string s(\"a value\"); cout << s << endl; // 输出 a value get_val(s, 0) = 'A'; // 将 s[0]的值改为A cout << s << endl; // 输出 A value } 列表初始化返回值 C++11 新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。 vector<string> process() { // ... // expected 和 actual 是 string 对象 if(expected.empty()) return {}; else if(expected == actual) return {\"functionX\", \"okay\"}; // 返回列表初始化的 vector 对象 else return {\"functionX\", expected, actual}; } ​ 如果函数返回的内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。 主函数 main 的返回值 ​ 如果主函数没有 return 语句，则默认隐式返回0。cstdlib 头文件定义了两个预处理变量，可以用这两个变量分别表示成功与失败。 int main() { if(some_failure) { return EXIT_FAILURE; } else{ return EXIT_SUCCESS; } } 递归 ​ 函数调用它自身。main函数不能调用它自身。 int factorial(int val) { if(val > 1) return Factorial(val - 1) * val; else return 1; } 练习 练习 6.32 ：下面函数合法吗？合法说明其功能，不合法，请改正。 int& get(int* array, int index) { return array[index]; } int main(int argc, char *argv[]) { int ia[10]; for (int i = 0; i != 10; ++i) { get(ia, i) = i; } for (auto i : ia) { cout << i << \" \"; } cout << endl; return 0; } 合法。get函数是返回 形参数组array的下标，返回结果可以作为赋值运算符的左值。 练习 6.33 ：编写一个递归函数，输出 vector 对象的内容。 void print(vector<int> &vect, int index) { if (index >= 0) { print(vect, index - 1); cout << vect[index] << endl; } } 练习 6.34 ：如果 factorial 函数的停止条件如下所示，将发生什么情况？ int factorial(int val) { if(val != 0) { return factorial(val - 1) * val; } return 1; } 输入正数就是求整数的阶乘，输入负数，则会陷入无限递归。 练习 6.35 ：在调用 factorial 函数时，为什么我们传入的值是 val -1 而非 val--? val 只是当前函数的局部变量，val--是先将val当前值传入，在进行自减1，显然不可取。要是换做--val是可以的。 6.3.3 返回数组指针 ​ 因为数组不能被拷贝，所以函数不能返回数组，但是可以返回数组的指针或引用。 typedef int arrT[10]; // arrT是一个类型别名，它表示的类型是含有10个整数的数组 using arrT = int[10]; // arrT的等价声明 arrT* func(int i); // func 返回一个指向含有10个整数的数组的指针 声明一个返回数组指针的函数 ​ 要想在声明 func 时不使用类型别名，必须牢记被定义的名字后面数组的维度： int arr[10]; // arr 是一个含有10个整数的数组 int *p1[10]; // p1 是一个含有10个指针的数组 int (*p2)[10]; // p2 是一个指针，它指向含有10个整数的数组 Type (*function(parameter_list))[dimension] Type表示元素的类型，dimension 表示数组的大小。(*function(parameter_list))两端的括号必须存在，如果没有括号，函数的返回类型将是指针的数组。 列子： int (*func(int i))[10]; func(int i) 表示调用func函数时需要一个int类型的实参。 (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作。 (*func(int i))[10] 表示解引用 func 的调用将得到一个大小是10的数组。 int (*func(int i))[10] 表示数组中的元素是 int 类型。 使用尾置返回类型 ​ 在 C++11 新标准中还有一种可以简化上诉 func 声明的方法，就是使用尾置返回类型。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 auto。 // func 接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组 auto func(int i) -> int(*)[10]; 使用 decltype ​ 如果知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。 int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; // 返回一个指针，该指针指向含有5个整数的数组 decltype(odd)* arrPtr(int i) { return (i % 2) ? &odd : &even; // 返回一个指向数组的指针。 } ​ arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。 decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示arrPtr 返回指针还必须在函数声明时加一个 * 符号。 练习 练习 6.36 ：编写一个函数的声明，使其返回数组的引用并且该数组包含10个string对象。不要使用位置返回类型、decltyoe 或者类型别名。 string (&func())[10]; string arr[10] = { \"q\",\"w\",\"e\",\"r\",\"t\",\"y\",\"u\",\"i\",\"o\",\"2\" }; int main(int argc, char *argv[]) { for (auto s : func()) { cout << s << endl; } return 0; } string(&func())[10] { return arr; // TODO: 在此处插入 return 语句 } 练习 6.37 ：为上一题的函数 再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。 类型别名： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; using arrT = int[10]; arrT* func() { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for(int i =0; i < 10; i++) cout << (*a)[i] << endl; return 0; } 尾置返回类型： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; auto func() -> int(*)[10] { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for (int i = 0; i < 10; i++) cout << (*a)[i] << endl; return 0; } decltype 关键字： int arr[10] = {99,2,3,5,4,68,7,9,9,10}; decltype(arr)* func() { return &arr; } int main(int argc, char *argv[]) { auto a = func(); for (int i = 0; i < 10; i++) cout << (*a)[i] << endl; return 0; } 练习 6.38 ：修改 arrPtr 函数，使其返回数组的引用。 int odd[] = { 1, 3, 5, 7, 9 }; int even[] = { 0, 2, 4, 6, 8 }; // 返回一个指针，该指针指向含有5个整数的数组 decltype(odd)& arrPtr(int i) { return (i % 2) ? odd : even; // 返回一个指向数组的指针。 } int main(int argc, char* argv[]) { cout << arrPtr(2)[4] << endl; return 0; }"
  },
  "Languages/Chapter6/6.4.html": {
    "href": "Languages/Chapter6/6.4.html",
    "title": "6.4 函数重载",
    "keywords": "6.4 函数重载 ​ 同一作用域内的几个函数名字相同但是形参列表不同，称之为重载函数。 void print(const char *cp); void print(const int *beg, const int *end); void print(const int ia[], size_t size); 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字，记名字的负担。当函数调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。 main 函数不能重载。 定义重载函数 ​ 有一种典型的数据块应用，需要创建几个不同的函数分别根据名字、电话、账户号码等信息查找记录。 Record lookup(const Acount&); Record lookup(const Phone&); Record lookup(const Name&); Acount acct; Phone phone; Record r1 = lookup(acct); // 调用接受Acount 的版本 Record r2 = lookup(phone); // 调用接受phone的版本 对于重载函数来说，它们应该在形参数量或者形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。 判断两个形参的类型是否相异 Record lookup(const Account& acct); Record lookup(const Account&); // 省略了形参的名字 typedef Phone Telno; Record lookup(const Phone&); Record lookup(const Telno&); 在第一对声明中，第一个函数给它的形参起了名字，第二个函数没有。形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容。 ​ 第二对声明看起来类型不同，但事实上Telno不是一种新类型，它只是 Phone 的别名而已。类型别名为已存在的类型提供另外一个名字，它并不是创建新类型。所以第二对中两个形参的区别仅在于一个使用类型原来的名字，另外一个使用它的别名，从本质上来说它们没什么不同。 重载和 const 形参 顶层 const 不影响传入函数的对象。也就是说一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来。 Record lookup(Phone); Record lookup(const Phone); // 重复声明了Record lookup(Phone) Record lookup(phone*); Record lookup(Phone* const); // 重复声明了Record lookup(phone*); 如果形参是某种类型的指针和引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。 Record lookup(Account&); // 函数作用于Account的引用 Record lookup(const Account&); // 新函数，作用于常量引用 Record lookup(Account*); // 新函数，作用于指向Account的指针 Record lookup(const Account*); // 新函数，作用于指向常量的指针 编译器可以通过实参是否是常量来推断应该调用哪个函数。因为 const 不能转换成其他类型，所以我们只能把 const 对象（或指向 const 的指针）传递给 const 形参。相反，因为非常量可以转换成 const，所以上面的 4个函数都能作用于非常量对象的指针。当我们传递一个非常量对象或指针非常量对象的指针时，编译器会优先选用非常量版本的函数。 const_cast 和重载 const string &shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 函数的参数和返回类型都是 const string 的引用。可以对两个非常量的 string 实参调用这个函数，但返回的结果仍然是 const string 的引用。因此我们需要一种新的 shorterString 函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用 const_cast 可以做到这点。 string& shorterString(string &s1, string& s2) { auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2)); return const_cast<string&>(r); } 这样做有什么好处？ // 如果没有第二个函数shorterString，即使是非常量参数传入之后，返回的也是一个常量的对象引用，不能改变其返回对象的内容。 // 下面的编码就编译不通过 // 有了第二个函数，下面编码顺利通过，对shorterString调用传入的是常量参数，就自动找到第一个shorterString函数，非常量就找到第二个函数。 int main(int argc, char* argv[]) { string s1 = \"this is a string1\"; string s2 = \"this is another string2\"; string& s = shorterString(s1, s2); s = \"hello\"; cout << s1 << endl; return 0; } // 输出： hello 调用重载的函数 函数匹配 是一个过程，在该过程中函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。编译器首先 将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。 大多数情况下很好区分某一次调用的是哪一个具体函数，但是当重载函数的参数数量和参数类型可以相互转换时，这时候就不容易区分了。因此调用重载函数有三种可能结果： 编译器找到一个与实参 最佳匹配 的函数，并生成 调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的报错。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用。 6.4.1 重载与作用域 一般来说，将函数声明至于局部作用域内不是一个明智的选择。 如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。 string read(); void print(const string&); void print(double); // 重载了print void fooBar(int ival) { bool read = false; // 隐藏了read函数，不好的习惯 string s = read(); // 错误，read是一个布尔值 void print(int); // 新作用域，隐藏了之前的print print(\"Value: \"); // 错误，print(const string&)被隐藏掉了 print(ival); // 正确，当前print(int)可见 print(3.14); // 正确，调用了print(int);print(double)被隐藏了 } 当调用 print 函数时，编译器首先寻找对该函数名的声明，找到的是接受 int 值的那个局部声明。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。剩下的工作就是检查函数调用是否有效了。"
  },
  "Languages/Chapter6/6.5.html": {
    "href": "Languages/Chapter6/6.5.html",
    "title": "6.5 特殊用途语言特性",
    "keywords": "6.5 特殊用途语言特性 6.5.1 默认实参 我们编写函数声明时，某些参数在调用时大多时候都是传入同一个值，但是也有特殊时候传入不同值，这个时候默认参数就起到一个作用。默认参数使得函数在调用时，可以接受默认参数值或者用户指定的值。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。一个某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用默认实参调用函数 如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。 默认实参声明 对于函数的声明来说，一般将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参之恩能够被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 string screen(int len, int wid, char x= ' ') string screen(int len, int wid, char x= '*') // 错误，重复声明 string screen(int len = 24, int wid = 95, char x) // 正确 默认实参初始值 局部变量不能作为默认实参。只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。 // wd、def 和 ht 的声明必须出现在函数之外 sz wd = 80; char def = ' '; sz ht(); string screen(sz = ht(), sz = wd, char def); string window = screen(); // 调用screen(ht(), 80, ' ') 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： void f2() { def = \"*\"; // 改变默认实参的值 sz wd = 100; // 隐藏了外层定义的wd，但是不影响screen调用的默认wd还是80 window = screen(); // 调用 screen(ht(), 80, '*') } 6.5.2 内联函数和 constexpr 函数 shorterString 函数的功能是比较两个 string 形参的长度并返回长度较小的 string 的引用。把这种规模较小得得得操作定义成函数有很多好处： 易于阅读和理解函数执行的功能。 使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行。 如果需要修改计算过程，只需要在函数定义的地方修改，而不用在每个使用这样的功能地方做修改。 函数可以被其他应用重复利用，省去重新编写代码的代价。 但是调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含一系列的工作。调用前要先保存寄存器，并在返回时恢复；此外可能要进行参数拷贝赋值等。 内联函数可避免函数调用的开销 将函数指定成内联函数，通常就是将它在每个调用点上“内联地”展开。 // 内联版本：寻找两个 string 对象中较短的那个 shorterString(const string& s1, const string& s2) { return s1.size() <= s2.size() ? s1 : s2; } 在某处使用了内联函数。 cout << shorterString(s1, s2) << endl; 实际上编译器在编译过程中将代码等价于如下： cout << (s1.size() <= s2.size() ? s1 : s2) << endl; 内联说明只是向编译器发出的一个请求，编译器可以选择忽略请求。也就是说，是否在调用点直接代码展开，取决于编译器。 内联机制用于优化规模小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。 constexpr 函数 ​ constexpr 函数 是指能用于常量表达式的函数。定义 constexpr 函数的方法与其他函数类型，不过要遵循约定：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体重必须有且只有一句 return 语句。 constexpr int new_sz() {return 42;} constexpr int foo = new_sz(); // 正确：foo是一个常量表达式 把 new_sz 定义成无参数的 constexpr 函数。因为编译器能在程序编译时验证 new_sz 函数返回的是常量表达式，所有可以用 new_sz 函数初始化 constexpr 类型的变量 foo。 执行该初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开， constexpr 函数被隐式地指定为内联函数。 ​ constepxr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。 ​ 允许 constexpr 函数的返回值并非一个常量。 // 如果arg是常量表示式，则scale(arg)也是常量表达式 constexpr size_t scale(size_t cnt) {return new_sz() * cnt;} 当 scale 的实参是常量表达式时，它的返回值也是常量表达式；反之则不然。 int arr[scale(2)]; // 正确，scale(2)是常量表达式 int i = 2; // i 不是常量表达式 int a2[scale(i)]; // 错误，scale(2)不是常量表达式 size_t x = scale(2); // 正确。 如果用一个非常量表达式调用 scale 函数；比如 int 类型的对象 i，则返回值是个非常量表达式。当把scale函数用在需要常量表达式的上下文中时，由编译器负责检查函数的结果是否符号要求。如果恰好不是常量表达式，编译器将发出错误信息。 constexpr 函数不一定返回常量表达式。 把内联函数和 constexpr 函数放在头文件内 和其他函数不一样，内联函数和 constexpr 函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。 6.5.3 调试帮助 ​ 为了有选择地执行调试代码，程序可以包含一些用于调试代码，这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert 和 NDEBUG。 assert 预处理宏 assert 是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。 assert(expr); 首先对 expr 求值，如果表达式为假，assert 输出信息并终止程序的执行。如果表达式为真，assert 什么也不做。 ​ assert 宏定义在 cassert 头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理器名字而无须提供 using 声明。使用时不需要加域说明，即std::assert，也不用为 assert 提供 using 声明。 ​ 和预处理变量一样，宏名字在程序内必须唯一。含有 cassert 头文件的程序不能再定义名为 assert 的变量、函数或者其他实体。assert 宏常用于检查 “不能发生” 的条件。 assert(word.size() > threshold); NDEBUG 预处理变量 ​ assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 将执行运行时检查。 ​ 定义 NDEBUG 能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。assert 应该仅用于验证那些确实不可能发生的事情。可以把 assert 当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。 ​ 除了用于 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef 和 #ednif 之间的代码；如果定义了 NDEBUG，这些代码将被忽略掉。 现在的vs2019编译器：Release 版本是 NDEBUG 无效，assert 无效。debug 版本就是有效的。 void print(const int ia[], size_t size) { #ifndef NDEBUG // __func__是编译器定义的一个局部静态变量，用于存放函数的名字 cerr << __func__ << \": array size is \" << size << endl; #endif // ... } C++ 预处理器还定义了4个对于程序调试很有用的名字 变量名字 释义 __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 if(word.size() < threshold) cerr << \"Error\" << __FILE__ << \" : in function \" << __func__ << \" at line \" << __LINE__ << endl << \" Compiled on \" << __DATE__ << \" at \" << __TIME__ << endl << \" Word read was \\\"\" << word << \"\\\": Length too short\" << endl;"
  },
  "Languages/Chapter6/6.6.html": {
    "href": "Languages/Chapter6/6.6.html",
    "title": "6.6 函数匹配",
    "keywords": "6.6 函数匹配 void f(); void f(int); void f(int, int); void f(double, double = 3.14); f(5.6); // 调用 void f(double, double); 当我们调用函数时，需要确定调用的是哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，就不容易确定到底是调用哪个重载函数了。 确定候选函数和可行函数 ​ 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为 候选函数 。候选函数具备两个特征：一是被调用的函数同名，而是其声明在调用点可见。 ​ 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 可行函数 。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 ​ 在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。 寻找最佳匹配 ​ 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。 6.6.1 实参类型转换 ​ 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示： 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型。 想实参添加顶层 const 或从实参中删除顶层 const。 通过 const 转换实现的匹配。 通过类型提升实现的匹配。 通过算术类型转换或指针转换实现的匹配。 通过类类型转换实现的匹配。 需要类型提升和算术类型转换的匹配 ​ 分析函数调用前，应该知道小整型一般都会提升到 int 类型或更大的整数类型。假设有两个函数，一个接受 int、另一个接受 short，则只有当调用提供的是 short 类型的值时，才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int类型；此时 short 版本反而会导致类型转换。 void ff(int); void ff(short); ff('a'); // char 提升成int；调用ff(int) ​ 所有算术类型转换的级别都一样。列如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高。 void mainp(long); void mainp(float); mainp(3.14); // 错误，二义性使用 函数匹配和 const 实参 ​ 如果重载函数的区别在于它们的引用类型的形参是否引用了 const，或者指针类型的形参是否指向 const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。 Record lookup(Account&); Record lookup(const Account&); const Account a; Account b; lookup(a); // 调用 lookup(const Account&) lookup(b); // 调用 lookup(Account&);"
  },
  "Languages/Chapter6/6.7.html": {
    "href": "Languages/Chapter6/6.7.html",
    "title": "6.7 函数指针",
    "keywords": "6.7 函数指针 ​ 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 // 比较两个 string 对象的长度 bool lengthCompare(const string&, const tring&); 该函数的类型是 bool(const string&, const string&)。要声明一个指向该函数的指针，只需要用指针替换函数名即可。 // pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型 bool (*pf)(const string&, const string&); // 未初始化 *pf的两端括号必不可少。不然就变成了声明一个返回 bool* 类型的函数 pf。 使用函数指针 pf = lengthCompare; // pf 指向名为 lengthCompare的函数 pf = &lengthCompare; // 等价语句，取地址符是可选的 可以直接使用指向函数的指针调用函数，无需提前解引用指针。 bool b1 = pf(\"hello\", \"goodbye\"); // 调用 lengthCompare 函数 bool b2 = (*pf)(\"hello\", \"goodbye\"); // 一个等价的调用 bool b3 = lengthCompare(\"hello\", \"goodbye\"); // 另一个等价的调用 在指向不同函数类型的指针间不存在转换规则。可以为函数指针赋 nullptr 或值为0的整型常量表达式，表示该指针没有指向任何一个函数： string::size_type sumLength(const string&, const string&); bool cstringCompare(const char*, const char*); pf = 0; // 正确，pf不指向任何函数 pf = sumLength; // 错误，返回类型不匹配 pf = cstringCompare; // 错误，形参类型不匹配 pf = lengthCompare; // 正确，函数和指针的类型精确匹配 重载函数的指针 ​ 当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针 void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned int) 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配 void (*pf2)(int) = ff; // 错误，没有任何一个 ff 与该形参列表匹配 double (*pf3)(int*) = ff; // 错误，ff 和 pf3的返回类型不匹配 函数指针形参 ​ 虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用： void useBigger(const string& s1, const string& s2, bool pf(const string&, const string&)); // 等价声明 void useBigger(const string& s1, const string& s2, bool (*pf)(const string&, const string&)); 可以直接把函数作为实参使用，此时它会自动转换成指针： // 自动将函数lengthCompare 转换成指向该函数的指针 useBigger(s1, s2, lengthCompare); 可以使用 decltype 关键字使用函数指针的代码： // Func 和 Func2 是函数类型 typedef bool Func(const string&, const string&); typedef decltype(lengthCompare) Func2; // FuncP 和 FuncP2是指向函数的指针 typedef bool (*FuncP)(const string&, const string&); typedef decltype(lengthCompare) *FuncP2; // 等价的类型 decltype 返回函数类型，此时不会将函数类型自动转换成指针类型。因为 decltype 的结果是函数类型，所以只有在结果前面加上*才能得到指针。 // useBigger 的等价声明，其中使用了类型别名 void useBigger(const string&, const string&, Func); void useBigger(const string&, const string&, funcP2); 这两个声明语句声明的是同一个函数，第一条语句中，编译器自动地将 Func 表示的函数类型转换成指针。 返回指向函数的指针 虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。 // 使用类型别名 using F = int(int*, int); // F是函数类型，不是指针 using PF = int(*)(int*, int); // PF 是指针类型 其中我们使用类型别名将 F 定义成函数类型，将 PF 定义成指向函数类型的指针。必须时刻注意，和函数类型的形参不一样，返回类型不会自动地转换成指针。必须显示地将返回类型指定为指针： PF f1(int); // 正确：PF 是指向函数的指针，f1 返回指向函数的指针 F f1(int); // 错误，F是函数类型，f1 不能返回一个函数 F *f1(int); // 正确，显示地指定返回类型是指向函数的指针 也能用下面的形式直接声明 f1： int (*f1(int))(int*, int); 按照由内向外的顺序阅读这条代码：f1有形参列表，f1是个函数；f1前面有 *，f1返回一个指针；指针的类型本身也包含形参列表，指针指向函数，该函数的返回类型是 int。 也可以使用尾置返回类型的方式声明一个返回函数指针的函数。 auto f1(int) -> int(*)(int*, int); 将 auto 和 decltype 用于函数指针类型 ​ 如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程。 string::size_type sumLength(const string&, const string&); string::size_type largerLength(const string&, const string&); // 根据形参的取值，getFunc 函数返回指向sumLength 或者 largerLength的指针 decltype(sumLength)* getFunc(const string&);"
  },
  "Languages/Chapter7/7.1.html": {
    "href": "Languages/Chapter7/7.1.html",
    "title": "7.1 定义抽象数据类型",
    "keywords": "7.1 定义抽象数据类型 ​ 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 ​ 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。 ​ 类要想实现数据抽象和封装，需要定义一个抽象数据类型。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。 7.1.1 设计 Sales_data 类 Sales_data 的接口应该包含以下操作： 一个 isbn 成员函数，用于返回对象的 isbn 编号。 一个 combine 成员函数，用于将一个 Sales_data 对象加到另一个对象上。 一个名为 add 的函数，执行两个 Sales_data 对象的加法。 一个 read 函数，将数据从 istream 读入到 Sales_data 对象中。 一个 print 函数，将 Sales_data 对象的值输出到 ostream。 struct Sales_data{ std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } // 非成员接口 Sales_data add(const Sales_data&, const Sales_data&); std::ostream &print(std::ostream&, const Sales_data&); std::istream &read(std::istream&, Sales_data&); const 成员函数 ​ isbn 函数的另一个关键之处是紧随参数列表之后的 const 关键字，这里，const 的作用是修改隐式 this 指针的类型。修饰之后，意味着不能在该函数内部修改成员变量的内容，该函数内部也不能调用非 const 成员函数。成员函数声明为 const 函数，有助于维护代码的健壮性。const 成员函数，也称为 常量成员函数 。 常量对象、常量对象的引用或者指针只能调用常量成员函数。 类的作用域和成员函数 类本身是一个作用域，所以类内部的成员函数可以访问到成员变量。isbn 定义在 bookno 前面，也能够在访问到 bookno 的原因是编译器首先编译成员的声明，然后才编译成员函数体。 在类的外部定义成员函数 在类的外部定义成员函数时，要求定义的返回类型、参数列表和声明的一致。如果是常量成员函数，定义时也要加上const关键字。而且在类外定义要加上类的名字，这是因为在类外部，可能一个文件里存在多个类，不同的类可能有名字相同的函数。 // 例如 template<class t> inline size_t LinkList<t>::GetLength() { int len = 0; auto current = phead; // 获取头指针 while ( current && ptail != current) { len++; current = current->next; } return len; } 定义一个返回 this 对象的函数 ​ 函数 combine 的设计初衷类似于复合赋值运算符 += ，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数： Sales_data& Sales_data::combine(const Sales_data& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象 } 7.1.3 定义类相关的非成员函数 ​ 这些非成员函数，大多数是用于辅助类，比如对其进行数据输入，打印数据等。把和类相关的非成员函数放到同一个头文件中，这样如果其他文件需要用到这个类，只需引用一个头文件即可。 定义 read 和 print 函数 // 负责读入数据 istream& read(istream& is, Sales_data& item) { double price = 0; is >> item.bookNo >> item.units_sold >> price; item.revenue = price * item.units_sold; return is; } // 负责输出数据 ostream& print(ostream& os, const Sales_data& item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << item.avg_price(); return os; } read 和 print 接受一个 IO 类型的引用参数，这类 IO 类型不能被拷贝，所以用引用；读取和写入会改变流的内容，因此不用 const修饰流参数。 定义 add 函数 // 返回一个两个对象相加后的副本 Sales_data add(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; sum.combine(rhs); return sum; } 7.1.4 构造函数 ​ 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做 构造函数 。构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 ​ 构造函数的名字和类名相同，但是没有返回类型。构造函数也可以重载。构造函数不能被声明成 const。创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正变成常量，所以可以在构造函数中对其写入值。 默认构造函数 ​ 如果没有显式声明一个构造函数的话，那么编译器就会隐式的加上一个默认构造函数，默认构造函数没有实参，并以以下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 某些类不能依赖于构造函数 ​ 一旦定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。 ​ 定义在块中的内置类型或复合类型的对象被默认初始化，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。不然当创建类的对象时可能得到未定义的值。 ​ 如果类中包含了一个其他类类型的成员，且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。 定义 Sales_data 的构造函数 一个 const string&，表示 ISBN 编号；一个 unsigned，表示售出的图书数量；以及一个 double，表示图书的出售价格。 一个 const string&，表示 ISBN 编号；编译器将赋予其他成员默认值； 一个空参数列表。 struct Sales_data{ Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } 构造函数初始值列表 像下面这个构造函数，在参数列表后面加上冒号，紧接着是类成员跟小括号加上参数，这等同于把s赋值给 bookNo，n 赋值给units_sold，p*n 赋值给 revenue。 Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} 有趣的是如果在构造函数内部再给bookno赋值，和参数不同，最终bookno的值到底是和s一样呢，还是和构造函数体中赋值的一样呢？ Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n) { bookNo = \"100101\"; } // 调用Sales_data(\"111111\", 5, 10); // 打印bookNo，得到的结果是100101 // 这样看起来，是先执行构造函数初始值列表赋值，再执行函数体 在类的外部定义构造函数 Sales_data(std::istream& is) { read(is, *this); } 7.1.5 拷贝、赋值和析构 略。"
  },
  "Languages/Chapter7/7.2.html": {
    "href": "Languages/Chapter7/7.2.html",
    "title": "7.2 访问控制与封装",
    "keywords": "7.2 访问控制与封装 在之前的定义中，Sales_data 类内部并没有封装起来，任何外部的 Sales_data 对象（实例化）都可以直接访问内部的数据成员。可以使用 访问说明符 加强类的封装性： 定义在 public 说明符之后的成员在整个程序内可被访问，public 成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问， private 部分封装了类的实现细节。 再定义 Sales_data 类： class Sales_data{ public: Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } class 和 struct 关键字 使用 class 关键字而非 struct 开始类的定义的区别是 struct 的默认访问权限是public，而类的默认访问权限是private。最好是都显示写出关键字来，一个是不耗费太多功夫，二是大家阅读访问。 7.2.1 友元 ​ 如果将 Sales_data 类的数据成员定义成 private，那么 read、print、add等非函数成员也就无法访问类的数据成员。可以用友元来支持类外部的其他类或者函数来访问类内的私有成员。需要增加 friend 关键字。 class Sales_data{ // 友元声明 friend Sales_data add(const Sales_data&, const Sales_data&); friend std::istream& read(std::istream&, Sales_data&); friend std::ostream& print(std::ostream&, const Sales_data&); public: Sales_data() = default; // c++11特性，等同于默认构造函数 Sales_data(const std::string& s):bookNo(s){} Sales_data(const std::string& s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n){} Sales_data(std::istream&); std::string isbn() const {return bookNo;} Sales_data& combine(const Sales_data&); private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } // 返回一个两个对象相加后的副本 Sales_data add(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; sum.combine(rhs); return sum; } // 负责读入数据 istream& read(istream& is, Sales_data& item) { double price = 0; is >> item.bookNo >> item.units_sold >> price; item.revenue = price * item.units_sold; return is; } // 负责输出数据 ostream& print(ostream& os, const Sales_data& item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << item.avg_price(); return os; } 友元声明只能出现在类的内部。 封装的好处 确保用户代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 一般友元函数放在和类声明的同一个文件，方便管理。"
  },
  "Languages/Chapter7/7.3.html": {
    "href": "Languages/Chapter7/7.3.html",
    "title": "7.3 类的其他特性",
    "keywords": "7.3 类的其他特性 Screen 和 Window_mgr 是一对相互关联的类。 7.3.1 类成员再探 定义一个类型成员 class Screen{ public: typedef std::string::size_type pos; // 类型别名 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; }; 这里在类的内部用了类型别名，意图在于不想让调用这个类的程序员知道类内部使用了 string::size_type 这种类型。 定义类型的成员必须先定义后使用，像下面这样是不可以的： class Screen { // 先使用后定义 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; public: typedef std::string::size_type pos; // 类型别名 }; Screen 类的成员函数 因为 光标位置，宽，高定义成私有成员，用户访问不到，所以需要一个构造函数负责写入数据： class Screen{ public: typedef std::string::size_type pos; // 类型别名 Screen() = default; // cursor 被其他类内初始值值初始化为0 Screen(pos ht, pos wd, char c):height(ht), width(wd), contents(ht * wd, c){} char get() const{ return contents[cursor]; } inline char get(pos ht, pos wd) const; // 显示内联 Screen &move(pos r, pos c); // 能在之后被设为内联 private: pos cursor = 0; // 光标位置 pos height = 0; // 高 pos width = 0; // 宽 std::string contents; }; 这里用到了类内的类型别名，之前说过类本身是一个作用域，那怎么使用类内的别名？ 类外部这样使用：Screen::pos 类内部直接使用：pos 令成员作为内联函数 在类外部用inline关键字修饰函数： inline Screen& Screen::move(pos r, pos c) { pos row = r * width; // 计算行的位置 cursor = row + c; // 在行内将光标移动到指定的列 return *this; // 以左值的形式返回对象 } char Screen::get(pos r, pos c) const { pos row = r * width; // 计算行的位置 return contents[row + c]; // 返回给定列的字符 } 可变数据成员 mutable 某些特殊情况下，希望修改类的某个数据成员，就算在 const 成员函数内，也能修改。一个 可变数据成员 永远不会是 const，即使它是 const 对象的成员。 class Screen{ public: void some_number() const; private: mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改。 } void Screen::some_number() const { ++access_ctr; } 类数据成员的初始值 窗口管理类 class Window_mgr{ private: // C++11新特性 // 这个window_mgr 追踪的Screen // 默认情况下，一个window_mgr 包含一个标准尺寸的空白screen std::vector<Screen> screens{Screen(24, 80, ' ')}; } 7.3.2 返回 *this 的成员函数 class Screen{ public: Screen& set(char); Screen& set(pos, pos, char); // 这里其他函数省略不写 }; inline Screen& Screen::set(char c) { contents[cursor] = c; // 设置当前光标所在位置 return *this; // 将this 对象作为左值返回 } inline Screen& Screen::set(pos r, pos col, char ch) { contents[r*width + col]; return *this; } 通过返回*this，返回引用的函数时左值的，set函数返回的是对象本身而非对象的副本。 myScreen.move(4,0).set('#'); // 等价于 auto a = myScreen.move; // 这里的a指向myScreen a.set('#'); 如果move返回的是 Screen 而不是 Screen&，那么情况大不相同。 myScreen.move(4,0).set('#'); // 等价于 auto temp = myScreen.move(4, 0); // 对返回值进行拷贝 temp.set('#'); // temp并非指向myScreen，而是一个副本 从 const 成员函数返回 *this ​ 如果要添加一个打印函数 display，显然这个函数只读入数据，不会写入数据，所以给理应给 display 函数加上 const 限定符。这个 display 函数返回 *this。则返回的将是一个 const Screen&类型。 inline Screen& Screen::display() const // 错误 { return *this; // TODO: 在此处插入 return 语句 } 如果想上面这样定义，编译器会提示，限定符 const 被丢弃。意思是，你都是一个 const 函数了，返回的 *this，默认是 const 的。 所以应该这样定义： inline const Screen& Screen::display(ostream& os) const { // todo: 输出数据 return *this; } 那就不能够再通过display去左值调用set函数了。 Screen myScreen; myScreen.display(cout).set('*'); // 错误，const左值不能调用set 基于 const 的重载 ​ 通过区分成员函数是否是 const 的，我们可以对其进行重载。 class Screen{ public: Screen& display(std::ostream& os) { do_display(os); return *this; } const Screen& display(std::ostream& os) const { do_display(os); return *this; } private: void do_display(std::ostream& os) const { os << contents; } } 这样，当对象调用display时，就会匹配最佳函数： Screen myScreen(5, 3); const Screen blank(5, 3); myScreen.set('#').display(cout); // 调用非常量函数 blank.display(cout); // 调用常量函数 7.3.3 类类型 struct First{ int memi; int getMem(); }; struct Second{ int memi; int getMem(); }; First obj1; Second sec = obj1; // 错误，obj1 和 sec 的类型不同 即使两个类的成员列表完全一致，但是它们两个是不同的类型。 可以把类名作为类型的名字使用，从而直接指向类类型。也可以把类名跟在关键字 class 或 struct 后面： Sales_data item1; class Sales_data item1; // 等价 Sales_data item1; 7.3.4 友元再探 友元类 Window_mgr 类功能上是管理 Screen 类的，可能某些函数需要访问 Screen 类的私有成员。比如 Window_mgr 有一个 clear 函数。作用是清除 Screen 对象的数据。这时候就需要用到 友元类 。 class screen{ friend class Window_mgr; // Window_mgr 可以访问 Screen 的私有成员 } class Window_mgr{ public: using ScreenIndex = std::vector<Screen>::size_type; void clear(ScreenIndex); private: std::vector<Screen> Screens{Screen(24, 80, ' ')}; } void Window_mgr::Clear(ScreenIndex index) { Screen& s = Screens[index]; s.contents = string(s.height * s.width, ' '); } 友元关系不存在传递性，每个类负责控制自己的友元类或者友元函数。 令成员函数作为友元 除了令整个 Window_mgr 作为友元外，Screen 还能只为 Clear 函数提供访问权限。当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类： class Screen{ // Window_mgr::Clear 必须在Screen类之前被声明； friend void Window_mgr::Clear(ScreenIndex); // ... } 要做到成员函数为友元，代码设计上需要： 首先定义 Window_mgr 类，其中声明 Clear 函数，但是不能定义它。在 Clear 使用Screen 的成员之前必须先声明Screen。 接下来定义 Screen，包括对 Clear 的友元声明。 最后定义 Clear，此时它才可以使用 Screen 的成员。 #pragma once #include<string> #include<vector> class Screen; class Window_mgr1 { public: using ScreenIndex = std::vector<Screen>::size_type; void Clear(ScreenIndex index); public: std::vector<Screen> Screens; }; class Screen { friend void Window_mgr1::Clear(ScreenIndex); public: typedef std::string::size_type pos; // 类型别名 Screen() = default; // cursor 被其他类内初始值值初始化为0 Screen(pos ht, pos wd, char c) :height(ht), width(wd), contents(ht* wd, c) {} char get() const { return contents[cursor]; } inline char get(pos ht, pos wd) const; // 显示内联 Screen& move(pos r, pos c); // 能在之后被设为内联 const Screen& display()const; private: std::string::size_type cursor = 0; // 光标位置 std::string::size_type height = 0; // 高 std::string::size_type width = 0; // 宽 std::string contents; }; inline Screen& Screen::move(pos r, pos c) { pos row = r * width; // 计算行的位置 cursor = row + c; // 在行内将光标移动到指定的列 return *this; // 以左值的形式返回对象 } inline const Screen& Screen::display() const { std::cout << contents << std::endl; return *this; // TODO: 在此处插入 return 语句 } char Screen::get(pos r, pos c) const { pos row = r * width; // 计算行的位置 return contents[row + c]; // 返回给定列的字符 } void Window_mgr1::Clear(ScreenIndex index) { Screen& s = Screens[index]; s.contents = std::string(s.height * s.width, ' '); } 尽管可以这样做，但是会发现，原来 Screens 容器默认有一个数据，现在做不到了，这是因为在Window_mgr之前只是声明了Screen，并没有具体实现Screen带三个参数的构造函数。所以只能忍痛去掉。 函数重载和友元 ​ 尽管重载函数的名字相同，但是它们任然是不同的函数，如果一个类想把一组重载函数声明为它的友元，它需要对这组函数中的每一个分别声明。 友元声明和作用域 ​ 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而友元本身不一定真的声明在当前的作用域中。 ​ 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。 struct x{ friend void f(){/* 友元函数可以定义在类的内部*/} X(){f();} // 错误，f还没有声明 void g(); void h(); } void X::g(){return f();} // 错误，f还没被声明 void f(); void X:h(){return f();} //正确，f已经声明了"
  },
  "Languages/Chapter7/7.4.html": {
    "href": "Languages/Chapter7/7.4.html",
    "title": "7.4 类的作用域",
    "keywords": "7.4 类的作用域 ​ 每个类都会定义类本身的作用域。在类外部，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符访问。对类类型成员则使用作用域运算符访问。 Screen::pos ht = 24, wd = 80; // pos类型是类类型，定义在Screen内部 Screen scr(ht, wd, ' '); Screen *p = &scr; char c = scr.get(); c = p->get(); // 使用成员指针访问运算符 这节知识点，大多数情况下不需要了解，有时间再补充。"
  },
  "Languages/Chapter7/7.5.html": {
    "href": "Languages/Chapter7/7.5.html",
    "title": "7.5 构造函数再探",
    "keywords": "7.5 构造函数再探 7.5.1 构造函数初始值列表 如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。 Sales_data::Sales_data(const string& s, unsigned cnt, double price) { bookNo = s; units_sold = cnt; revenue = cnt * price; } 构造函数的初始值有时必不可少 有的程序员在定义类时，忽略对数据成员初始化的重视程度。如果成员是 const 或者是 引用的，必须要初始化。 class ConstRef{ public: ConstRef(int ii); private: int i; const int ci; int &ri; } 成员 ci 和 ri 必须初始化。如果我们 没有为它们提供构造函数初始值的话将引发错误： // 错误，ci 和 ri 必须被初始化 ConstRef::ConstRef(int ii) { i = ii; ci = ii; // 错误 ri = i; // 错误 } 编译不通过，ConstRef(int ii) 是重载了默认构造函数，而const int 和 int& 的类成员必须用初始值列表来初始化。 // 正确 class ConstRef { public: ConstRef(int ii):i(ii),ci(ii),ri(i){} private: int i; const int ci; int& ri; }; 而且初始化和赋值是两回事，赋值是先初始化在赋值。初始化值比赋值高效。 成员初始化的顺序 class X{ int i; int j; public: X(int val):j(val), i(j){} } 初始值列表的初始化顺序和成员定义的顺序有关，与初始值列表的变量排放顺序无关。比如上面这段代码，就是先初始化i，在初始化j的。显然上面这个代码有问题。 7.5.2 委托构造函数 C++11 新标准支持构造函数初始值的功能，即 委托构造函数 。 class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} // 剩余的构造函数委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s): Sales_data(s, 0, 0){} Sales_data(std::istream& is):Sales_data(){read(is, *this);} } 功能上来说等价于： class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} Sales_data() { Sales_data(\"\", 0, 0); } Sales_data(std::string s){ Sales_data(s, 0, 0); } Sales_data(std::istream& is){ Sales_data(); read(is, *this); } } 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后接着才执行委托者的函数体。 7.5.4 隐式的类类型转换 7.1节中我们为 Sales_data 类定义了一个 combine 函数： Sales_data& Sales_data::combine(const Sales_data& rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; // 返回调用该函数的对象 } 如果我们像下面这样调用： string null_book = \"9-999-999999-9\"; item.combine(null_book); // 这样可以通过编译，item1的boolNo就是被 null_book初始化了 Sales_data item1 = null_book; 代码看起来似乎是错误的，因为成员函数 combine接受的是一个 Sales_data 对象的引用，但是实际上缺能够编译通过。这是因为 null_book 作为参数传入后，Sales_data 有一个构造函数带一个 string 类型参数，此时会创建一个 Sales_data 类型的临时变量，作为参数然后传入 combine。 显然也可以用一个输入流作为 “参数” 调用combine： item.combine(std::cin); 特定场景下不希望 Sales_data 类的使用者这样调用 combine，该怎么做？ 抑制构造函数定义的隐式转换 在声明构造函数时加上关键字 explicit : class Sales_data{ public: Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} // 剩余的构造函数委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} explicit Sales_data(std::string s): Sales_data(s, 0, 0){} explicit Sales_data(std::istream& is):Sales_data(){read(is, *this);} } 关键字 explicit 只对带一个参数的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，也就不需要为那些多个或0个参数的构造函数指定 explicit。只能在类内声明构造函数时使用关键字，在类外定义时不能重复是用 explicit。 // 错误 explicit Sales_data::Sales_data(istream& is) { read(is, *this); } explicit 只能用于直接初始化，不能用于值初始化： Sales_data item(null_book); // 正确 Sales_data item = null_book; // 错误 为转换显式地使用构造函数 // explicit Sales_data(std::string) item.combine(Sales_data(null_book)); // 正确 item.combine(const_cast<Sales_data>(cin)); // 正确，const_cast 可以解 explicit 7.5.5 聚合类 不推荐使用这个用法。 要求所有的成员是public的，没有定义任何构造函数，没有类内初始值，没有基类，没有 virtual 函数。 struct Data{ int ival; string s; } // 初始化时就可以这样，大括号的参数赋值按成员的顺序来赋值，否则可能出错。 // 大括号的元素个数少于成员变量，剩下的成员变量就变成值初始化。 Data d = {0, \"Anna\"}; 7.5.6 字面值常量类 略。"
  },
  "Languages/Chapter7/7.6.html": {
    "href": "Languages/Chapter7/7.6.html",
    "title": "7.6 类的静态成员",
    "keywords": "7.6 类的静态成员 类的静态成员是指成员只和类相关，不与对象相关，所有该类型的对象共享静态成员。只要改变静态成员，其他对象访问的静态成员都会受到影响。 class Account{ public: void calculate(){ amount += amount * interestRate;} static double rate(){return interestRate;} static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate(); }; 类的静态成员存在于任何对象之外，对象中不包含任何于静态数据成员有关的数据。 静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。静态成员函数不能声明为 const 的，而且我们也不能在 static 函数体内使用 this 指针。 如何使用？ double r = Account::rate(); // 作用域访问运算符访问静态成员 也可以通过类的对象、引用或者指针访问静态成员： Account ac1; Account* ac2; r = ac1.rate(); r = ac2->rate(); 如果在类的外部定义静态成员函数，不能重复 static 关键字。 静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的。也就是说，静态数据成员不是由类的构造函数初始化的。不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员。一个静态数据成员只能定义一次。 double Account::interestRate = initRate(); 静态成员类内初始化 类的静态成员不应该在类内初始化，但是可以为静态成员提供 const 整数类型的类内初始值，要求静态成员必须是字面值常量类型 constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有合适于常量表达式的地方。 class Account{ public: static double rate(){ return interestRate; } static void rate(double); static constexpr int period = 30; // period 是常量 double daily_tbl[period]; } 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 与普通成员的一些不同 class Bar{ public: // ... private: static Bar mem1; Bar*mem2; Bar mem3; // 错误 } 此外，非静态数据成员不能作为默认实参，但是静态数据成员却可以。 class Screen{ public : Screen& clear(char = bkground); private: static const char bkground; }"
  },
  "Languages/Chapter8/8.1.html": {
    "href": "Languages/Chapter8/8.1.html",
    "title": "8.1 IO 类",
    "keywords": "8.1 IO 类 三个关于 IO 类型的头文件： 头文件 类型 iostream istream，wistream 从流读取数据 ostream，wostream 向流写入数据 iostream，wiostream 读写流 fstream ifstream，wifstream 从文件读取数据 ofstream，wofstream 向文件写入数据 fstream，wfstream 读写文件 sstream istringstream，wistringstream 从 string 读取数据 ostringstream，wostringstream 向 string 写入数据 stringstream，wstringstream 读写 string 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵 wchar_t 类型的数据。宽字符版本的类型和函数的名字以一个 w 开始。 支持宽字符 支持普通字符 wcin cin wcout cout wcerr cerr IO对象不可拷贝或赋值 流对象不可拷贝也不能用 const 修饰。一般流都用引用。 8.1.2 流的条件状态 状态或函数 释义 std::ios::iostate iostate是一种机器相关的类型，提供了表达条件状态的完整功能。 std::ios::badbit 指出流已崩溃 std::ios::failbit 指出 IO 操作失败了 std::ios::eofbit 指出流到达了文件结束 std::ios::goodbit 指出流未处于错误状态。此值保证为零 s.eof() 若流 s 的 eofbit 置位，返回 true。 s.fail() 若流 s 的 failbit 或badbit 置位，返回 true s.bad() 若流 s 的 badbit 置位，返回 true s.good() 若流 s 处于有效状态，返回 true s.clear() 若流 s 中所有条件状态复位，将流的状态设置为有效。返回 void 根据给定的 flags 标志位，将流 s 中对应条件状态复位。 flags 的类型为 iostate。返回 void s.clear(flags) 若流 s 中所有条件状态复位，将流的状态设置为有效。返回 void 根据给定的 flags 标志位，将流 s 中对应条件状态复位。 flags 的类型为 iostate。返回 void s.setstate(flags) 根据给定的 flags 标志位，将流 s 中对应条件状态位置位。flags 的类型为 iostate。返回 void s.rdstate() 返回流s 的当前状态，返回值类型为 iostate void test(istream& os, int& i) { os >> i; auto state = os.rdstate(); switch (state) { case std::ios::badbit: cout << \"流崩溃了\" << endl; break; case std::ios::failbit: cout << \"IO 操作失败了\" << endl; break; case std::ios::eofbit: cout << \"流到达文件结尾了\" << endl; break; case std::ios::goodbit: cout << \"流处于正确状态\" << endl; break; default: cout << \"流处于未知状态\" << endl; break; } } int main(int argc, char* argv[]) { int i; test(cin, i); cout << i << endl; return 0; } // 输入：15 // 输出： // 流处于正确状态 // 15 // 输入：Boo // 输出： // IO 操作失败 // 0 如果去看 badbit这几个类型定义的话，长这样： static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0); static constexpr _Iostate eofbit = static_cast<_Iostate>(0x1); static constexpr _Iostate failbit = static_cast<_Iostate>(0x2); static constexpr _Iostate badbit = static_cast<_Iostate>(0x4); 用16进制表示的 0, 1, 2, 4。也就是： 十六进制表示 二进制表示 goodbit 0x0 0000 eofbit 0x1 0001 failbit 0x2 0010 badbit 0x4 1000 这样的好处是给出一个状态，除了goodbit之外，通过相与可以判断一个状态是否包含上面的任一一个。 8.1.3 管理输出缓冲 系统为了提高对设备或文件的操作效率，做了缓冲区，即当执行到某一条输出流代码时，并不一定立即在黑窗体上显示出来。数据真正写到输出设备或文件的场景有： 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。 缓冲区满时，需要刷新缓冲区。 操作符 unitbuf 强制刷新，清空缓冲区；cerr默认设置了unitbuf。 一个输出流可能被关联到另一个流。读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，cin 和 cerr 都关联到 cout。所以读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。 刷新缓冲区 cout << \"hi\" << endl; // 输出 hi 和一个换行，然后刷新缓冲区 cout << \"hi\" << flush; // 输出 hi，然后刷新缓冲区 cout << \"hi\" << ends; // 输出 hi和一个空字符，然后刷新缓冲区 cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都立即刷新，无缓冲 cout <<nonunitbuf; // 回到正常的缓冲方式 程序崩溃时，可能有些测试数据并没有被刷新出来，所以定位bug时记得刷新一些输出缓冲区。"
  },
  "Languages/Chapter8/8.2.html": {
    "href": "Languages/Chapter8/8.2.html",
    "title": "8.2 文件输入输出",
    "keywords": "8.2 文件输入输出 fstream 除了继承自 iostream 的操作外，还有自己的一套： 操作 释义 fstream fstrm 创建一个未绑定的文件流。fstream 是头文件 fstream 中定义的一个类型 fstream fstrm(s); 创建一个 fstream，并打开名为 s 的文件。s 可以是 string 类型，或者是一个指向 C 风格字符串的指针。这些构造函数都是 explicit 的，默认的文件模式 mode 依赖于 fstream 的类型 fstream fstrm(s,mode); 与前一个构造函数类似，但按指定mode打开文件 fstrm.open(s) 打开名为 s 的文件，并将文件与 fstrm绑定。s可以是一个string类型或一个 指向C风格字符串的指针。默认的文件mode依赖于fstream的类型。返回void fstrm.close() 关闭与 fstrm 绑定的文件。返回void fstrm.is_open() 返回一个bool值，指出与 fstrm 关联的文件是否成功打开且尚未关闭。 8.2.1 使用文件流对象 int main(int argc, char* argv[]) { string ifileName = \"D:/OneDrive/桌面/demo/sales_data.txt\"; string ofileName = \"D:/OneDrive/桌面/demo/sales_data_result.txt\"; ifstream ifile(ifileName); ofstream ofile(ofileName); Sales_data total; if (read(ifile, total)) // 读取第一条销售记录 { Sales_data trans; // 保存下一条销售记录的变量 while (read(ifile, trans)) { if (total.isbn() == trans.isbn()) { total.combine(trans); } else { print(ofile, total) << endl; total = trans; // 处理下一本书 } } print(ofile, total) << endl; } else cerr << \"No Data?!\" << endl; return 0; } 因为 fstream 继承 iostream，所以之前写的 read 和 print 函数也是可以用的。 我在输入文件sales_data.txt中写入内容： 978-7-229 9 36.6 978-7-229 130 36.6 978-7-229 100 36.6 273-7-209 100 21.4 971-8-229 9 89.5 971-8-229 11 89.5 运行程序后得到： 978-7-229 239 8747.436.6 273-7-209 100 214021.4 971-8-229 20 179089.5 手工算了下，没错。运行过程中，如果程序打开了输出文件sales_data_result.txt，但是程序没有执行到 print 时异常结束（调试，直接终止程序），sales_data_result.txt文件内容会被清空，要注意这个情况。 成员函数open和close 成员函数 open 打开指定文件。 close 关闭当前流相关联的文件。 open文件后，一般先判断流是否正确打开了文件。 ifstream input; input.open(path1); if(out) // 判断是否正确打开 { // ... } // 如果open失败了，断开流与path1文件的关联 out.close(); out.open(path2); //再打开另一个文件 8.2.2 文件模式 模式 in 以读方式打开 out 以写方式打开 app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO 只可以对 ofstream 或 fstream 对象设定 out 模式。 只可以对 ifstream 或 fstream 对象设定 in 模式。 只有当 out 也被设定时才可以设定 trunc 模式。 只要 trunc 没被设定，就可以设定 app 模式。在 app 模式下，即使没有显式指定 out 模式，文件也总是以输出方式被打开。 默认情况下，即使我们没有指定 trunc，以 out 模式打开的文件也会被截断。为了保留以 out 模式打开的文件的内容，我们必须同时指定 app 模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。 ate 和 binary 模式可用于任何类型的文件流对象，且可以于其他任何文件模式组合使用。 以 out 模式打开文件会丢弃已有数据 如果 ostream 打开文件以默认的方式（ios::out）打开，那么每次保存文件时，会先清空文件内容，再将程序的结果写入文件。可以在打开文件的时候指定文件的模式为 ios::app，这样就可以在文件原有的内容基础上进行内容追加到文件末尾。 8.3 string 流 流名 释义 istringstream 从 string 读入数据 ostringstream 向 string 写入数据 stringstream 即可从 string 读数据也可向 string 写数据 sstream 继承 iostream，但是也有一套自己的操作： 操作 sstream strm; strm 是一个未绑定的 stringstream 对象。sstream 是头文件 sstream 中定义的一个类型。 sstream strm(s); strm 是一个 sstream对象，保存 string s 的一个拷贝。此构造函数是 explicit 的。 strm.str(); 返回 strm 所保存的 string 的拷贝。 strm.str(s); 将 string s 拷贝到 strm 中。返回 void string 流使用示例 假定有一个文件，列出了一些人名和他们的电话号码。其中某些人只有一个号码，而另一些人有多个号码。列如： morgan 13778776342 13557989912 drew 18804202645 lee 7710-8786500 18787875434 个人信息类 struct PersonInfo{ string name; vector<string> phones; }; 读入程序： void HandleMes(std::istream& is, std::ostream& os) { std::string line, word; std::vector<PersonInfo> people; while (getline(is, line)) // getline 每次只从流中读入一行 { PersonInfo info; std::istringstream record(line); record >> info.name; while (record >> word) { info.phones.push_back(word); } people.push_back(info); } // 将信息重新组织 for (auto p : people) { os << p.name << \": \"; for (auto t : p.phones) { os << t << \" \"; } os << std::endl; } } // 主函数调用 int main(int argc, char* argv[]) { string ifileName = \"D:/OneDrive/桌面/demo/info.txt\"; string ofileName1 = \"D:/OneDrive/桌面/demo/PersonMsg.txt\"; ifstream ifile(ifileName); ofstream ofile(ofileName1); HandleMes(ifile, ofile); return 0; } 得到数据 PersonMsg.txt： morgan: 13778776342 13557989912 drew: 18804202645 lee: 7710-8786500 18787875434"
  },
  "Languages/Chapter9/9.1.html": {
    "href": "Languages/Chapter9/9.1.html",
    "title": "9.1 顺序容器",
    "keywords": "9.1 顺序容器 以下列表中的顺序容器都提供了快速顺序访问元素的能力。但是在一些方面的性能不同： 向容器添加或从容器中删除元素的代价。 非顺序访问容器中元素的代价。 容器名 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。 list 双向链表。支持双向顺序访问。在 list 中任何位置进行插入/删除操作速度很快。 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 array 固定大小数组。支持快速随机访问。不能添加或删除元素。 string 与 vector 相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 string 和 vector 将元素保存在连续的内存空间中，可以由元素的下标计算地址，速度很快。但是在容器的 中间位置 添加或删除元素就会很耗时：因为在一次 插入/删除元素操作后，需要移动插入/删除元素位置后面的所有元素，来保持连续存储。而且添加一个元素有时可能需要分配额外的存储空间。每个元素都必须移动到新的存储空间中。 list 和 forward_list 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。但是容器不支持元素的随机访问，也就是说不能通过下标去访问，要访问一个元素，只能从头到尾一个一个去遍历。额外内存开销也相对较大。 deque 支持快速的随机访问。在中间位置插入/删除元素代价高。在两端插入/删除元素很快，性能与 list 相当。 forward_list 和 array 是新C++标准增加的。与内置数组相比，array 是一种更安全、更容易使用的数组类型。 选用容器准则参考 一般都是用 vector。 如果程序有很多小的元素，而且空间的额外开销很重要，则不要使用 list 或 forward_list。 如果程序要求随机访问元素，应使用 vector 或 deque。 如果程序要求在容器的中间插入或删除元素，应该使用 list 或 forward_list。 如果程序需要在头尾位置插入或删除原，但不会在中间位置进行插入或删除元素，使用deque。 如果程序需要在输入时才需要在容器中间插入元素，随后随机 访问元素。 先使用 vector，还可以进行排序。 此外，可以考虑先用 list，然后再把数据拷贝到 vector。 9.2 容器库 下面的操作是所有容器共有的操作： 操作名 iterator 此容器类型的迭代器类型 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能容器的大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型；与value_type& 含义相同 const_reference 元素的const左值类型（即，const value_type&) C c; 默认构造函数，构造空容器 C c1(c2); 构造 c2 的拷贝 c1 C c(b, e); 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c (array不支持) C c{a, b, c...}; 列表初始化 c c1 = c2 将 c1 中的元素替换为 c2 中元素 c1 = {a, b, c... } 将 c1 中的元素替换为列表中元素（不适用array） a.swap(b) 交换 a 和 b 的元素 swap(a, b) 与 a.swap(b) 等价 c.size() c 元素的数目（不支持 forward_list） c.max_size() c 中可保存的最大元素的数目 c.empty() 若 c 中存储了元素，返回 false，否则返回 true c.insert(args) 将 args的元素拷贝到 c c.emplace(inits) 使用 inits 构造 c 中的一个元素 c.erase(args) 删除 args 指定的元素 c.clear() 删除 c 中所有元素，返回 void ==, != 所有容器都支持相等，不相等运算符 <，<=，>，>= 关系运算符 c.begin()，c.end() 返回指向 c 的首元素和尾元素之后位置的迭代器 c.cbegin()，c.cend() 返回 const_iterator reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 不能修改元素的逆序迭代器 c.rbegin()，c.rend() 返回指向 c 的尾元素和首元素之前位置的迭代器 c.crbegin()，c.crend() 返回 const_reverse_iterator 9.2.1 迭代器 之前的章节已经介绍过了通过迭代器去遍历和访问容器：通过迭代器进行++或--操作，可以移动迭代器指向的元素，读取元素值通过解引用运算符读取。forward_list 不支持 -- 操作。 迭代器范围 由两个迭代器组成，分别指向同一个容器中的元素和尾元素之后的位置。数学描述： [begin，end) 称为 左闭合区间 。 9.2.2 容器类型成员 反向迭代器 方向迭代器是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作也都发生了颠倒。对一个反向迭代器执行++操作，会得到上一个元素。 类型别名 在不了解容器中的元素类型的情况下，如果需要元素类型，可以使用容器中的 value_type。如果需要元素类型的一个引用，可以使用 reference 或 const_reference。这些元素相关的类型别名在泛型编程中非常有用。 list<string>::iterator iter; vector<int>::difference_type count; 9.2.3 begin 和 end 成员 begin 和 end 操作，生成指向容器中第一个元素和尾元素之后位置的迭代器。 带r的版本返回反向迭代器； 以c开头的版本返回 const 迭代器。 9.2.4 容器定义和初始化 除了 array 外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。 C seq(n); // seq 包含 n 个元素，这些元素进行了值初始化 C seq(n, t) // seq 包含 n 个初始化为值 t 的元素 将一个容器拷贝给另一个容器 将容器直接拷贝给另一个容器 要求两个容器的类型及元素的类型必须匹配。 list<string> authors = {\"Mike\", \"Vincent\", \"cristal\"}; list<string> authorlist(authors); // 正确 list<char*> al(authors); // 错误 vector<string> vec(authors); // 错误 由一对迭代器指定范围 要求元素类型一致或者能转换。 list<string> authors = {\"Mike\", \"Vincent\", \"cristal\"}; vector<string> authorlist(begin(authors), end(authors)); // 正确 list<char*> al(begin(authors), end(authors)); // 正确 // it 是 authors 有效迭代器 deque<string> de(begin(athuors), it); array array 的大小也是类型的一部分。定义一个 array 时，除了指定元素类型，还要指定容器大小： array<int, 42> // 类型为：保存 42 个 int 的数组 array<string, 10> // 类型为：保存 10 个 string 的数组 必须指定元素类型和大小。 array<int, 10>::size_type i; // 即使要用size_type 也要把大小标出 array<int>::size_type j; // 错误 一个默认构造的 array 是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，和内置数组中的元素那样。 如果对 array 进行列表初始化，初始值的数目必须等于或小于 array 的大小。 如果初始值列表的数目小于 array 的大小，则它们被用来初始化 array 靠前的元素，剩下的元素都会进行值初始化。因此，如果 array 元素是类类型，最好这个类型有一个默认构造函数。 array<int, 10> ia1; // 10 个默认初始化的 int array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; array<int, 10> ia3 ={42}; // ia3[0]=42，其余为0 与内置数组的区别： int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int cpy[10] = digs; // 错误 array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; array<int, 10> copy = digits; // 正确。 9.2.5 赋值和 swap 与内置数组不同，array 类型允许赋值。 array<int, 10> a1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; array<int, 10> a2 = {0}; // 所有元素值均为0 a1 = a2; // 正确 a2 = {0}; // 错误 array 类型不止 assign， 也不允许用花括号包围的值列表进行赋值。 容器赋值运算 c1 = c2 将 c1 中的元素替换为 c2 中元素的拷贝。c1 和 c2 必须具有相同的类型。 c={a, b, c...}; 将 c1 中元素替换为初始化列表中元素的拷贝(array不适用) swap(c1, c2); 交换 c1 和 c2 中的元素。c1 和 c2 必须具有相同的类型。swap 通常比从 c2 向 c1 拷贝元素快得多。 c1.swap(c2); 等同 swap(c1, c2); seq.assign(b, e) 将 seq 中的元素替换为迭代器 b 和 e 所表示的范围中的元素。迭代器 b 和 e 不能指向 seq 中的元素。 seq.assign(il); 将 seq 中的元素替换为初始化列表il中的元素。 seq.assign(n, t); 将 seq 中的元素替换为 n 个值为 t 的元素。 使用 assign（仅顺序容器） 赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为 assign 的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign 操作用参数所指定的元素的拷贝替换左边容器中的所有元素。 list<string> names; vector<const char*> oldstyle; names = oldstyle; // 错误，容器类型不匹配 names.assign(oldstyle.cbegin(), oldstyle.cend()); 为什么调用assign时不能用容器自身的迭代器？ 自身的旧元素被替换。 // 等价于 slist1.clear(); // slist1.insert(slist1.begin(), 10, \"Hiya!\"); list<string> slist1(1); slist1.assign(10, \"Hiya!\"); // 10 个元素，每个都是 “Hiya!” 使用 swap vector<string> vec1(10); vector<string> vec2(24); swap(vec1, vec2); swap 交换两个类型相同的容器。 交换后，vec1 将有 24个元素，vec2 将有 10个元素。除了 array 外，交换两个容器的内容很快，元素本身并未交换，只是交换了两个容器的内部数据结构。 除 array 外，swap 不会对任何元素进行拷贝、删除或插入操作，所以可以很快就实现交换。 除 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效。它们仍指向 swap 操作之前所指向的那些元素。但是，在 swap 之后，这些元素已经属于不同的容器了。列如，iter 在 swap 之前指向 vec1[3] 的 string，在 swap 之后它指向 vec2[3]的元素。与其他容器不同，对一个 string 调用 swap 会导致迭代器、引用和指针失效。 用 swap 交换 array，会真正地交换它们的元素，所以耗费时间比其他容器贵。交换后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个 array 中对应元素的值进行了交换。 9.2.6 容器大小操作 每个容器类型都有三个与大小相关的操作： 成员 size() 返回容器中元素的数目 empty() size 为 0 返回 true；否则返回 false。 max_size() 返回一个大于或等于该类型所能容纳的最大元素数的值。 vector<int> vect; cout << vect.max_size() << endl; vector<double> vectd; cout << vectd.max_size() << endl; // 输出 ： // 1073741823 // 536870911 forward_list 不支持 size。 9.2.7 关系运算符 每个容器都支持相等和不等运算符（== 和 !=）。 除了无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）。 关系运算符必须保证两边的容器类型相同，且容器中的元素类型相同。 这些容器的关系运算符工作方式与 string 的关系运算符类似。 关系运算符实现的背后 容器相等运算符实际上是使用元素的 == 运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持上述运算符，那么就不可能实现容器的比较。"
  },
  "Languages/Chapter9/9.3.html": {
    "href": "Languages/Chapter9/9.3.html",
    "title": "9.3 顺序容器操作",
    "keywords": "9.3 顺序容器操作 9.3.1 向顺序容器添加元素 除了 array 外，所有容器都提供了在运行时可以动态添加或删除元素来改变容器大小的操作。 操作 c.push_back(t) 在 c 的尾部创建一个值为 t 的元素。返回 void c.emplace_back(args) 在 c 的尾部一个值由 args 创建的元素。返回 void c.push_front(t) 在 c 的头部创建一个值为 t 的元素。返回 void c.emplace_front(args) 在 c 的头部一个值由 args 创建的元素。返回 void c.insert(p, t) 在迭代器 p 指向的元素之前创建一个值为 t 的元素。返回指向新添加的元素的迭代器 c.emplace(p, args) 在迭代器 p 指向的元素之前由 args 创建的元素。返回指向新添加的元素的迭代器 c.insert(p, n, t) 在迭代器 p 指向的元素之前插入 n 个值为 t 的元素。返回指向新添加的第一个元素的迭代器。若n为 0，返回 p。 c.insert(p, b, e) 将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前。b 和 e 不能指向 c 中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回 0。 c.insert(p, il) il 是一个花括号包围的元素值列表。将这些给定值插入到迭代器p 指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，返回 p。 向一个 vector、string、deque 插入元素会使所有指向容器的迭代器、引用和指针失效。 push_back array、forward_list 不支持push_back。 string word; while(cin >> word) { container.push_back(word); } 每次 push_back，size 就会 +1。 当用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响原始对象。 push_front 见名知意，push_back 是在容器尾部插入新元素，那么 push_front 就是在头部插入新元素。list、forward_list 和 deque 容器都支持 push_front，反而 vector 不支持。 在容器中的特定位置添加元素 每个 insert 函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以 insert 函数将元素插入到迭代器所指定的位置之前。 slist.insert(iter, \"Hello\"); // 将 \"Hello\" 添加到 iter之前的位置 因此如果某些容器不支持 push_front，那么可以用 insert 也能实现同样的功能。 vector<string> svec; list<string> slist; // 等价于调用 slist.push_front(\"Hello\"); slist.insert(slist.begin(), \"Hello\"); // 插入到 vector 末尾之外的任何位置可能很慢 svec.insert(svec.begin(), \"Hello\"); insert 其他版本 // 将 10 个元素插入到 svec 的末尾，并将所有元素都初始化为 string类型 “Anna” svec.insert(svec.end(), 10, \"Anna\"); vector<string> v = {\"quasi\", \"sima\", \"frollo\", \"scar\"}; // 将 v 的最后两个元素添加到 slist 的开始位置 slist.insert(slist.begin(), v.end() - 2, v.end()); slist.insert(slist.end(), {\"these\", \"words\", \"will\", \"go\", \"at\", \"the\", \"end\"}); // 错误，迭代器表示要拷贝的范围，不能指向与目的位置相同的容器 slist.insert(slist.begin(), slist.begin(), slist.end()); 调用 insert时，参数用一对迭代器时不能指向容器本身。 新版下，接受元素个数或范围的 insert 版本返回指向第一个新加入元素的迭代器。如果范围空，不插入任何元素， insert 操作会将第一个参数返回。 list<string> lst; auto iter=lst.begin(); while(cin >> word) { iter = lst.insert(iter, word); // 等价于调用 push_front } emplace 新标准引入了三个新成员： emplace_front、emplace、emplace_back。 上面三个操作构造而不是拷贝元素。这些操作分别对应 push_front、insert、push_back，允许将元素放置容器头部、一个指定位置之前或容器尾部。 调用push或insert成员函数，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数。emplace 成员使用这些参数在容器管理的内存空间中直接构造元素。 // 假定c 保存Sales_data 类型的对象 // 等价于c.push_back(Sales_data(\"978-0593284\", 10, 39.9)); c.emplace_back(\"978-0593284\", 10, 39.9); // 错误 c.push_back(\"978-0593284\", 10, 39.9); 9.3.2 访问元素 访问操作 c.back() 返回 c 中尾元素的引用。若 c 为空，函数行为未定义。 c.front() 返回 c 中首元素的引用。若 c 为空，函数行为未定义。 c[n] 返回 c 中下标为 n 的元素的引用，n是一个无符号整数。若 n>=c.size()，函数行为未定义。 c.at[n] 返回下标为 n 的元素的引用。如果下标越界，则抛出 out_of_range 异常。 对空容器调用 back 和 front 函数，就像数组访问越界一样严重错误。 forward_list 没有 back。 at 和下标操作适用于 string、vector、deque 和 array。 访问成员函数返回的是引用 如果容器是一个const 对象，返回值是 const 的引用。如果容器不是 const，返回的是普通引用。 if(!c.empty()) { c.front() = 42; // 将c中第一个元素赋值 42 auto& v = c.back(); // 指向c最后一个元素的引用 v = 1024; // c中最后一个元素值改为 1024 auto v2 = c.back(); // v2 得到了 c最后一个元素的拷贝 v2 = 0; // c 中最后一个元素值还是 1024，而不是 0 } 编译器在编译的时候，并不会检查数组的访问是否存在越界，但是在运行时我们的程序有可能存在越界的行为，这将会导致程序异常甚至直接崩溃，但是使用 at 函数，如果越界了会抛出一个 out_of_range 异常。 如果去看 at 的处理代码，会发现，其实就是先检查一下，参数是否在容器有效范围内。如果不在有效范围内，执行 _Xrange 抛出异常，否则返回数组下标元素引用。 _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) { auto& _My_data = _Mypair._Myval2; if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) { _Xrange(); } return _My_data._Myfirst[_Pos]; } 9.3.3 删除元素 删除操作 c.pop_back() 删除 c 中尾元素。若 c 为空，则函数行为未定义。函数返回 void c.pop_front() 删除 c 中首元素。若 c 为空，则函数行为未定义。函数返回 void c.erase(p) 删除迭代器 p 所指定的元素，返回一个指向被删除元素之后的迭代器，若 p 指向尾元素，则返回尾后迭代器。若 p 是尾后迭代器，则函数行为未定义。 c.erase(b, e) 删除迭代器 b 和 e 所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若 e 本身就是尾后迭代器，则函数也返回尾后迭代器。 c.clear() 删除 c 中的所有元素。返回 void 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。 pop_front 和 pop_back 不能对一个空容器执行弹出操作。 从容器内部删除一个元素 若 j 是 i之后的元素，那么 erase(i)将返回指向 j 的迭代器。 删除多个元素 elem1 = slist.erase(elem1, elem2); // 调用后， elem1 == elem2 迭代器 elem1 指向要删除的第一个元素， elem2 指向要删除的最后一个元素之后的位置。 9.3.4 特殊的 forward_list 操作 forward_list 是一个单向链表，要相比于获取后继结点来说，获取当前结点的前驱结点更加困难（再从头遍历一遍）。因此与其他容器的操作实现方式不同， forward_list 并未定义insert、emplace 和 erase。 操作名 lst.before_begin() 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。 lst.cbefore_begin() 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。返回一个 const_iterator。 lst.insert_after(p, t) 在迭代器 p 之后的位置插入元素。t 是一个对象。若 p 是尾后迭代器，函数未定义。 lst.insert_after(p, n, t) 在迭代器 p 之后的位置插入 n 个值为 t 的元素。若 p 是尾后迭代器，函数未定义。 lst.insert_after(p, b, e) 在迭代器 p 之后的位置插入范围 b 到 e的元素，b 和 e不能指向lst。 返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回 p。 若 p 是尾后迭代器，函数未定义。 lst.insert_after(p, il) il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。若 p 是尾后迭代器，函数未定义。 emplace_after(p, args) 使用 args 在 p 指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义。 lst.erase_after(p) 删除 p 指向的位置之后的元素。 返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。 如果 p 指向 lst 的尾元素或者是一个尾后迭代器，函数未定义。 lst.erase_after(b, e) 删除从 b 之后直到 e(不删除e)之间的元素。 返回一个指向被删除元素之后的迭代器，若不存在这样的元素，则返回尾后迭代器。 如果 p 指向 lst 的尾元素或者是一个尾后迭代器，函数未定义。 9.3.5 改变容器的大小 操作 c.resize(n) 调整 c 的大小为 n 个元素。若 n<c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化。 c.resize(n, t) 调整 c 的大小为 n 个元素。任何新添加的元素都初始化为值 t。 list<int> ilist(10, 42); // 10 个 int，每个的值都是 42 ilist.resize(15); // 将 5 个值为 0 的元素添加到 ilist 的末尾 ilist.resize(25, -1); // 将 10 个值为 -1 的元素添加到 ilist 的末尾 ilist.resieze(5); // 从 ilist 末尾删除 20个元素 如果保存的是类类型，那么添加新元素时，务必提供默认构造函数。 9.3.6 容器操作可能是迭代器失效 添加元素后： 对 vector 和 string，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之外的任何位置都会导致迭代器、指针和引用失效。 vector<int> vect = {0, 1, 2, 3, 4, 5, 6, 7}; auto& a = vect.back(); auto iter = vect.begin(); cout << *iter << endl; cout << a << endl; a = 100; vect.push_back(5); // 插入后，空间重新分配了 for (auto i : vect) { cout << i << \" \"; } cout << a << endl; // 输出 -572662307 cout << *iter << endl; // 访问失败了 //0 //7 //0 1 2 3 4 5 6 100 5 -572662307 string s = \"thisisastring\"; auto iter = s.begin(); auto first = s.begin(); iter = iter + 3; // iter 指向s[3]，即 's' cout << *iter << endl; // 输出s[3],也就是's' s.insert(first, 'e'); // s = \"ethisisastring\" cout << *iter << endl; // 结果 iter指向了s[3]，但是内容变为了 'i' // s // i string s = \"thisisastring\"; auto& iter = s[3]; cout << iter << endl; // 输出s[3],也就是's' s.insert(s.begin(), 'e'); // s = \"ethisisastring\" cout << iter << endl; // 查看 iter指向是否改变 // 改变下iter内容 iter = 'g'; cout << s << endl; //s //i //ethgsisastring 就是说，引用指针指向的容器下标还是原来的位置，但是内容是被往后移动了。 对于 deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器失效，但指向存在的元素的引用和指针不会失效。 deque<int> deq = { 0, 1, 2, 3, 4 ,5 }; auto iter = deq.begin(); cout << *iter++ << endl; deq.push_front(10); cout << *iter << endl; // 直接报错了 deque<int> deq = { 0, 1, 2, 3, 4 ,5 }; auto& iter = deq[2]; // iter 指向 deq[2] cout << iter << endl; deq.push_front(10); // deq ={10, 0, 1, 2, 3, 4 ,5} cout << iter << endl; // iter 指向 deq[3] 对于 list 和 forward_list， 指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。 删除元素后： 对于 list 和 forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。 对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器，引用和指针也会失效。如果删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果删除首元素，这些也不会受影响。 deque<int> deq = { 0, 1, 2, 3, 4 ,5 }; auto& iter = deq[2]; cout << iter << endl; // iter 指向deq[2]，内容为 2 deq.pop_front(); // deq = {1, 2, 3, 4 ,5} cout << iter << endl; // iter 指向 deq[1]，内容为2 deque<int> deq = { 0, 1, 2, 3, 4 ,5 }; auto& iter = deq[2]; cout << iter << endl; // iter 指向deq[2]，内容为 2 auto it = deq.begin(); it++; // it 指向 deq[1] deq.erase(it); // 干掉 deq[1],deq = {0, 2, 3, 4, 5} cout << iter << endl; // iter指向 deq[1], 即内容为 2 对于 vector 和 string，指向被删元素之前元素的迭代器、引用和指针仍有效。 不要缓冲容器的 end() 函数"
  },
  "Languages/Chapter9/9.4.html": {
    "href": "Languages/Chapter9/9.4.html",
    "title": "9.4 vector 对象是如何增长的？",
    "keywords": "9.4 vector 对象是如何增长的？ 略。（扩展知识）"
  },
  "Languages/Chapter9/9.5.html": {
    "href": "Languages/Chapter9/9.5.html",
    "title": "9.5 额外的 string 操作",
    "keywords": "9.5 额外的 string 操作 9.5.1 构造 string 的其他方法 方法 string s(cp, n) s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符。 string s(s2, pos2) s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 > s2.size()，构造函数的行为未知。 string s(s2, pos2, len2) s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2 > s2.size()，构造函数的行为未知。不管 len2 的值是多少，构造函数至多拷贝 s2.size()-pos2个字符。 const char *cp = \"Hello World!\"; char noNull[] = {'H', 'i'}; // 不是以空字符结束 string s1(cp); // 拷贝cp中的字符直到遇到空字符；s1=\"Hello World!\" string s2(noNull, 2); // s2 == \"Hi\" string s3(noNull); // noNUll 不是以空字符结束，s3未知 string s4(cp+6, 5); // 从 cp[6] 开始拷贝5个字符：s4 == \"World\" string s5(s1, 6, 5); // 从 s1[6]开始拷贝5个字符：s5==\"World\" string s6(s1, 6); // 从 s1[6]开始拷贝剩余的字符，s6==\"World!\" string s7(s1, 6, 20); // 只拷贝到末尾：s7 == \"World!\" string s8(s1, 16); // 数组越界了，因为 s1的长度都没超过16 substr(pos, n) 返回一个 string，包含 s 中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size()-pos，即拷贝从pos开始的所有字符。 string s(\"Hello world\"); string s2 = s.substr(0, 5); // s2 = Hello string s3 = s.substr(6); // s3 = world string s4 = s.substr(6, 11); // s3 = world string s5 = s.substr(12); // outofrange 异常 9.5.2 改变 string 的其他方法 s.insert(s.size(), 5, '!'); // 在 s末尾插入5个感叹号 s.erase(s.size() - 5, 5); // 从 s 删除最后 5个字符 string s=\"okkk\"; const char* cp = \"Stately, plump Buck\"; s.assign(cp, 7); // s == \"Stately\" cout << s << endl; s.insert(s.size(), cp + 1); // s == \"Statelytately, plump Buck\" cout << s << endl; string s = \"some string\"; string s2 = \"some other string\"; s.insert(0, s2); cout << s << endl; // s = \"some other stringsome string\" s.insert(0, s2, 0, s2.size()); cout << s << endl; // s = \"some other stringsome other stringsome string\" append 和 replace append 是在 string 末尾进行插入操作的一种简写形式： string s(\"C++ Primer\"), s2 = s; // s = s2 = \"C++ Primer\" s.insert(s.size(), \"4th Ed.\"); // s == \"C++ Primer 4th Ed.\" s2.append(\" 4th Ed.\"); // s2 == \"C++ Primer 4th Ed.\" replace 操作是调用 erase 和 insert 的一种简写形式： // 将 \"4th\" 替换为 \"5th\" 的等价方法 // 调用erase前 s== \"C++ Primer 4th Ed.\" s.erase(11, 3); // s == \"C++ Primer Ed.\" s.insert(11, \"5th\"); // s== \"C++ Primer 5th Ed.\" // 从位置 11 开始，删除3个字符并插入\"5th\" s.replace(11, 3, \"5th\"); s.replace(11, 3, \"Fifth\"); // s== \"C++ Primer Fifth Ed.\" 9.5.3 string 搜索操作 ​ string 类提供多个搜索函数。函数返回一个string::size_type 值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为 string::npos 的 static 成员。标准库将 npos 定义为一个 const string::size_type 类型，并初始化为值-1.由于 npos 是一个unsigned 类型，此初始值意味着 npos 等于任何 string 最大的可能大小。 find 函数 find 函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回 npos。 string name(\"AnnaBelle\"); auto pos1 = name.find(\"Anna\"); // pos1 = 0 大小写敏感 string name(\"AnnaBelle\"); auto pos1 = name.find(\"anna\"); // pos1 = npos 查找与给定字符串中任何一个字符匹配的位置。 string numbers(\"0123456789\"), name(\"r2d2\"); auto pos = name.find_first_of(numbers); // 返回 1 ，name中第一个数字的下标 搜索第一个不在参数中的字符： string dept(\"03714p3\"); auto pos = dept.find_first_not_of(bumbers); 操作名 s.find(args) 查找 s 中 args 第一次出现的位置 s.rfind(args) 查找 s 中 args 最后一次出现的位置 s.find_first_of(args) 在 s 中查找 args 中任何一个字符第一次出现的位置 s.find_last_of(args) 在 s 中查找 args 中任何一个字符最后一次出现的位置 s.find_first_not_of(args) 在 s 中查找第一个不在 args 中的字符的位置 s.find_last_not_of(args) 在 s 中查找最后一个不在 args 中的字符 上面这个表格的 args 必须是下面的形式之一： 形式 c, pos 从 s 中位置 pos 开始查找字符 c。pos 默认为 0 s2, pos 从 s 中位置 pos 开始查找字符串 s2。pos 默认为 0 cp, pos 从 s 中位置 pos 开始查找指针 cp 指向的以空字符结尾的 C 风格字符串。 cp, pos, n 从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符。pos 和 n 无默认值。 char c[] = \"Bell\"; string name(\"AnnaBelleBelle\"), sub(\"ell\"); auto pos1 = name.find('n'); visit(pos1); auto pos2 = name.rfind('n'); visit(pos2); auto pos3 = name.find('e', 6); visit(pos3); auto pos4 = name.find(sub, 7); visit(pos4); auto pos5 = name.find_last_of(sub); visit(pos5); // 输出 // 1 // 2 // 8 // 10 // 13 在字符串中循环地搜索子字符串出现的所有位置： string::size_type pos = 0; while(pos = name.find_first_of(numbers, pos) != string::npos) { cout << \"find number at index: \" << pos << \" element is\" << name[pos] << endl; pos++; } 9.5.4 compare 函数 参数 s2 比较 s 和 s2 pos1, n1, s2 将 s 中从 pos1 开始的 n1 个字符与 s2 进行比较 pos1, n1, s2, pos2, n2 将 s 中从 pos1 开始的 n1 个字符与 s2 中从 pos2 位置开始的 n2 个字符进行比较 cp 比较 s 与以 cp 指向的以空字符结尾的字符数组 pos1, n1, cp 将 s 中从 pos1 开始的 n1 个字符与 cp 指向的以空字符结尾的字符数组进行比较 pos1, n1, cp, n2 将 s 中从 pos1 开始的 n1 个字符与指针 cp 指向的地址开始的 n2 个字符进行比较 9.5.5 数值转换 新标准引入多个函数，可以实现数值数据与标准库 string 之间的转换： int i = 42; string s = to_string(i); double d = stod(S); 要转换为数值的 string 中第一个非空白符必须是数值中可能出现的字符： string s2 = \"pi = 3.14\"; d = stod(s2.substr(s2.find_first_of(\"+-.0123456789\"))); string 参数中第一个非空白符必须是符号或数字。对那些将字符串转换成浮点数的函数，string 参数可以是以小数点开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整形值的函数，根据基数不同，string 参数可以包含字母字符，对应大于数字9的数（十六进制）。 如果 string 不能转换为一个数值，这些函数抛出一个 invalid_argument 异常。如果转换得到的数值无法用任何类型来表示（太大或太小），则抛出一个 out_of_range 异常。 转换函数 to_string(val) 一组重载函数，返回数值 val 的 string 表示。val 可以是任何算术类型。对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string。与往常一样，小整型会被提升。 stoi(s, p, b) 返回 s 的起始子串（表示整数内容）的数值，返回值类型分别是 int、long、unsigned long、long long、unsigned long long。b 表示转换所用的基数，默认值为10。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，p 默认为 0，即函数不保存下标。 stol(s, p, b) stoul(s, p, b) stoll(s, p, b) stoull(s, p ,b) stof(s, p) 返回 s 的起始子串的数值，返回值类型分别是 float、double 或 long double。参数 p 的作用与整数转换函数中一样 stod(s, p) stold(s, p)"
  },
  "Languages/Chapter9/9.6.html": {
    "href": "Languages/Chapter9/9.6.html",
    "title": "9.6 容器适配器",
    "keywords": "9.6 容器适配器 标准库定义了三个顺序容器适配器： stack queue priority_queue 上面这三种适配器是基于其他顺序容器的基础上实现的。stack和queue 默认基于 deque 实现的，priority_queue 默认基于 vector 实现。 适配器通用操作和类型 size_type 一种类型，足以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器类型 A a; 创建一个名为 a 的空适配器 A a(c); 创建一个名为 a 的适配器，带有容器 c 的一个拷贝 关系运算符 每个适配器都支持所有关系运算符：==、!=、<、<=、> 和 >=，这些运算符返回底层容器的比较结果 a.empty() 若 a 包含任何元素，返回 false；否则返回 true a.size() 返回 a 中的元素数目 swap(a, b) 交换 a 和 b 的内容，a 和 b 必须具有相同类型，包括底层容器类型也必须相同 a.swap(b) 交换 a 和 b 的内容，a 和 b 必须具有相同类型，包括底层容器类型也必须相同 如何定义适配器？ stack<int> stk(deq); // 从 deq拷贝元素到 stk // 底层容器是 vector stack<string, vector<string>> str_stk; // 底层容器是 vector，用 vector svec 初始化str_stk2 stack<string, vector<string>> str_stk2(svec); 适配器不能构造在 array 之上。也不能用 forward_list 来构造适配器，因为所以适配器都要求容器具有添加、删除、访问尾部元素的能力。 stack 只要求push_back、pop_back和back操作，可以使用除 array 和 forward_list 之外的任何容器类型来构造。 queue 要求 back、push_back、front 和 push_front，因此它可以构造在 list 或 deque 之上，但不能基于 vector。 priority_queue 除了 front、push_back 和 pop_back 操作之外，还要求具有随机访问的能力，可以构造在 vector 或 deque 之上，但不能基于 list。"
  },
  "OperatingSystem/Chapter1/1.1.html": {
    "href": "OperatingSystem/Chapter1/1.1.html",
    "title": "1.1 操作系统的基本概念",
    "keywords": "1.1 操作系统的基本概念 1.1.1 操作系统的概念 ​ 计算机系统大致可分为4个部分：硬件、操作系统、应用程序和用户。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。 ​ 硬件如中央处理器、内存、输入/输出设备等，提供基本的计算资源。应用程序如字处理器程序、电子制表软件、编译器、网络浏览器等，规定按何种方式使用这些资源来解决用户的计算问题，操作系统控制和协调各用户的应用程序对硬件的分配与使用。 ​ 综上所述，操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。 1.1.2 操作系统的特征 ​ 操作系统的基本特征包括并发、共享、虚拟和异步。 并发 ​ 并发指两个或多个事件在同一时间间隔内发生的。对计算机来说，并发就是有多个程序在某一段时间里发生了。 ​ 在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，所以看起来是多个程序在“同时运行”。而在每个时刻，单处理机环境下实际仅有一道程序执行，微观上这些程序是交替执行的。操作系统的并发性是通过分时得以实现的。 并行 ​ 并行性指系统具有同时进行运算和操作的特性，同一时刻能完成两种或两种以上的工作。这个特性离不开硬件的支持。 共享 ​ 这里讲的共享就是资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享又分 互斥共享 和 同时访问 。 互斥共享 如打印机，磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不至于混淆，规定在一段时间内只允许一个进程访问该资源。 进程A需要某个资源时，先向系统申请资源，如果这时资源已经被占用，并且进程A对该资源的占用优先级没有高过当前占用的进程，那么就得排队等待该资源。如果资源没被占用，那么进程A就对系统要求锁住该资源，让给A使用，此时进程B向系统申请该资源，并且优先级没有进程A高，那么系统拒接该进程B的申请。像这样的资源称为临界资源或独占资源。 同时访问方式 系统中的一些资源，允许在一段时间内由多个进程“同时”访问。这里说的同时，指宏观上同时，进程之间可能以交替地对该资源进行访问即“分时共享”。像磁盘；一些共享文件，多个进程可读共同一个文件。可以想象，电脑只有一个播音器，但是如果同时开着几个音频软件，在人耳处听到的是，这几个音频软件同时被播放器播放声音了。 虚拟 ​ 虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体是实的，即实际存在的；而逻辑对应物是虚的，是用户感觉上的事物。操作系统利用多种虚拟技术实现虚拟处理器、虚拟内存和虚拟外设。 ​ 虚拟处理器技术是通过多道程序 设计技术，采用让多道程序并发执行的方法，分时地使用一个处理器。使用者认为这个系统可以为多个用户服务，每个终端用户感觉有一个中央处理器专门为其服务。但是物理上就只有一个 cpu。 ​ 虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，从逻辑上扩充存储器容量。这是用户感觉到的内存脑容量是虚的。 ​ 虚拟设备技术将一台物理 IO 设备虚拟为多台逻辑上的 IO 设备，并允许每个用户占用一台逻辑上的 IO 设备，使原来仅允许一段时间内由一个用户访问的设备变为一段时间内允许许多用户同时访问的设备。 异步 ​ 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。 ​ 异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误。然而，只要运行环境相同，操作系统就必须保证多次运行进程后都能获得相同的结果。 为了给多道程序提供优良的运行环境，操作系统有以下4大功能： 功能 处理机管理 多道程序环境下，处理机的分配和运行以进程为基本单位，因而对处理机的管理归结为对进程的管理。 因为进程并发运行，所以操作系统要管理进程何时创建、何时撤销、如何管理、避免进程间冲突、合理共享资源等。 控制进程、进程同步、进程通信、死锁如何处理、处理机轮换调度。 存储器管理 内存分配与回收、地址映射、内存保存与共享和内存扩充。 文件管理 文件存储空间管理、目录管理、文件读写管理和保护。 设备管理 IO 请求，方便用户使用过各种设备，并提高设备利用率。缓冲管理、设备分配、设备处理、虚拟设备。 用户与计算机硬件系统之间的中间人——操作系统 为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口： 命令接口，用户利用命令接口组织和控制作业的执行 联机命令接口 交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权返回控制台或终端，此时用户又输入下一条命令。迭代下去。 脱机命令接口 批处理命令接口，适用于批处理系统。它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给操作系统。 程序接口，编程人员可以使用它们来请求操作系统服务。 程序接口由一组系统调用（广义指令）组成。用户通过在程序中使用这些系统调用来申请操作系统为其提供服务，如使用各种外设、申请分配和回收内存等。如GUI，windows桌面那些程序的软件打开方式。"
  },
  "OperatingSystem/Chapter1/1.2.html": {
    "href": "OperatingSystem/Chapter1/1.2.html",
    "title": "1.2 操作系统发展和分类",
    "keywords": "1.2 操作系统发展和分类 背景：用户在计算机上算题的所有工作都是人工干预，程序的装入、运行、结果输出等。用户独占全机，cpu等资源利用率低。 单道批处理系统 系统对作业的处理是成批输入的，但内存中始终保持一道作业。单道批处理系统主要解决的是人机矛盾、cpu 和 IO设备速率不匹配的矛盾。 一些特性 自动性。磁带上的一批作业能自动地逐个运行，无序人工干预。 顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下形同。 单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常时，才换入其后继程序进入内存运行。 缺点：当程序运行的某一时段不需要cpu和IO等其他设备时，这些资源就没得到使用，极大的“浪费”了。 多道批处理系统 ​ 多道批处理系统允许多个程序同时进入内存并允许它们在 cpu 中交替地运行，这些程序共享系统中的各种硬件软件资源。比如当作业A在内存中正在使用 cpu，下一刻，它不用了，它要用 IO 设备输出结构，在作业A输出结果这段时间，作业B可以立即使用cpu。 多道操作系统的特点是多道、宏观上并行（并发）、微观上串行。 优点：资源利用率高，各种资源得到充分利用；系统吞吐量大。 缺点：用户响应时间长；不提供人机交互能力，用户不能了解自己的程序运行情况。 分时系统 ​ 把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业分配给它的时间片内不能完全其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。因为计算速度很快，作业运行轮转也很快，用户感觉自己独占一台计算机。 ​ 分时操作系统值多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。比起多道批处理系统，分时系统解决了人机交互的情况。 有以下特征： 同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端向连接，终端用户可以同时使用计算机。 交互性。用户能方便地与系统进行人机对话，即用户通过终端采用人机对话方式直接控制程序运行。 独立性。系统多个用户可以独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。 及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。 虽然分时系统已经很好了，比如我们现代大多数人用的windows系统，就是一个分时系统，但是有一些作业运行要求很高，比如军方的一些导弹系统，要求时间片很短。这是分时系统就做不到了。 实时操作系统 为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，科学家们就发明了实时操作系统。这里的时间限制可以分为两种情况： 某个动作必须绝对地在规定的时刻（规定的时间范围内）发生，称为 硬实时系统 ，如飞行自动控制系统，自动跟踪导弹系统等。 若能够接受偶尔违反时间规定且不会引起任何永久性的伤害，则称为软实时系统，如飞机订票系统，银行管理系统。"
  },
  "OperatingSystem/Chapter1/1.3.html": {
    "href": "OperatingSystem/Chapter1/1.3.html",
    "title": "1.3 操作系统的运行环境",
    "keywords": "1.3 操作系统的运行环境 cpu 除了执行用户自编的程序（ 应用程序 ），而且还要执行操作系统 内核程序 。 内核程序是应用程序的管理者，内核程序要执行一些 特权指令 。处于安全考虑，应用程序不允许执行特权指令，也就是说，只有操作系统可以执行特权指令，即使应用程序想执行某个功能的特权指令，也要想操作系统申请调用才可以。 常见的一些特权指令有：I/O 指令、内存清零指令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。 cpu 的状态划分为 用户态（目态） 和 核心态（管态） 。处于用户态时，cpu 执行非特权指令；当处于核心态时，cpu 执行特权指令。用户自编程序运行在用户态，操作系统内核程序运行在核心态。 cpu 如何区分这两个态？ cpu 有一个寄存器—— 程序状态寄存器（PSW） ，其中有一个二进制位，1表示内核态，0表示用户态。 如何切换状态？ 内核态---> 用户态：执行一条特权指令——修改PSW的标志位为0，操作系统主动让出 cpu 使用权。 用户态---> 内核态：由 “中断” 引发，硬件自动完成变态过程，触发中断信号意味着操作系统强行夺取 cpu 使用权。 操作系统内核四大方面的内容 时钟管理 时钟是最关键的设备。其重要功能——计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。 通过时钟中断的管理，实现进程的切换。 分时操作系统中采用的时间片轮转调度。 实时系统中按截止时间控制运行。 批处理系统中衡量一个作业的运行程度。 都离不开时钟中断。 中断机制 中断技术的发明初衷是为了提高多道程序运行环境中 cpu 的利用率，而且主要是针对外部设备的。随着发展，形成多种类型的中断。比如，键盘鼠标信号输入、进程管理和调度、系统功能调用、设备驱动、文件访问，均依赖中断机制。 中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。 原语 操作系统底层有一些被调用的公用小程序。特点如下： 处于操作系统最底层，是最接近硬件的部分。 这些程序运行具有原子性，其操作只能一气呵成。 这些程序的运行时间都较短，而且调用频繁。 也叫 原语 ，定义原语的直接方法是 关闭中断 ，让其所有动作不可分割地完成后再打开中断。 常见的原语：设备驱动、cpu 切换、进程通信等功能的部分操作。 系统控制的数据结构及处理 系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表。操作系统对这些管理需要一些基本操作： 进程管理。进程状态管理、进程调度和分派、创建和撤销进程控制块等。 存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等 设备管理。缓冲区管理、设备分配和回收。 中断和异常 中断称外中断。比如外设请求、时钟中断，时间片轮转。它们的特点是与当前指令无关。 异常，也称内中断。非法操作码、地址越界、算术溢出、虚存系统缺页、陷入指令。对异常的处理一般要依赖当前程序的运行现场，而且异常不能被屏蔽，一旦出现就要立即处理。 中断处理过程 大多数计算机的中断过程如下： ① 关中断。cpu 响应中断后，首先要保护现场，在现场信息没有保护好之前，不会再响应其他中断。 ② 保存断点。为保证中断服务程序执行完毕后能正确返回原来的程序，必须将原来的程序的断点（程序计数器PC）保存起来。 ③ 中断服务程序寻址。取出中断服务程序的入口地址送入程序计数器PC。 ④ 保存现场和屏蔽字。进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器PSWR 和某些通用寄存器的内容。 ⑤ 开中断。允许更高级中断请求。 ⑥执行中断服务程序。 ⑦ 关中断。保证在恢复现场和屏蔽字时不被中断。 ⑧ 恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。 ⑨ 开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到源程序的断点处，以便继续执行源程序。 陷入指令 有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令—— 陷入指令 ，该指令会引发一个内部中断信号。应用程序主动地将 cpu 控制权还给操作系统内核。系统调用就是通过陷入指令完成的。 陷入指令，又称访管指令，trap 指令。"
  },
  "OperatingSystem/Chapter2/2.1.html": {
    "href": "OperatingSystem/Chapter2/2.1.html",
    "title": "2.1 进程",
    "keywords": "2.1 进程 2.1.1 进程介绍 程序：是 静态的 ，就是个存放在磁盘里的可执行文件，是一系列的指令集合。 进程：是 动态的 ，是程序的一次执行过程，一个程序可以在一台机子上同时运行 n 个，好比 qq，不运行的话，qq所在的文件目录那些文件代码是程序，点击运行，装载到内存和cpu里就变成了进程，而且可以同时运行多个 qq。 这就体现了 并发性 和 共享性 。 那操作系统如何区分同一个程序装入内存的多个进程？ 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的编号——PID（Process ID，进程ID）。 操作系统还记录给进程分配了什么资源（内存、IO设备、文件）。同时还记录进程的运行情况（cpu 占用时间、对磁盘读写速率、网络流量使用情况）。 上面这些记录的信息，都被保存在一个数据结构 PCB（Process Control Block）中，也称为 进程控制块 。 进程映像由三个部分组成： 程序段（程序使用） 相关数据段（程序使用） PCB（操作系统使用） 进程映像是静态的，进程是动态的。 PCB 是进程存在的唯一标志！ 可以这么理解进程： 进程是程序的一次运行。进程是一个程序及其数据在处理机上顺序执行时所发生的活动。进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 进程特性 动态性 。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡。 并发性 。多个进程实体同时存在内存中，能在一段时间内同时运行。 独立性 。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡是未建立PCB的程序，都不能作为一个独立的单位参与运行。 异步性 。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此操作系统中必须配置相应的同步机制。 结构性 。每个进程都配置一个 PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和PCB三部分组成的。 2.1.2 进程的状态与转换 进程在生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断的发生变化。 运行态 。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。 就绪态 。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常它们会排队，形成一个队列，称为就绪队列。 阻塞态 。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 创建态 。进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤：首先申请空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；足厚把该进程转入就绪态。 结束态 。进程正在从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须将该进程置为结束态，然后进一步处理资源释放和回收等工作。 这几个状态之间会进行相互转换： 状态转换 就绪态 ---> 运行态 处于就绪态的进程被调度后，获得处理机资源（时间片轮转到了） 运行态----> 就绪态 处于运行态的进程时间片用完了，操作系统夺回处理机；有更高优先级的进程需要处理机。 运行态----> 阻塞态 进程请求某一资源的使用和分配或等待某一事件的发生；进程以系统调用的形式请求操作系统提供服务。 阻塞态----> 就绪态 进程等待的事件（资源）到来，如IO操作结束或中断结束时，中断处理程序必须把相应进程的状态有阻塞态转换为就绪态。 从运行态变成阻塞态是主动的行为，从阻塞态变成就绪态是被动的行为。 进程的状态是保存在 PCB的一个叫做 state 变量中。 2.1.3 进程控制 进程控制包括，创建新进程（ 增 ）、撤销已有进程（ 删 ）、实现进程状态转换（ 改 ）等功能。 在操作系统中，一般把进程控制用的程序段称为 原语 ，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。 进程的创建 ​ 允许一个进程创建另一个进程。可以理解为父进程和子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应该将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。（归结起来一句话： 子承父业，子亡物归父，父亡子必亡 ） ​ 创建一个新进程的过程如下（创建原语）： ① 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB。若 PCB申请失败（PCB个数有限），则创建失败。 ② 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（在PCB中体现）。若资源不足（内存不足），则不是创建失败，而是处于阻塞态，等待内存资源。 ③ 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，设置进程优先级。 ④ 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。 进程的终止 进程的终止原因有： 正常结束，表示进程的任务已完成并准备退出运行。 异常结束。表示进程在运行时，发生了异常事件，使程序无法运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、IO故障。 外界干预。进程应用外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。 操作系统终止进程的过程如下（撤销原语）： ① 根据被终止进程的标识符，检索 PCB，从中读出该进程的状态。 ② 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程 ③ 若该进程还有子孙进程，则应将其所有子孙进程终止。 ④ 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。 ⑤ 将该 PCB 从所在队列中删除。 进程的阻塞和唤醒 进程等待的资源还未到达，由系统自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是进程自身的一种主动的行为，只有处于运行态的进程，才可能将其转为阻塞态。 阻塞原语 执行过程： ① 找到将要被阻塞进程的标识号对应的 PCB。 ② 若该进程为运行态，则保护现场，将其状态转为阻塞态，停止运行。 ③ 把该 PCB 插入相应事件（如等待IO设备）的等待队列，将处理机资源调度给其他就绪的进程。 当被阻塞的进程所需的资源有可分配的，由有关进程（如释放资源的进程）调用 唤醒原语 ，将等待该资源的阻塞进程唤醒。唤醒原语执行过程: ① 在该资源的等待队列中找到相应进程的 PCB。 ② 将其从等待队列中移出，置其状态位就绪态。 ③ 把该 PCB 插入就绪队列，接下来就是等待调度程序调度。 进程切换 进程切换是在内核的支持下实现的，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。 其过程为： ① 保存处理机上下文，包括程序计数器和其他寄存器。 ② 更新 PCB。 ③ 把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞队列。 ④选择另一个进程执行，更新其 PCB。 ⑤更新内存管理的数据结构。 ⑥ 恢复处理机上下文。 与处理机模式切换不同，处理机模式切换时，处理机逻辑上可能还在同一个进程中运行。例子：进程因中断或异常进入核心态运行，运行完毕后回到用户态刚被中断的进程运行，则操作系统只需恢复进程进入内核时所保存的 cpu 现场，而无须改变当前进程的环境信息。如果是进程切换，当前运行进程改变了，当前进程的环境信息也会改变。 2.1.4 进程的组织 进程是一个独立的单位，由三部分组成。 进程控制块 进程创建时，操作系统为它创建一个 PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程的存在的唯一标志。 ​ 进程执行时，系统通过其 PCB 了解进程的现行状态，以便对其进行控制和管理。进程结束时，系统回收 PCB，该进程随之消亡。操作系统通过控制 PCB 表来管理和控制进程 ​ 当操作系统预调度某个进程运行时，要从该进程的 PCB 中查找其现行的状态及优先级；在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存开始地址，找到程序和数据，进程在运行过程中，当需要与之合作的进程实现同步、通信或访问文件时，也需要访问 PCB；当进程由于某种原因而暂停运行时，又需要将其断点的处理机环境保存在 PCB 中。 PCB 包含的内容 进程描述信息 进程控制和管理信息 资源分配清单 处理机相关信息 进程标识符 进程当前状态 代码段指针 通用寄存器 用户标识符 进程优先级 数据段指针 地址寄存器 代码运行入口地址 堆栈段指针 控制寄存器 程序的外存地址 文件描述符 标准寄存器 进入内存的时间 键盘 状态字 处理机占用时间 鼠标 信号量使用 程序段 能被进程调度程序调度到 cpu 执行的代码段。程序可被多个进程共享。 数据段 一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。 2.1.5 进程的通信 PV 操作是低级通信方式，高级通信方式是以较高的效率传输大量数据的通行方式。 共享存储 正常来说，每个进程都有自己的地址空间段。一个进程不允许访问另一个进程的地址空间。 那怎么实现两个进程之间的通信呢？ 共享存储 可以实现两个进程间的通信！两个进程对操作系统进行系统调用，申请一个 共享空间 ，进程 A 和进程 B 通过同步互斥工具（PV），从而对共享空间进行读/写操作实现进程间的信息交换。进程对共享空间的访问必须是互斥的。可以多个进程进行共享空间的读写。 这里的箭头表示访问的意思。 分两种：基于数据结构的共享；基于存储区的共享。 消息传递 在消息传递系统中，进程间的数据交换时以格式化的 消息 为单位的。若通信的进程间不存在可直接访问的共享空间，则必须利用操作系统的消息传递方法实现进程通信。进程通过系统提供的发送信息和接受信息两个原语进行数据交换。 ① 直接通信方式。发送进程直接把消息发送个接受进程，并将它挂在接受进程的消息缓冲队列上，接受进程从消息缓冲队列中取得消息。 ② 间接通信方式。发送进程把消息发送到某个中间实体，接受进程从中间实体取得消息，这种中间实体一般称为 信箱 ，这种通信方式又称 信箱通信方式 。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。 管道通信 管道通信是消息传递的一种特殊方式。管道，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名 pipe 文件。向管道提供输入的发送进程，以字符流形式将大量的数据送入管道；而接受管道输出的接受进程则从管道中接受数据。为了系统双方的通信，管道机制必须提供三方面的协调能力：互斥、同步、确定对方存在。 linux 管道： ① 限制管道的大小。管道是一个固定大小的缓冲区。在 linux 中，该缓冲区的大小为 4KB，这使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的 write 调用将默认地被阻塞，等待数据被读取，以便腾出足够的空间供 write 调用写。 ② 读进程也可能工作得比写进程快。当所有当前进程数据已经被读取了，管道就变空。当这种情况发生时，一个随后的 read 也被默认地阻塞，等待某些数据被写入，这解决了 read 调用返回文件结束符的问题。 管道读数据是一次性操作，数据一旦被读取，它就能从管道中被抛弃，释放空间以便写入更多的数据。管道只能采用半双工通信（某一时刻只能单向传输），如果实现两个进程间互动通信，需要两个管道。 管道还有一个特点，就是写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写入数据。"
  },
  "OperatingSystem/Chapter2/2.2.html": {
    "href": "OperatingSystem/Chapter2/2.2.html",
    "title": "2.2 线程",
    "keywords": "2.2 线程 2.2.1 基本概念 ​ 引入进程的目的是 更好地使用多道程序并发执行 ，提高资源利用率和系统吞吐量；而引入线程的目的是 减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能 。（可以试想一下，如果没有线程，我们还能用微信一边接通视频通话，一边刷着朋友圈或者和其他好友打字聊天吗？） ​ 线程是轻量级进程，它是一个基本的 cpu 执行单元，也是程序执行流的最小单元。 ​ 线程由线程ID、程序计数器、寄存器集合和堆栈组成。 ​ 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，值拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以 并发 执行。 ​ 进程只作为除 cpu 外的系统资源的分配单元，而线程作为处理机的分配单元。由于一个进程内部有多个线程，若线程切换发生在同一进程内部，则只需很少的时空开销（因为这些线程共用进程的所有资源）。 2.2.2 线程与进程的比较 ① 调度 。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一个进程中，线程切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换（为什么，因为另一个进程中的线程需要的资源和原先的线程不一样啊） ② 拥有资源 。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，但线程可以访问其隶属进程的系统资源。如果线程由自己的资源，那么同一个进程的线程切换时，也要切换大量的时空开销，不值得。 ③ 并发性 。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。 ④ 系统开销 。由于创建或撤销进程时，系统都要为之分配或回收资源。因此操作系统付出的开销远大于创建或撤销线程时的开销。进程切换时，涉及当前执行进程 cpu 环境的保存及新调度到 cpu 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销相对小很多。同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步和通信非常容易实现，甚至无需操作系统的干预。 ⑤ 地址空间和其他资源 。进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。 ⑥ 通信方面 。进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段。 2.2.3 线程的属性 多线程操作系统把线程作为独立运行的基本单位，此时的进程已不再是一个基本的可执行实体，但它仍具有与执行相关的状态。所谓进程处于 执行 状态，实际上是指该进程中某线程正在执行。 线程的属性： ① 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。 ② 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的进程。 ③ 同一个进程中的各个线程共享该进程所拥有的资源。 ④ 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单 cpu 的计算机系统中，各个线程是交替地占用 cpu；在多个 cpu 的计算机系统中，各线程可同时占用不同的 cpu，若各个 cpu 同时为一个进程内的各线程服务，则可缩短进程的处理时间。 ⑤ 一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。 2.2.4 线程的实现方式 线程的实现分为： 用户级线程（User-Level Thread, ULT） 内核级线程（Kernal_Level Thread, KLT) 内核级线程即内核支持的线程。 用户级线程 ​ 早期的操作系统只支持进程，不支持线程。当时的线程是由线程库实现的。 早期的操作系统事实上并没有在支持线程，但是聪明的程序员大师们想到了用线程库来实现，可能看代码更清晰： int main() { int flag = 0; // 让 A,B,C 不断轮流交替执行，但是这是如果某个线程卡住了，其他线程就只能一直等。 while(condition) { if(flag == 0) call(ThreadA); if(flag == 1) call(ThreadB); if(flag == 2) call(ThreadC); flag = (flag + 1) % 3; } } 操作系统压根不知道用户级线程的存在，只知道轮循调用进程罢了。这时候线程管理由用户管理，线程切换管理也由用户态下线程库管理。但是线程切换不需要从用户态切换到内核态，开销就小些。 内核级线程 内核级线程的线程管理由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然要在核心态矮才能完成。 操作系统会为每个内核级线程建立相应的 TCB，通过 TCB 对线程进行管理。“内核级线程” 就是从操作系统内核视觉看到线程的。 相比于用户级线程，同一个进程中的线程被阻塞了，另外的几个并不会因此而阻塞（除非为了资源被阻塞）。同时线程切换会导致用户态切换到内核态，时空开销相对来说比较大。 多线程模型 多对一模型 ：上面的用户级线程，就是多对一模型，将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。 优点：线程管理在用户空间进行，时空开销小。 缺点：一个线程阻塞，整个进程都会被阻塞，多个线程不能并行地运行在多个处理机上。 一对一模型 ： 将每个用户级线程映射到一个内核级线程上。 优点：当一个线程被阻塞后，允许另一个线程继续执行，并发能力强。 缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。 多对多模型 ：将 n 个用户级线程映射到 m 个 内核级线程上。n > m 特点：是前两个模型的折中，客服了并发度不高的缺点，也克服了进程用户占用太多内核级线程而开销大的缺点。 如果线程 A 阻塞，线程 B 也可能导致阻塞，这时如果处理好代码，让 内核线程2 去执行线程 B 直到线程 A 恢复顺畅执行后，再交给 内核线程1 执行。"
  }
}