<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>2.3 &#22797;&#21512;&#31867;&#22411; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="2.3 &#22797;&#21512;&#31867;&#22411; ">
    <meta name="generator" content="docfx 2.59.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="23-复合类型">2.3 复合类型</h1>

<p>​	符合类型指基于其他类型定义的类型。这里仅介绍<font color='blue'>引用</font>和<font color='blue'>指针</font>。</p>
<h2 id="231-引用">2.3.1 引用</h2>
<p>​	引用为对象起了另一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p>
<pre><code class="lang-c++">int ival = 1024;
int &amp;refVal = ival;		// refVal指向ival（相当于给ival起了另一个名字）
int &amp;refVal2;			// 报错，引用必须初始化
</code></pre>
<p>​	一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。</p>
<h3 id="引用即别名">引用即别名</h3>
<p>​	引用不是一个对象，它只是一个已存在的对象所起的另一个名字，对其操作是在与之绑定的对象基础上进行操作。</p>
<pre><code>int ival = 1024;
int &amp;refVal = ival;		// refVal指向ival（相当于给ival起了另一个名字）
refVal = 2048
cout &lt;&lt; ival &lt;&lt; endl;	// 打印 2048
</code></pre>
<h3 id="引用的定义">引用的定义</h3>
<p>​	允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。</p>
<pre><code class="lang-c++">int i = 1024, i2 = 2048;
int &amp;r = i, r2 = i2;
int i3 = 1024, &amp;ri = i3;
int &amp;r3 = i3, &amp;r4 = i2;
</code></pre>
<p>​	引用只能绑定在对象上，不能绑定在字面值或某个表达式的计算结果。</p>
<pre><code>int &amp;refVal = 1024; // 报错
double dVal = 3.14; 
int refVal2 = dVal; // 报错，引用类型的初始值类型不匹配
</code></pre>
<h3 id="练习">练习</h3>
<p><strong>练习2.15</strong> 下面的哪个定义是不合法的？</p>
<p>(a) int ival= 1.01;	(b) int &amp;rvall = 1.01;</p>
<p>(c) int &amp;rval2 = ival;  	(d) int &amp;rval3;</p>
<p>​	答：(a)和(c)合法，(b)绑定只能绑定到对象上，不能绑定到具体的字面值上，(d)绑定必须初始化。</p>
<p><strong>练习2.16</strong> 考查下面所有的赋值然后回答，哪些赋值是不合法的，为什么?哪些赋值是合法的，他们执行了什么操作？</p>
<p>int i = 0,&amp;r1 = i; double d= 0, &amp;r2 = d;</p>
<p>(a) r2 = 3.14159;	(b) r2 = r1;</p>
<p>(c) i = r2;	(d) r1 = d;</p>
<p>​	答：(a) 合法，将3.14159赋值给了与r2绑定的对象。(b) 合法，将 r1绑定对象的值，赋值给 r2绑定的对象，因为r2绑定的对象是double类型，r1 是int类型，所以是可以运行的。(c) 不合法，会报警提示可能存在数据精度丢失。(d) 不合法。会报警提示可能存在数据精度丢失。</p>
<p><strong>练习2.17</strong> 执行下面的代码段将会输出什么？</p>
<pre><code>int i, &amp;ri = i;
i = 5; ri = 10;
cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ri &lt;&lt;endl;
</code></pre>
<p>​	输出10 10，这里ri与i的对象绑定在一起，对ri的任何操作都是对i的操作。</p>
<h2 id="232-指针">2.3.2 指针</h2>
<p>​	指针是指向另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。指针是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以先后指向几个不同的对象。指针无须在定义时赋初始值。</p>
<pre><code>int *ip1, *ip2; // 两个指向int类型的指针
int dp, *ip3;   // dp是int类型对象，ip3是指向int类型的指针。
</code></pre>
<h3 id="获取对象的地址">获取对象的地址</h3>
<p>​	指针存放某个对象的地址，而给指针赋值地址时需要<font color='blue'>取地址符&amp;</font>。</p>
<pre><code>int ival = 42;
int *p = &amp;ival;	// p指针指向ival对象
</code></pre>
<p>​	引用不是对象，无实际地址，所以不能将指针指向引用。</p>
<p>​	一般情况下，指针的类型要和它所指向的对象类型严格匹配。</p>
<pre><code>double ival;
double* pd = &amp;ival;
int* p1 = pd;  			// 报错，类型不匹配
int* p = &amp;ival;			// 报错，类型不匹配
</code></pre>
<h3 id="指针值"><strong>指针值</strong></h3>
<p>​	指针的值是地址。指针要么指向一个对象，要么指向紧邻对象所占空间的下一个位置，要么是个空指针（因此对指针操作一般要进行判空），或者是个无效指针，随意访问可能导致程序崩溃。</p>
<h3 id="利用指针访问对象"><strong>利用指针访问对象</strong></h3>
<p>​	要知道指针指向一个对象，直接访问指针名，其实访问的是对象的地址，而一般数据是对象的内容，因此需要一个<font color='blue'>解引用符*</font>来访问对象内容。</p>
<pre><code class="lang-c++">int ival = 42;
int *p = &amp;ival;   // p 指向ival
cout &lt;&lt; p;        // 输出p的地址 
cout &lt;&lt; *p;       // 输出 42
</code></pre>
<p>​	给指针指向的对象赋值，也需要<font color='blue'>解引用符*</font>。</p>
<pre><code class="lang-c++">*p=1024;          // 给p指向的对象赋值
cout &lt;&lt; *p;       // 输出 1024
cout &lt;&lt; ival;     // 输出 1024
</code></pre>
<p>​	解引用符只适用于指针指向了明确的对象。</p>
<pre><code class="lang-c++">int ival = 42;
int* p = NULL;   // p 指向ival
cout &lt;&lt; *p &lt;&lt; endl; // 运行时报错
</code></pre>
<h3 id="空指针"><strong>空指针</strong></h3>
<p>​	空指针不指向任何对象，在试图使用一个指针之前代码可以先判空。三种生成空指针的方法。</p>
<pre><code>int *p1 = nullptr;	// c++11标准推荐使用这种方式赋值空指针
int *p2 = 0;
int *p3 = NULL;		// NULL实际就是0
</code></pre>
<h3 id="赋值和指针">赋值和指针</h3>
<p>​	引用一旦绑定到某个对象之后，再解绑并对另一个对象绑定是不可能的。而指针就不同，指针可以再指向另一个对象。给指针赋值(地址)，就是令指针重新存放了一个地址，从而指向一个新的对象。</p>
<p>​	任何非0地址的指针在条件判断是都是true。</p>
<h3 id="void-指针">void* 指针</h3>
<p>​	<code>void*</code>是一种特殊的指针类型，可用于存放任意对象的地址。一个<code>void*</code>指针存放一个地址，存放什么类型地址我们不得而知。</p>
<pre><code class="lang-c++"> double obj = 3.14159, * pd = &amp;obj;
 void* pv = &amp;obj;
 pv = pd;

cout &lt;&lt; *pv &lt;&lt; endl; 	// 报错，void* 类型不允许访问，必须提前知道void*指针指向什么类型的地址，再用该类型的指针指向void*指向的指针，方可访问对象
return 0;
</code></pre>
<h3 id="练习-1"><strong>练习</strong></h3>
<p><strong>练习2.18</strong> 编写代码分别更改指针的值以及指针所指向对象的值。</p>
<pre><code class="lang-c++">double obj = 3.14159, * pd = &amp;obj; // pd指向obj对象
double x = 1919;
pd = &amp;x;    // 更改pd的值，令其指向x对象
*pd = 1024; // 更改pd指向对象的值，即x值为1024
</code></pre>
<p><strong>练习2.19</strong> 说明指针和引用的主要区别。</p>
<p>答，引用不是一个对象，没有实际地址，引用一旦绑定到某个对象，要再绑定到另一个对象是不可能的，因此引用必须初始化。指针是一个对象，有实际地址，指针可以更改值，从而指向新的对象，也不用初始化。</p>
<p><strong>练习2.20</strong> 请叙述下面这段代码的作用。</p>
<pre><code class="lang-c++">int i =42;
int *p1 = &amp;i;
*p1 = *p1 * *p1;
</code></pre>
<p>答：定义一个int类型变量i，指针p1指向i对象，将p1指向对象的值相乘然后赋值给pi指向的对象，因此i对象的值最后变为42*42。</p>
<p><strong>练习2.21</strong> 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？</p>
<p>int i = 0;</p>
<p>(a) double* dp = &amp;i;	(b) int *pi = i;	(c) int *p = &amp;i;</p>
<p>答：(a)非法，非空指针要和指向的对象严格类型匹配。(b) 指针初始化时是赋值地址，而非具体对象的值。</p>
<p><strong>练习2.22</strong> 假设p是一个int型指针，请说明下述代码的含义。</p>
<pre><code class="lang-c++">if(p) // p如果是非空指针，则执行if后的代码块
if(*p) // 指针p指向的对象如果值不为0，这执行if后的代码块
</code></pre>
<p><strong>练习2.23</strong> 给定指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断思路；如果不能，也请说明原因。</p>
<p>答：可以通过判空来确定是否指向了一个合法的对象。</p>
<p><strong>练习2.24</strong> 在下面这段代码中为什么p合法而lp非法？</p>
<p>int i = 42; 	void *p = &amp;i;	long *lp = &amp;i;</p>
<p>答：void*指针是特殊的指针，可以指向任意对象。而long指针只能指向long类型的对象。</p>
<h2 id="233-理解复合类型的声明">2.3.3 理解复合类型的声明</h2>
<pre><code class="lang-c++">int i = 1024, *p = i, &amp;r = i;
</code></pre>
<p>​	只需在某行代码前面写一个关键字 int ，然后声明变量的名字用逗号分隔，可以定义不同类型的变量。</p>
<h3 id="指向指针的指针">指向指针的指针</h3>
<p>​	不像引用，指针是内存中的对象，有自己的地址，因此可以将指针的地址存放到另一个指针中。通过*符号的个数可以区分指针的级别。<code>**</code> 表示指向指针的指针，<code>***</code>表示指向指针的指针的指针。</p>
<pre><code class="lang-c++">int ival = 1024;
int *pi = &amp;ival; // 指向ival的指针
int **ppi = &amp;pi; // 指向pi指针的指针

cout &lt;&lt; *pi &lt;&lt; endl;   // 输出 1024
cout &lt;&lt; *ppi &lt;&lt; endl;  // 输出 pi的地址
cout &lt;&lt; **ppi &lt;&lt; endl; // 输出 1024
</code></pre>
<h3 id="指向指针的引用">指向指针的引用</h3>
<p>​	引用本身不是一个对象，因此不能定义一个指向引用的对象。但是指针是一个对象，可以定义一个指向指针的引用。</p>
<pre><code class="lang-c++">int i = 42;
int *p;
int *&amp;r = p; // r是指向p的引用，相当于p有另一个名字：r

r=&amp;i; // 相当于将p指向了i
*r=0; // 将i的值改为0
</code></pre>
<h3 id="练习-2">练习</h3>
<p><strong>练习2.25</strong> 说明下列变量的类型和值。</p>
<p>(a) int* ip, i, &amp;r = i; 	(b) int i, *ip = 0; 	(c) int * ip, ip2;</p>
<p>答：(a) ip是个int类型指针，i是int类型对象，r是一个指向i对象的int类型引用。</p>
<p>(b) i是个int类型对象，ip是个空的int类型指针。</p>
<p>(c) ip是个int类型的指针，ip2是个int类型的对象。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/NaviAvatar/Docfx/blob/master/Languages/Chapter2/2.3.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
